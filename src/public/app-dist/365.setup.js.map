{"version":3,"sources":["webpack://trilium/./src/public/app/dialogs/clone_to.js","webpack://trilium/./src/public/app/services/branches.js","webpack://trilium/./src/public/app/services/note_autocomplete.js"],"names":["$dialog","$","$form","$noteAutoComplete","$clonePrefix","$noteList","clonedNoteIds","async","showDialog","noteIds","noteId","includes","push","val","trigger","empty","note","append","text","title","on","notePath","getSelectedPath","modal","parentNoteId","targetBranchId","cloneNoteId","clonedNote","targetNote","getNote","cloneNotesTo","console","error","filterRootNote","branchIds","hoistedNoteId","filter","branchId","branch","makeToast","id","message","icon","taskType","type","taskId","progressCount","toast","closeAfter","moveBeforeBranch","branchIdsToMove","beforeBranchId","branchIdToMove","resp","success","alert","moveAfterBranch","afterBranchId","afterNote","reverse","moveToParentNote","newParentBranchId","branchToMove","getParentNote","deleteNotes","branchIdsToDelete","length","$deleteClonesCheckbox","attr","$nodeTitles","$confirmText","confirmDialog","confirm","deleteClones","find","is","counter","branchIdToDelete","query","moveNodeUpInHierarchy","node","getParent","data","noteType","getChildren","folder","renderTitle","cloneNoteAfter","cloneNoteTo","childNoteId","parentBranchId","prefix","autocompleteSource","term","cb","result","encodeURIComponent","pathTitle","path","clearText","$el","setSelectedPath","autocomplete","showRecentNotes","initNoteAutocomplete","options","hasClass","addClass","$clearTextButton","prop","$showRecentNotesButton","$goToSelectedNoteButton","$sideButtons","hideGoToSelectedNoteButton","after","e","appendTo","document","querySelector","hint","autoselect","openOnFocus","minLength","tabAutocomplete","source","displayKey","templates","suggestion","highlightedTitle","cache","event","trim","init","fn","this","closest","toggleClass"],"mappings":"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","file":"365.setup.js","sourcesContent":["import noteAutocompleteService from \"../services/note_autocomplete.js\";\nimport utils from \"../services/utils.js\";\nimport treeService from \"../services/tree.js\";\nimport toastService from \"../services/toast.js\";\nimport treeCache from \"../services/tree_cache.js\";\nimport branchService from \"../services/branches.js\";\n\nconst $dialog = $(\"#clone-to-dialog\");\nconst $form = $(\"#clone-to-form\");\nconst $noteAutoComplete = $(\"#clone-to-note-autocomplete\");\nconst $clonePrefix = $(\"#clone-prefix\");\nconst $noteList = $(\"#clone-to-note-list\");\n\nlet clonedNoteIds;\n\nexport async function showDialog(noteIds) {\n    clonedNoteIds = [];\n\n    for (const noteId of noteIds) {\n        if (!clonedNoteIds.includes(noteId)) {\n            clonedNoteIds.push(noteId);\n        }\n    }\n\n    utils.openDialog($dialog);\n\n    $noteAutoComplete.val('').trigger('focus');\n\n    $noteList.empty();\n\n    for (const noteId of clonedNoteIds) {\n        const note = await treeCache.getNote(noteId);\n\n        $noteList.append($(\"<li>\").text(note.title));\n    }\n\n    noteAutocompleteService.initNoteAutocomplete($noteAutoComplete);\n    noteAutocompleteService.showRecentNotes($noteAutoComplete);\n}\n\nasync function cloneNotesTo(notePath) {\n    const {noteId, parentNoteId} = treeService.getNoteIdAndParentIdFromNotePath(notePath);\n    const targetBranchId = await treeCache.getBranchId(parentNoteId, noteId);\n\n    for (const cloneNoteId of clonedNoteIds) {\n        await branchService.cloneNoteTo(cloneNoteId, targetBranchId, $clonePrefix.val());\n\n        const clonedNote = await treeCache.getNote(cloneNoteId);\n        const targetNote = await treeCache.getBranch(targetBranchId).getNote();\n\n        toastService.showMessage(`Note \"${clonedNote.title}\" has been cloned into ${targetNote.title}`);\n    }\n}\n\n$form.on('submit', () => {\n    const notePath = $noteAutoComplete.getSelectedPath();\n\n    if (notePath) {\n        $dialog.modal('hide');\n\n        cloneNotesTo(notePath);\n    }\n    else {\n        console.error(\"No path to clone to.\");\n    }\n\n    return false;\n});\n","import utils from './utils.js';\nimport server from './server.js';\nimport toastService from \"./toast.js\";\nimport treeCache from \"./tree_cache.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport ws from \"./ws.js\";\n\nasync function moveBeforeBranch(branchIdsToMove, beforeBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    if (beforeBranchId === 'root') {\n        alert('Cannot move notes before root note.');\n        return;\n    }\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const resp = await server.put(`branches/${branchIdToMove}/move-before/${beforeBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function moveAfterBranch(branchIdsToMove, afterBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    const afterNote = await treeCache.getBranch(afterBranchId).getNote();\n\n    if (afterNote.noteId === 'root' || afterNote.noteId === hoistedNoteService.getHoistedNoteId()) {\n        alert('Cannot move notes after root note.');\n        return;\n    }\n\n    branchIdsToMove.reverse(); // need to reverse to keep the note order\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const resp = await server.put(`branches/${branchIdToMove}/move-after/${afterBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function moveToParentNote(branchIdsToMove, newParentBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const branchToMove = treeCache.getBranch(branchIdToMove);\n\n        if (branchToMove.noteId === hoistedNoteService.getHoistedNoteId()\n            || (await branchToMove.getParentNote()).type === 'search') {\n            continue;\n        }\n\n        const resp = await server.put(`branches/${branchIdToMove}/move-to/${newParentBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function deleteNotes(branchIdsToDelete) {\n    branchIdsToDelete = filterRootNote(branchIdsToDelete);\n\n    if (branchIdsToDelete.length === 0) {\n        return false;\n    }\n\n    const $deleteClonesCheckbox = $('<div class=\"form-check\">')\n        .append($('<input type=\"checkbox\" class=\"form-check-input\" id=\"delete-clones-checkbox\">'))\n        .append($('<label for=\"delete-clones-checkbox\">')\n                    .text(\"delete also all note clones\")\n                    .attr(\"title\", \"all clones of selected notes will be deleted and as such the whole note will be deleted.\"));\n\n    const $nodeTitles = $(\"<ul>\");\n\n    for (const branchId of branchIdsToDelete) {\n        const note = await treeCache.getBranch(branchId).getNote();\n\n        $nodeTitles.append($(\"<li>\").text(note.title));\n    }\n\n    const $confirmText = $(\"<div>\")\n        .append($(\"<p>\").text('This will delete the following notes and their sub-notes: '))\n        .append($nodeTitles)\n        .append($deleteClonesCheckbox);\n\n    const confirmDialog = await import('../dialogs/confirm.js');\n\n    if (!await confirmDialog.confirm($confirmText)) {\n        return false;\n    }\n\n    const deleteClones = $deleteClonesCheckbox.find(\"input\").is(\":checked\");\n\n    const taskId = utils.randomString(10);\n\n    let counter = 0;\n\n    for (const branchIdToDelete of branchIdsToDelete) {\n        counter++;\n\n        const last = counter === branchIdsToDelete.length;\n        const query = `?taskId=${taskId}&last=${last ? 'true' : 'false'}`;\n\n        const branch = treeCache.getBranch(branchIdToDelete);\n\n        if (deleteClones) {\n            await server.remove(`notes/${branch.noteId}` + query);\n        }\n        else {\n            await server.remove(`branches/${branchIdToDelete}` + query);\n        }\n    }\n\n    return true;\n}\n\nasync function moveNodeUpInHierarchy(node) {\n    if (hoistedNoteService.isRootNode(node)\n        || hoistedNoteService.isTopLevelNode(node)\n        || node.getParent().data.noteType === 'search') {\n        return;\n    }\n\n    const resp = await server.put('branches/' + node.data.branchId + '/move-after/' + node.getParent().data.branchId);\n\n    if (!resp.success) {\n        alert(resp.message);\n        return;\n    }\n\n    if (!hoistedNoteService.isTopLevelNode(node) && node.getParent().getChildren().length <= 1) {\n        node.getParent().folder = false;\n        node.getParent().renderTitle();\n    }\n}\n\nfunction filterRootNote(branchIds) {\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    return branchIds.filter(branchId => {\n       const branch = treeCache.getBranch(branchId);\n\n        return branch.noteId !== 'root'\n            && branch.noteId !== hoistedNoteId;\n    });\n}\n\nfunction makeToast(id, message) {\n    return {\n        id: id,\n        title: \"Delete status\",\n        message: message,\n        icon: \"trash\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'delete-notes') {\n        return;\n    }\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message.taskId, \"Delete notes in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message.taskId, \"Delete finished successfully.\");\n        toast.closeAfter = 5000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'undelete-notes') {\n        return;\n    }\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message.taskId, \"Undeleting notes in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message.taskId, \"Undeleting notes finished successfully.\");\n        toast.closeAfter = 5000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nasync function cloneNoteTo(childNoteId, parentBranchId, prefix) {\n    const resp = await server.put(`notes/${childNoteId}/clone-to/${parentBranchId}`, {\n        prefix: prefix\n    });\n\n    if (!resp.success) {\n        alert(resp.message);\n    }\n}\n\n// beware that first arg is noteId and second is branchId!\nasync function cloneNoteAfter(noteId, afterBranchId) {\n    const resp = await server.put('notes/' + noteId + '/clone-after/' + afterBranchId);\n\n    if (!resp.success) {\n        alert(resp.message);\n    }\n}\n\nexport default {\n    moveBeforeBranch,\n    moveAfterBranch,\n    moveToParentNote,\n    deleteNotes,\n    moveNodeUpInHierarchy,\n    cloneNoteAfter,\n    cloneNoteTo\n};\n","import server from \"./server.js\";\nimport appContext from \"./app_context.js\";\nimport utils from './utils.js';\n\n// this key needs to have this value so it's hit by the tooltip\nconst SELECTED_PATH_KEY = \"data-note-path\";\n\nasync function autocompleteSource(term, cb) {\n    const result = await server.get('autocomplete'\n        + '?query=' + encodeURIComponent(term)\n        + '&activeNoteId=' + appContext.tabManager.getActiveTabNoteId());\n\n    if (result.length === 0) {\n        result.push({\n            pathTitle: \"No results\",\n            path: \"\"\n        });\n    }\n\n    cb(result);\n}\n\nfunction clearText($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\").trigger('change');\n}\n\nfunction showRecentNotes($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\");\n    $el.trigger('focus');\n}\n\nfunction initNoteAutocomplete($el, options) {\n    if ($el.hasClass(\"note-autocomplete-input\") || utils.isMobile()) {\n        return $el;\n    }\n\n    options = options || {};\n\n    $el.addClass(\"note-autocomplete-input\");\n\n    const $clearTextButton = $(\"<a>\")\n            .addClass(\"input-group-text input-clearer-button bx bx-x\")\n            .prop(\"title\", \"Clear text field\");\n\n    const $showRecentNotesButton = $(\"<a>\")\n            .addClass(\"input-group-text show-recent-notes-button bx bx-time\")\n            .prop(\"title\", \"Show recent notes\");\n\n    const $goToSelectedNoteButton = $(\"<a>\")\n        .addClass(\"input-group-text go-to-selected-note-button bx bx-arrow-to-right\")\n        .attr(\"data-action\", \"note\");\n\n    const $sideButtons = $(\"<div>\")\n        .addClass(\"input-group-append\")\n        .append($clearTextButton)\n        .append($showRecentNotesButton);\n\n    if (!options.hideGoToSelectedNoteButton) {\n        $sideButtons.append($goToSelectedNoteButton);\n    }\n\n    $el.after($sideButtons);\n\n    $clearTextButton.on('click', () => clearText($el));\n\n    $showRecentNotesButton.on('click', e => {\n        showRecentNotes($el);\n\n        // this will cause the click not give focus to the \"show recent notes\" button\n        // this is important because otherwise input will lose focus immediatelly and not show the results\n        return false;\n    });\n\n    $el.autocomplete({\n        appendTo: document.querySelector('body'),\n        hint: false,\n        autoselect: true,\n        openOnFocus: true,\n        minLength: 0,\n        tabAutocomplete: false\n    }, [\n        {\n            source: autocompleteSource,\n            displayKey: 'pathTitle',\n            templates: {\n                suggestion: function(suggestion) {\n                    return suggestion.highlightedTitle;\n                }\n            },\n            // we can't cache identical searches because notes can be created / renamed, new recent notes can be added\n            cache: false\n        }\n    ]);\n\n    $el.on('autocomplete:selected', (event, suggestion) => $el.setSelectedPath(suggestion.path));\n    $el.on('autocomplete:closed', () => {\n        if (!$el.val().trim()) {\n            clearText($el);\n        }\n    });\n\n    return $el;\n}\n\nfunction init() {\n    $.fn.getSelectedPath = function () {\n        if (!$(this).val().trim()) {\n            return \"\";\n        } else {\n            return $(this).attr(SELECTED_PATH_KEY);\n        }\n    };\n\n    $.fn.setSelectedPath = function (path) {\n        path = path || \"\";\n\n        $(this).attr(SELECTED_PATH_KEY, path);\n\n        $(this)\n            .closest(\".input-group\")\n            .find(\".go-to-selected-note-button\")\n            .toggleClass(\"disabled\", !path.trim())\n            .attr(SELECTED_PATH_KEY, path); // we also set attr here so tooltip can be displayed\n    };\n}\n\nexport default {\n    autocompleteSource,\n    initNoteAutocomplete,\n    showRecentNotes,\n    init\n}"],"sourceRoot":""}