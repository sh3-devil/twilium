{"version":3,"sources":["webpack://trilium/./src/public/app/dialogs/attributes.js"],"names":["$dialog","$","$saveAttributesButton","$ownedAttributesBody","AttributesModel","self","this","async","showAttributes","noteId","attributes","ownedAttributes","filter","attr","labelValue","type","value","relationValue","selectedPath","labelDefinition","labelType","multiplicityType","isPromoted","numberPrecision","relationDefinition","inverseRelation","map","ko","observable","addLastEmptyRow","inheritedAttributes","isDeleted","last","length","name","trim","push","attributeId","isInheritable","position","observableArray","availableTypes","text","availableLabelTypes","multiplicityTypes","typeChanged","data","event","getTargetAttribute","target","valueHasMutated","labelTypeChanged","updateAttributePositions","find","each","attribute","loadAttributes","setTimeout","trigger","deleteAttribute","attributeData","save","i","isEmptyName","isEmptyRelationTarget","isValid","alert","attributesToSave","JSON","stringify","attributeChanged","index","cur","contextFor","$index","attributesModel","showDialog","bindingHandlers","noteLink","init","element","valueAccessor","allBindings","viewModel","bindingContext","unwrap","link","append","noteAutocomplete","setSelectedPath","$data","on","suggestion","dataset","val","path","applyBindings","e","$el","attributeType","open"],"mappings":"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","file":"31.desktop.js","sourcesContent":["import server from '../services/server.js';\nimport toastService from \"../services/toast.js\";\nimport treeService from \"../services/tree.js\";\nimport attributeAutocompleteService from \"../services/attribute_autocomplete.js\";\nimport utils from \"../services/utils.js\";\nimport linkService from \"../services/link.js\";\nimport libraryLoader from \"../services/library_loader.js\";\nimport noteAutocompleteService from \"../services/note_autocomplete.js\";\nimport appContext from \"../services/app_context.js\";\n\nconst $dialog = $(\"#attributes-dialog\");\nconst $saveAttributesButton = $(\"#save-attributes-button\");\nconst $ownedAttributesBody = $('#owned-attributes-table tbody');\n\nfunction AttributesModel() {\n    const self = this;\n\n    this.ownedAttributes = ko.observableArray();\n    this.inheritedAttributes = ko.observableArray();\n\n    this.availableTypes = [\n        { text: \"Label\", value: \"label\" },\n        { text: \"Label definition\", value: \"label-definition\" },\n        { text: \"Relation\", value: \"relation\" },\n        { text: \"Relation definition\", value: \"relation-definition\" }\n    ];\n\n    this.availableLabelTypes = [\n        { text: \"Text\", value: \"text\" },\n        { text: \"Number\", value: \"number\" },\n        { text: \"Boolean\", value: \"boolean\" },\n        { text: \"Date\", value: \"date\" },\n        { text: \"URL\", value: \"url\"}\n    ];\n\n    this.multiplicityTypes = [\n        { text: \"Single value\", value: \"singlevalue\" },\n        { text: \"Multi value\", value: \"multivalue\" }\n    ];\n\n    this.typeChanged = function(data, event) {\n        self.getTargetAttribute(event.target).valueHasMutated();\n    };\n\n    this.labelTypeChanged = function(data, event) {\n        self.getTargetAttribute(event.target).valueHasMutated();\n    };\n\n    this.updateAttributePositions = function() {\n        let position = 10;\n\n        // we need to update positions by searching in the DOM, because order of the\n        // attributes in the viewmodel (self.ownedAttributes()) stays the same\n        $ownedAttributesBody.find('input[name=\"position\"]').each(function() {\n            const attribute = self.getTargetAttribute(this);\n\n            attribute().position = position;\n            position += 10;\n        });\n    };\n\n    async function showAttributes(noteId, attributes) {\n        const ownedAttributes = attributes.filter(attr => attr.noteId === noteId);\n\n        for (const attr of ownedAttributes) {\n            attr.labelValue = attr.type === 'label' ? attr.value : '';\n            attr.relationValue = attr.type === 'relation' ? (await treeService.getNoteTitle(attr.value)) : '';\n            attr.selectedPath = attr.type === 'relation' ? attr.value : '';\n            attr.labelDefinition = (attr.type === 'label-definition' && attr.value) ? attr.value : {\n                labelType: \"text\",\n                multiplicityType: \"singlevalue\",\n                isPromoted: true,\n                numberPrecision: 0\n            };\n\n            attr.relationDefinition = (attr.type === 'relation-definition' && attr.value) ? attr.value : {\n                multiplicityType: \"singlevalue\",\n                inverseRelation: \"\",\n                isPromoted: true\n            };\n\n            delete attr.value;\n        }\n\n        self.ownedAttributes(ownedAttributes.map(ko.observable));\n\n        addLastEmptyRow();\n\n        const inheritedAttributes = attributes.filter(attr => attr.noteId !== noteId);\n\n        self.inheritedAttributes(inheritedAttributes);\n    }\n\n    this.loadAttributes = async function() {\n        const noteId = appContext.tabManager.getActiveTabNoteId();\n\n        const attributes = await server.get('notes/' + noteId + '/attributes');\n\n        await showAttributes(noteId, attributes);\n\n        // attribute might not be rendered immediatelly so could not focus\n        setTimeout(() => $(\".attribute-type-select:last\").trigger('focus'), 1000);\n    };\n\n    this.deleteAttribute = function(data, event) {\n        const attribute = self.getTargetAttribute(event.target);\n        const attributeData = attribute();\n\n        if (attributeData) {\n            attributeData.isDeleted = true;\n\n            attribute(attributeData);\n\n            addLastEmptyRow();\n        }\n    };\n\n    function isValid() {\n        for (let attributes = self.ownedAttributes(), i = 0; i < attributes.length; i++) {\n            if (self.isEmptyName(i) || self.isEmptyRelationTarget(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    this.save = async function() {\n        // we need to defocus from input (in case of enter-triggered save) because value is updated\n        // on blur event (because of conflict with jQuery UI Autocomplete). Without this, input would\n        // stay in focus, blur wouldn't be triggered and change wouldn't be updated in the viewmodel.\n        $saveAttributesButton.trigger('focus');\n\n        if (!isValid()) {\n            alert(\"Please fix all validation errors and try saving again.\");\n            return;\n        }\n\n        self.updateAttributePositions();\n\n        const noteId = appContext.tabManager.getActiveTabNoteId();\n\n        const attributesToSave = self.ownedAttributes()\n            .map(attribute => attribute())\n            .filter(attribute => attribute.attributeId !== \"\" || attribute.name !== \"\");\n\n        for (const attr of attributesToSave) {\n            if (attr.type === 'label') {\n                attr.value = attr.labelValue;\n            }\n            else if (attr.type === 'relation') {\n                attr.value = treeService.getNoteIdFromNotePath(attr.selectedPath);\n            }\n            else if (attr.type === 'label-definition') {\n                attr.value = JSON.stringify(attr.labelDefinition);\n            }\n            else if (attr.type === 'relation-definition') {\n                attr.value = JSON.stringify(attr.relationDefinition);\n            }\n\n            delete attr.labelValue;\n            delete attr.relationValue;\n            delete attr.labelDefinition;\n            delete attr.relationDefinition;\n        }\n\n        const attributes = await server.put('notes/' + noteId + '/attributes', attributesToSave);\n\n        await showAttributes(noteId, attributes);\n\n        toastService.showMessage(\"Attributes have been saved.\");\n    };\n\n    function addLastEmptyRow() {\n        const attributes = self.ownedAttributes().filter(attr => !attr().isDeleted);\n        const last = attributes.length === 0 ? null : attributes[attributes.length - 1]();\n\n        if (!last || last.name.trim() !== \"\") {\n            self.ownedAttributes.push(ko.observable({\n                attributeId: '',\n                type: 'label',\n                name: '',\n                labelValue: '',\n                relationValue: '',\n                isInheritable: false,\n                isDeleted: false,\n                position: 0,\n                labelDefinition: {\n                    labelType: \"text\",\n                    multiplicityType: \"singlevalue\",\n                    isPromoted: true,\n                    numberPrecision: 0\n                },\n                relationDefinition: {\n                    multiplicityType: \"singlevalue\",\n                    inverseRelation: \"\",\n                    isPromoted: true\n                }\n            }));\n        }\n    }\n\n    this.attributeChanged = function (data, event) {\n        addLastEmptyRow();\n\n        const attribute = self.getTargetAttribute(event.target);\n\n        attribute.valueHasMutated();\n    };\n\n    this.isEmptyName = function(index) {\n        const cur = self.ownedAttributes()[index]();\n\n        if (cur.name.trim() || cur.isDeleted) {\n            return false;\n        }\n\n        if (cur.attributeId) {\n            // name is empty and attribute already exists so this is NO-GO\n            return true;\n        }\n\n        if (cur.type === 'relation-definition' || cur.type === 'label-definition') {\n            // for definitions there's no possible empty value so we always require name\n            return true;\n        }\n\n        if (cur.type === 'label' && cur.labelValue) {\n            return true;\n        }\n\n        if (cur.type === 'relation' && cur.relationValue) {\n            return true;\n        }\n\n        return false;\n    };\n\n    this.isEmptyRelationTarget = function(index) {\n        const cur = self.ownedAttributes()[index]();\n\n        return cur.type === \"relation\" && !cur.isDeleted && cur.name && !cur.relationValue;\n    };\n\n    this.getTargetAttribute = function(target) {\n        const context = ko.contextFor(target);\n        const index = context.$index();\n\n        return self.ownedAttributes()[index];\n    }\n}\n\nlet attributesModel;\n\nfunction initKoPlugins() {\n    ko.bindingHandlers.noteLink = {\n        init: async function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            const noteId = ko.unwrap(valueAccessor());\n\n            if (noteId) {\n                const link = await linkService.createNoteLink(noteId);\n\n                $(element).append(link);\n            }\n        }\n    };\n\n    ko.bindingHandlers.noteAutocomplete = {\n        init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            noteAutocompleteService.initNoteAutocomplete($(element));\n\n            $(element).setSelectedPath(bindingContext.$data.selectedPath);\n\n            $(element).on('autocomplete:selected', function (event, suggestion, dataset) {\n                bindingContext.$data.selectedPath = $(element).val().trim() ? suggestion.path : '';\n            });\n        }\n    };\n}\n\nexport async function showDialog() {\n    await libraryLoader.requireLibrary(libraryLoader.KNOCKOUT);\n\n    // lazily apply bindings on first use\n    if (!attributesModel) {\n        attributesModel = new AttributesModel();\n\n        initKoPlugins();\n\n        ko.applyBindings(attributesModel, $dialog[0]);\n    }\n\n    await attributesModel.loadAttributes();\n\n    utils.openDialog($dialog);\n}\n\n$dialog.on('focus', '.attribute-name', function (e) {\n    attributeAutocompleteService.initAttributeNameAutocomplete({\n        $el: $(this),\n        attributeType: () => {\n            const attribute = attributesModel.getTargetAttribute(this);\n            return (attribute().type === 'relation' || attribute().type === 'relation-definition') ? 'relation' : 'label';\n        },\n        open: true\n    });\n});\n\n$dialog.on('focus', '.label-value', function (e) {\n    attributeAutocompleteService.initLabelValueAutocomplete({\n        $el: $(this),\n        open: true\n    })\n});\n"],"sourceRoot":""}