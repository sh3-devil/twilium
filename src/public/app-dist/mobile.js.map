{"version":3,"sources":["webpack://trilium/./src/public/app/entities/attribute.js","webpack://trilium/./src/public/app/entities/branch.js","webpack://trilium/./src/public/app/services/dialog_command_executor.js","webpack://trilium/./src/public/app/services/entrypoints.js","webpack://trilium/./src/public/app/services/zoom.js","webpack://trilium/./src/public/app/services/tab_context.js","webpack://trilium/./src/public/app/services/tab_manager.js","webpack://trilium/./src/public/app/widgets/mobile_widgets/mobile_screen_switcher.js","webpack://trilium/./src/public/app/services/main_tree_executors.js","webpack://trilium/./src/public/app/services/app_context.js","webpack://trilium/./src/public/app/services/attribute_autocomplete.js","webpack://trilium/./src/public/app/services/branches.js","webpack://trilium/./src/public/app/services/bundle.js","webpack://trilium/./src/public/app/services/clipboard.js","webpack://trilium/./src/public/app/services/context_menu.js","webpack://trilium/./src/public/app/services/date_notes.js","webpack://trilium/./src/public/app/services/hoisted_note.js","webpack://trilium/./src/public/app/services/keyboard_actions.js","webpack://trilium/./src/public/app/services/library_loader.js","webpack://trilium/./src/public/app/services/link.js","webpack://trilium/./src/public/app/services/mime_types.js","webpack://trilium/./src/public/app/services/note_attribute_cache.js","webpack://trilium/./src/public/app/services/note_autocomplete.js","webpack://trilium/./src/public/app/services/note_create.js","webpack://trilium/./src/public/app/services/options.js","webpack://trilium/./src/public/app/services/protected_session.js","webpack://trilium/./src/public/app/services/protected_session_holder.js","webpack://trilium/./src/public/app/services/note_tooltip.js","webpack://trilium/./src/public/app/widgets/collapsible_widget.js","webpack://trilium/./src/public/app/widgets/tab_caching_widget.js","webpack://trilium/./src/public/app/services/frontend_script_api.js","webpack://trilium/./src/public/app/services/script_context.js","webpack://trilium/./src/public/app/services/server.js","webpack://trilium/./src/public/app/services/spaced_update.js","webpack://trilium/./src/public/app/services/toast.js","webpack://trilium/./src/public/app/services/tree.js","webpack://trilium/./src/public/app/entities/note_short.js","webpack://trilium/./src/public/app/entities/note_complement.js","webpack://trilium/./src/public/app/services/tree_cache.js","webpack://trilium/./src/public/app/services/utils.js","webpack://trilium/./src/public/app/services/load_results.js","webpack://trilium/./src/public/app/services/ws.js","webpack://trilium/./src/public/app/services|sync","webpack://trilium/./src/public/app/widgets/basic_widget.js","webpack://trilium/./src/public/app/widgets/component.js","webpack://trilium/./src/public/app/widgets/tab_aware_widget.js","webpack://trilium/webpack/bootstrap","webpack://trilium/webpack/runtime/define property getters","webpack://trilium/webpack/runtime/ensure chunk","webpack://trilium/webpack/runtime/get javascript chunk filename","webpack://trilium/webpack/runtime/hasOwnProperty shorthand","webpack://trilium/webpack/runtime/make namespace object","webpack://trilium/webpack/runtime/publicPath","webpack://trilium/webpack/runtime/jsonp chunk loading","webpack://trilium/./src/public/app/widgets/flex_container.js","webpack://trilium/./src/public/app/widgets/note_title.js","webpack://trilium/./src/public/app/widgets/type_widgets/type_widget.js","webpack://trilium/./src/public/app/services/render.js","webpack://trilium/./src/public/app/services/note_content_renderer.js","webpack://trilium/./src/public/app/widgets/type_widgets/abstract_text_type_widget.js","webpack://trilium/./src/public/app/widgets/type_widgets/editable_text.js","webpack://trilium/./src/public/app/widgets/type_widgets/image.js","webpack://trilium/./src/public/app/widgets/type_widgets/relation_map.js","webpack://trilium/./src/public/app/widgets/type_widgets/book.js","webpack://trilium/./src/public/app/widgets/note_detail.js","webpack://trilium/./src/public/app/widgets/type_widgets/empty.js","webpack://trilium/./src/public/app/widgets/type_widgets/deleted.js","webpack://trilium/./src/public/app/widgets/type_widgets/read_only_text.js","webpack://trilium/./src/public/app/widgets/type_widgets/editable_code.js","webpack://trilium/./src/public/app/widgets/type_widgets/read_only_code.js","webpack://trilium/./src/public/app/widgets/type_widgets/file.js","webpack://trilium/./src/public/app/widgets/type_widgets/search.js","webpack://trilium/./src/public/app/widgets/type_widgets/render.js","webpack://trilium/./src/public/app/widgets/type_widgets/protected_session.js","webpack://trilium/./src/public/app/services/sync.js","webpack://trilium/./src/public/app/widgets/note_tree.js","webpack://trilium/./src/public/app/widgets/mobile_widgets/mobile_global_buttons.js","webpack://trilium/./src/public/app/widgets/mobile_widgets/close_detail_button.js","webpack://trilium/./src/public/app/widgets/mobile_widgets/mobile_detail_menu.js","webpack://trilium/./src/public/app/widgets/mobile_widgets/screen_container.js","webpack://trilium/./src/public/app/services/glob.js","webpack://trilium/./src/public/app/mobile.js","webpack://trilium/./src/public/app/layouts/mobile_layout.js"],"names":["treeCache","row","this","update","attributeId","noteId","type","name","value","position","isInheritable","notes","undefined","JSON","parse","e","affectedNote","attrNote","getNote","owningNotes","getTemplateNotes","owningNote","hasAncestor","branchId","parentNoteId","notePosition","prefix","isExpanded","isDeleted","DialogCommandExecutor","then","d","showDialog","showCurrentNoteRevisions","importMarkdownInline","notePath","noteIds","branchIds","Entrypoints","super","jQuery","hotkeys","options","filterInputAcceptingElements","filterContentEditable","filterTextInputs","$","document","on","async","linkEl","event","target","attr","noteRevisionId","showNoteRevisionsDialog","utils","remote","getCurrentWindow","toggleDevTools","FindInPage","getCurrentWebContents","offsetTop","offsetRight","boxBgColor","boxShadowColor","inputColor","inputBgColor","inputFocusColor","textColor","textHoverBgColor","caseSelectedColor","openFindWindow","todayNote","note","server","title","content","isProtected","ws","hoistedNoteId","win","isFullScreenable","setFullScreen","isFullScreen","$widget","find","hide","zenModeActive","removeClass","addClass","$logoutForm","append","glob","csrfToken","trigger","webContents","activeIndex","parseInt","getActiveIndex","goToIndex","window","history","back","forward","searchText","response","encodeURIComponent","success","triggerEvent","results","toast","ipcRenderer","send","url","location","protocol","host","pathname","open","openInWindowCommand","mime","endsWith","bundle","ZoomService","setZoomFactor","zoomFactor","parseFloat","webFrame","console","log","getZoomFactor","setZoomFactorAndSave","getCurrentZoom","TabContext","tabId","tabContext","inputNotePath","triggerSwitchEvent","tree","error","autoBookDisabled","textPreviewDisabled","codePreviewDisabled","setTimeout","active","isActive","loadResults","isNoteReloaded","TabManager","activeTabId","tabsUpdate","openTabs","tabContexts","map","tc","getTabState","filter","t","stringify","children","tabsToOpen","hash","substr","tab","foundTab","push","filteredTabs","openTab","length","isMainWindow","allowUpdateWithoutChange","openTabWithNote","setCurrentNotePathToHash","scheduleUpdate","activeTabContext","getActiveTabContext","pushState","getTabContextById","activeContext","activeNote","getActiveTabNote","openEmptyTab","activateTab","setNote","setEmpty","child","activate","getTabContexts","tabContextToRemove","autocomplete","openAndActivateEmptyTab","findIndex","activatePreviousTabCommand","activateNextTabCommand","tabIdsInOrder","order","i","sort","a","b","oldIdx","newActiveTabId","removeTab","updateNowIfNecessary","tabIdToRemove","triggerCommand","splice","split","includes","MobileScreenSwitcherExecutor","screen","activeScreen","setActiveScreenCommand","MainTreeExecutors","selectedOrActiveNoteIds","getSelectedOrActiveNodes","node","data","selectedOrActiveBranchIds","saveSelection","getActiveNode","targetBranchId","AppContext","executors","layout","Promise","all","showWidgets","tabManager","loadTabs","rootWidget","getRootWidget","$renderedWidget","render","commandName","closest","prop","$el","executor","zoom","handleEvent","fun","callMethod","debug","el","appContext","startsWith","isNotePathInAddress","switchToTab","initAttributeNameAutocomplete","attributeType","hasClass","appendTo","querySelector","hint","openOnFocus","minLength","tabAutocomplete","displayKey","cache","source","term","cb","initLabelValueAutocomplete","attributeName","parent","val","trim","attributeValues","attribute","toLowerCase","filterRootNote","branch","makeToast","id","message","icon","taskType","taskId","progressCount","closeAfter","moveBeforeBranch","branchIdsToMove","beforeBranchId","branchIdToMove","resp","alert","moveAfterBranch","afterBranchId","afterNote","reverse","moveToParentNote","newParentBranchId","branchToMove","getParentNote","deleteNotes","branchIdsToDelete","$deleteClonesCheckbox","text","$nodeTitles","$confirmText","confirmDialog","confirm","deleteClones","is","counter","branchIdToDelete","query","moveNodeUpInHierarchy","getParent","noteType","getChildren","folder","renderTitle","cloneNoteAfter","cloneNoteTo","childNoteId","parentBranchId","getAndExecuteBundle","originEntity","executeBundle","$container","apiContext","allNoteIds","eval","script","call","executeStartupBundles","scriptBundles","WidgetsByParent","byParent","widget","parentWidget","parentName","getWidgetBundlesByParent","widgetsByParent","add","clipboardBranchIds","clipboardMode","isClipboardEmpty","pasteAfter","clipboardBranches","clipboardBranch","clipboardNote","pasteInto","mode","cut","copy","dateContextMenuOpenedMs","empty","addItems","items","positionMenu","Date","now","clientHeight","documentElement","contextMenuHeight","outerHeight","top","y","css","display","left","x","$parent","item","$icon","uiIcon","$link","$item","stopPropagation","handler","selectMenuItemHandler","enabled","$subMenu","getDateNote","date","getTodayNote","dayjs","format","getMonthNote","month","getYearNote","year","getHoistedNoteId","setHoistedNoteId","unhoist","isRootNode","isTopLevelNode","checkNoteAccess","runNotePath","keyboardActionRepo","keyboardActionsLoaded","actions","actionName","action","effectiveShortcuts","shortcut","getActionsForScope","scope","getAction","silent","Error","shortcutForNotes","setElementActionHandler","updateDisplayedShortcuts","each","join","shortcuts","newTitle","setupActionsForElement","component","loadedScriptPromises","requireScript","ajax","dataType","requireCss","Array","from","querySelectorAll","href","some","l","requireLibrary","library","cssUrl","js","scriptUrl","CKEDITOR","CODE_MIRROR","ESLINT","COMMONMARK","RELATION_MAP","LINK_MAP","PRINT_THIS","KNOCKOUT","CALENDAR_WIDGET","getNotePathFromUrl","notePathMatch","exec","getNotePathFromLink","notePathAttr","goToLink","preventDefault","which","ctrlKey","address","linkContextMenu","pageX","pageY","command","createNoteLink","noteTitle","showTooltip","showNotePath","$noteLink","pop","parentNotePath","MIME_TYPES_DICT","default","mimeTypes","loadMimeTypes","enabledMimeTypes","mt","getMimeTypes","attributes","autocompleteSource","result","pathTitle","path","clearText","setSelectedPath","showRecentNotes","initNoteAutocomplete","$clearTextButton","$showRecentNotesButton","$goToSelectedNoteButton","$sideButtons","hideGoToSelectedNoteButton","after","autoselect","templates","suggestion","highlightedTitle","init","fn","getSelectedPath","toggleClass","createNote","Object","assign","selectedHtml","dom","parseHTML","tagName","match","replace","outerHTML","parseSelectedHtml","cutToNote","getSelectedHtml","newNoteName","removeSelection","createNewTopLevelNote","duplicateNote","origNote","initializedPromise","load","arr","key","keys","set","payload","protectedSessionDeferred","enterProtectedSession","dfd","Deferred","resolve","dialog","show","promise","protectingLabel","protect","protectNote","includingSubtree","leaveProtectedSession","setupProtectedSession","password","enterProtectedSessionOnServer","protectedSessionId","reloadData","close","lastProtectedSessionOperationDate","setProtectedSessionId","resetProtectedSession","isProtectedSessionAvailable","touchProtectedSession","setInterval","protectedSessionTimeout","touchProtectedSessionIfNecessary","mouseEnterHandler","noteComplement","html","getAttributes","promoted","json","jsonValue","isPromoted","$table","definitionAttr","definitionType","valueType","valueAttrs","valueAttr","$value","$row","renderTooltip","tooltip","delay","container","placement","boundary","template","sanitize","mouseLeaveHandler","CollapsibleWidget","componentId","$bodyWrapper","widgetName","widgetTitle","collapse","saveCollapsed","$body","$title","$help","help","$headerActions","headerActions","initialized","doRenderBody","decorateWidget","toString","TabCachingWidget","widgetFactory","widgets","toggleExt","remove","ch","isTab","hasBeenAlreadyShown","handleEventInChildren","startNote","currentNote","$pluginButtons","prepareParams","params","p","TabAwareWidget","BasicWidget","activateNote","activateNewNote","addButtonToToolbar","opts","buttonId","button","replaceWith","runOnBackend","ret","startNoteId","currentNoteId","originEntityName","originEntityId","maxSyncId","executionResult","runOnServer","searchForNotes","api","searchString","searchForNote","getNotes","silentNotFoundError","reloadNotes","getInstanceName","instanceName","formatDateISO","parseDate","showMessage","showError","refreshTree","addTextToActiveTabEditor","getActiveTabTextEditor","callback","getActiveTabNotePath","setupElementTooltip","protectActiveNote","protectSubTree","bindGlobalShortcut","waitUntilSynced","refreshIncludedNote","includedNoteId","modules","allNotes","apis","require","moduleNoteIds","moduleName","c","exports","getHeaders","headers","allHeaders","sourceId","headerName","cookie","reqResolves","maxKnownSyncId","method","start","ipc","requestId","reject","baseApiUrl","end","PROFILING_LOG","maxSyncIdStr","Math","max","body","res","rej","timeout","textStatus","jqXhr","respHeaders","getAllResponseHeaders","forEach","line","parts","header","shift","toastService","throwError","contentType","arg","get","post","put","getMaxKnownSyncId","SpacedUpdate","updater","updateInterval","lastUpdated","changed","changeForbidden","triggerUpdate","$toast","autohide","showAndLogError","showPersistent","closePersistent","getRunPath","logErrors","effectivePath","parents","getParentNotes","someNotePath","getSomeNotePath","pathToRoot","cur","getNoteTitle","parentToBranch","sortAlphabetically","resolveNotePath","runPath","getParentProtectedStatus","getNotePath","getNoteIdFromNotePath","getNoteIdAndParentIdFromNotePath","getNotePathTitle","titlePath","getHashValueFromAddress","parseNotePath","concat","LABEL","targetRelations","childToBranch","contentLength","branchIdPos","values","getBranch","getContent","getBranches","getNotesFromCache","attrs","Boolean","__filterAttrs","__getCachedAttributes","ownedAttributes","getOwnedAttributes","attrArrs","newPath","templateAttr","oa","templateNote","parentNote","__getInheritableAttributes","flat","getAttribute","getOwnedAttribute","hasOwnedAttribute","hasAttribute","getOwnedAttributeValue","getAttributeValue","targets","getRelationTargets","relations","getRelations","relation","rel","ancestorNote","__attributeCache","getNoteComplement","dto","getLabels","dateCreated","dateModified","utcDateCreated","utcDateModified","loadInitialTree","loadParents","branches","noteComplementPromises","addResp","additiveLoad","Set","missingNoteIds","existingNotes","has","newResp","noteRows","branchRows","attributeRows","noteRow","oldNote","childNote","branchRow","addParent","addChild","attributeRow","targetNote","searchResults","index","trace","padNum","num","formatTime","getHours","getMinutes","formatTimeWithSeconds","getSeconds","formatDate","getFullYear","getMonth","getDate","isElectron","process","entityMap","formatValueWithWhitespace","test","bindElShortcut","keyboardShortcut","isDesktop","normalizeShortcut","bind","device","navigator","userAgent","closeActiveDialog","activeDialog","modal","$lastFocusedElement","saveFocusedElement","focusSavedElement","editing","view","focus","dynamicRequire","reloadApp","reload","str","stack","formatDateTime","localNowDateTime","isMac","platform","indexOf","assertArguments","arguments","escapeHtml","s","stopWatch","what","func","tookMs","getTime","formatLabel","label","download","downloadURL","toObject","array","obj","randomString","len","possible","charAt","floor","random","isMobile","setCookie","expires","toUTCString","setSessionCookie","getCookie","valueMatch","getNoteTypeClass","getMimeTypeClass","semicolonIdx","openDialog","$dialog","isHtmlEmpty","clearBrowserCache","session","clearCache","getUrlForDownload","URL","hostname","port","getHost","copySelectionToClipboard","getSelection","clipboard","writeText","isCKEditorInitialized","timeLimit","limitMs","resolved","LoadResults","noteIdToSourceId","sourceIdToNoteIds","noteReorderings","noteRevisions","contentNoteIdToSourceId","nr","sourceIds","sId","$outstandingSyncsCount","messageHandlers","lastPingTs","lastAcceptedSyncId","maxSyncIdAtLoad","lastProcessedSyncId","syncDataQueue","logError","readyState","subscribeToMessages","messageHandler","consumeQueuePromise","processedSyncIds","handleMessage","syncRows","outstandingSyncs","filteredRows","entityName","entityId","logRows","sendPing","allSyncRows","nonProcessedSyncRows","sync","entity","addNote","addBranch","positions","addNoteReordering","sourceNote","addAttribute","addNoteContent","addNoteRevision","addOption","isEmpty","hasAttributeRelatedChanges","processSyncRows","syncRow","syncIdReachedListeners","desiredSyncId","resolvePromise","consumeSyncData","waitForSyncId","connectWebSocket","loc","webSocketUri","WebSocket","onopen","onmessage","OPEN","lastSyncId","CLOSED","CLOSING","waitForMaxKnownSyncId","webpackEmptyContext","req","code","module","style","classes","className","class","block","cssEl","doRender","toggleInt","isEnabled","Component","components","setParent","promises","refreshWithNote","noteSwitched","refresh","activeTabChanged","isNote","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","m","definition","o","defineProperty","enumerable","f","chunkId","reduce","u","prototype","hasOwnProperty","r","Symbol","toStringTag","installedChunks","8","j","installedChunkData","onScriptComplete","createElement","charset","nc","setAttribute","src","onerror","onload","clearTimeout","reportError","loadingEnded","errorType","realSrc","request","head","appendChild","jsonpArray","oldJsonpFunction","chunkIds","moreModules","runtime","resolves","parentJsonpFunction","FlexContainer","direction","positionCounter","NoteTitleWidget","spacedUpdate","$noteTitle","setProtectedStatus","TypeWidget","constructor","getType","getWidgetType","cleanup","doRefresh","scrollTop","renderNoteIds","toggle","renderNoteId","$scriptContainer","getRenderedContent","getRenderingType","$rendered","fullNote","getFileUrl","$downloadButton","$openButton","$pdfPreview","ctx","$button","getCssClass","renderedContent","AbstractTextTypeWidget","isErased","_","loadIncludedNote","mentionSetup","feeds","marker","feed","queryText","rows","link","itemRenderer","itemElement","classList","innerHTML","minimumCharacters","$imageWrapper","$imageView","$copyToClipboardButton","$uploadNewRevisionButton","$uploadNewRevisionInput","$fileName","$fileType","$fileSize","$imageDownloadButton","selectImage","execCommand","removeAllRanges","removeAttr","fileToUpload","files","formData","FormData","processData","uploaded","attributeMap","originalFileName","imageHash","element","selection","range","createRange","selectNodeContents","addRange","uniDirectionalOverlays","foldback","cssClass","biDirectionalOverlays","inverseRelationsOverlays","linkOverlays","containerCounter","ZOOMS","1","width","height","2","3","4","5","6","typeWidgetClasses","$autoComplete","dataset","$editor","initEditor","codeBlockLanguages","language","textEditor","BalloonEditor","create","placeholder","mention","codeBlock","languages","model","isDev","setData","getData","dateString","addTextToEditor","linkHref","linkTitle","change","writer","insertPosition","getFirstPosition","insertText","hasSelection","execute","addLinkToEditor","isCollapsed","boxSize","insertContent","imageElement","$content","loadReferenceLinkTitle","CodeMirror","keyMap","modeURL","codeEditor","viewportMargin","Infinity","indentUnit","matchBrackets","matchTags","bothTags","highlightSelectionMatches","showToken","annotateScrollbar","lint","gutters","lineNumbers","tabindex","lineWrapping","dragDrop","setValue","clearHistory","info","findModeByMIME","setOption","autoLoadMode","getValue","$fileNoteId","$previewContent","$searchString","$component","SEARCH_HELP_TEXT","$noteDetailRenderHelp","$noteDetailRenderContent","$relationMapContainer","$createChildNote","$zoomInButton","$zoomOutButton","$resetPanZoomButton","mapData","jsPlumbInstance","pzInstance","$relationMapWrapper","getMousePosition","createNoteBox","saveData","contextMenuHandler","promptDialog","ask","defaultValue","zoomTo","getZoom","moveTo","ev","dropNoteOntoRelationMapHandler","jsPlumb","ready","originalTarget","$noteBox","idToNoteId","confirmDeleteNoteBoxWithNote","noteIdToId","isDeleteNoteChecked","sourceNoteId","targetNoteId","transform","scale","loadMapData","initJsPlumbInstance","initPanZoom","loadNotesAndRelations","deleteEveryEndpoint","inverseRelations","noteTitles","batch","clearMap","connection","connect","getOverlay","setLabel","canvas","panzoom","maxZoom","minZoom","smoothScroll","filterKey","dx","dy","dz","altKey","setZoom","saveCurrentTransform","newTransform","getTransform","dispose","getInstance","Endpoint","radius","Connector","ConnectionOverlays","HoverPaintStyle","stroke","strokeWidth","Container","registerConnectionType","anchor","connector","overlays","originalEvent","connectionCreatedHandler","deleteConnection","shown","$answer","infoDialog","mousedown","getContainer","draggable","drag","stop","finalPos","makeSource","connectorStyle","connectionType","extract","makeTarget","dropOptions","hoverClass","allowLoopback","matches","dataTransfer","n","evt","rect","getBoundingClientRect","clientX","clientY","$passwordForm","$passwordInput","$expandChildrenButton","zoomLevel","$unexpandedLinks","$card","expandCard","renderIntoElement","getDefaultZoomLevel","isAutoBook","$addTextLink","getLabelValue","childNotes","getChildNotes","imageLinks","renderNote","childCount","getChildNoteIds","w","NoteDetailWidget","typeWidgets","getTypeWidget","uploadFiles","safeImport","shrinkImages","textImportedAsText","codeImportedAsCode","explodeArchives","clazz","typeWidget","setupClasses","hasChildren","hasLabel","printThis","footer","importCSS","loadCSS","isNoteContentReloaded","isAffecting","syncNow","forceNoteSync","NOTE_TYPE_ICONS","NoteTreeWidget","treeName","$tree","refreshSearch","ui","fancytree","getNode","$treeSettingsPopup","$hideArchivedNotesCheckbox","$hideIncludedImages","$treeSettingsButton","hideArchivedNotes","hideIncludedImages","offsetLeft","outerWidth","$saveTreeSettingsButton","setHideArchivedNotes","setHideIncludedImages","reloadTreeFromCache","initFancyTree","setupNoteTitleTooltip","currentTarget","$sub","conOffset","offset","conDistanceFromTop","conDistanceFromLeft","subOffset","subDistanceFromTop","subDistanceFromLeft","isEnclosing","innerText","treeData","prepareRootNode","titlesTabbable","autoScroll","keyboard","extensions","scrollParent","minExpandLevel","click","targetType","shiftKey","setSelected","isSelected","setFocus","reactivate","setActive","clearSelectedNodes","expand","setExpanded","keydown","getHotKeys","dnd5","autoExpandMS","dragStart","dragEnter","dragOver","hitMode","jsonStr","selectedBranchIds","lazyLoad","prepareChildren","clones","highlightActiveClones","enhanceTitle","$span","span","unhoistButton","refreshSearchButton","loadChildren","visit","subNode","isUndefined","TreeContextMenu","getTree","hoistedBranch","hoistedNote","prepareNode","prepareSearchNoteChildren","prepareNormalNoteChildren","isFolder","iconClass","getIconClass","extraClasses","getExtraClasses","getIcon","refKey","lazy","expanded","getChildBranches","noteList","childBranches","newNote","getParentNoteIds","stopOnParents","getSelectedNodes","nodes","getNodesByNoteId","batchUpdate","noEvents","setExpandedStatusForSubtree","getFocusNode","selectedNode","expandToNote","makeVisible","scrollIntoView","parentNode","isLoaded","updateNode","foundChildNode","findChildNode","childNode","getNodeFromPath","list","getNodesByRef","collapseTree","oldActiveNode","oldActiveNodeFocused","hasFocus","newActiveNode","isVisible","noFocus","activeNode","enableUpdate","activeNodeFocused","nextNode","getNextSibling","getPrevSibling","activeNotePath","nextNotePath","activeNoteId","noteIdsToUpdate","noteIdsToReload","getNodesByBranchId","getNoteIds","getNoteReorderings","sortChildren","nodeA","nodeB","branchA","branchB","notesById","rootNode","hotKeyMap","navigate","keyCode","LEFT","RIGHT","UP","DOWN","getSelectedOrActiveBranchIds","beforeNode","afterNode","toNode","getFocusedNode","prevSibling","nextSibling","expandTree","exportDialog","MobileGlobalButtonsWidget","CloseDetailButtonWidget","MobileDetailMenuWidget","getBranchIds","togglePanes","ScreenContainer","screenName","setupGlobs","getComponentByEl","msg","lineNo","columnNo","appCssNoteId","appCssNoteIds","cssBlock"],"mappings":"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","file":"mobile.js","sourcesContent":["class Attribute {\n    constructor(treeCache, row) {\n        this.treeCache = treeCache;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @param {string} attributeId */\n        this.attributeId = row.attributeId;\n        /** @param {string} noteId */\n        this.noteId = row.noteId;\n        /** @param {string} type */\n        this.type = row.type;\n        /** @param {string} name */\n        this.name = row.name;\n        /** @param {string} value */\n        this.value = row.value;\n        /** @param {int} position */\n        this.position = row.position;\n        /** @param {boolean} isInheritable */\n        this.isInheritable = row.isInheritable;\n    }\n\n    /** @returns {NoteShort} */\n    getNote() {\n        return this.treeCache.notes[this.noteId];\n    }\n\n    get targetNoteId() { // alias\n        return this.type === 'relation' ? this.value : undefined;\n    }\n\n    get jsonValue() {\n        try {\n            return JSON.parse(this.value);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n\n    get toString() {\n        return `Attribute(attributeId=${this.attributeId}, type=${this.type}, name=${this.name}, value=${this.value})`;\n    }\n\n    /**\n     * @return {boolean} - returns true if this attribute has the potential to influence the note in the argument.\n     *         That can happen in multiple ways:\n     *         1. attribute is owned by the note\n     *         2. attribute is owned by the template of the note\n     *         3. attribute is owned by some note's ancestor and is inheritable\n     */\n    isAffecting(affectedNote) {\n        if (!affectedNote) {\n            return false;\n        }\n\n        const attrNote = this.getNote();\n\n        if (!attrNote) {\n            // the note (owner of the attribute) is not even loaded into the cache so it should not affect anything else\n            return false;\n        }\n\n        const owningNotes = [affectedNote, ...affectedNote.getTemplateNotes()];\n\n        for (const owningNote of owningNotes) {\n            if (owningNote.noteId === attrNote.noteId) {\n                return true;\n            }\n        }\n\n        if (this.isInheritable) {\n            for (const owningNote of owningNotes) {\n                if (owningNote.hasAncestor(attrNote)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\nexport default Attribute;\n","/** Represents mapping between note and parent note */\nclass Branch {\n    constructor(treeCache, row) {\n        this.treeCache = treeCache;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @param {string} primary key */\n        this.branchId = row.branchId;\n        /** @param {string} */\n        this.noteId = row.noteId;\n        /** @param {string} */\n        this.parentNoteId = row.parentNoteId;\n        /** @param {int} */\n        this.notePosition = row.notePosition;\n        /** @param {string} */\n        this.prefix = row.prefix;\n        /** @param {boolean} */\n        this.isExpanded = !!row.isExpanded;\n        /** @param {boolean} */\n        this.isDeleted = !!row.isDeleted;\n    }\n\n    /** @returns {NoteShort} */\n    async getNote() {\n        return this.treeCache.getNote(this.noteId);\n    }\n\n    /** @returns {NoteShort} */\n    async getParentNote() {\n        return this.treeCache.getNote(this.parentNoteId);\n    }\n\n    /** @returns {boolean} true if it's top level, meaning its parent is root note */\n    isTopLevel() {\n        return this.parentNoteId === 'root';\n    }\n\n    get toString() {\n        return `Branch(branchId=${this.branchId})`;\n    }\n}\n\nexport default Branch;","import Component from \"../widgets/component.js\";\nimport appContext from \"./app_context.js\";\n\nexport default class DialogCommandExecutor extends Component {\n    jumpToNoteCommand() {\n        import(\"../dialogs/jump_to_note.js\").then(d => d.showDialog());\n    }\n\n    showRecentChangesCommand() {\n        import(\"../dialogs/recent_changes.js\").then(d => d.showDialog());\n    }\n\n    showAttributesCommand() {\n        import(\"../dialogs/attributes.js\").then(d => d.showDialog());\n    }\n\n    showNoteInfoCommand() {\n        import(\"../dialogs/note_info.js\").then(d => d.showDialog());\n    }\n\n    showNoteRevisionsCommand() {\n        import(\"../dialogs/note_revisions.js\").then(d => d.showCurrentNoteRevisions());\n    }\n\n    showNoteSourceCommand() {\n        import(\"../dialogs/note_source.js\").then(d => d.showDialog());\n    }\n\n    showLinkMapCommand() {\n        import(\"../dialogs/link_map.js\").then(d => d.showDialog());\n    }\n\n    pasteMarkdownIntoTextCommand() {\n        import(\"../dialogs/markdown_import.js\").then(d => d.importMarkdownInline());\n    }\n\n    async editBranchPrefixCommand() {\n        const notePath = appContext.tabManager.getActiveTabNotePath();\n\n        if (notePath) {\n            const editBranchPrefixDialog = await import(\"../dialogs/branch_prefix.js\");\n            editBranchPrefixDialog.showDialog(notePath);\n        }\n    }\n\n    async cloneNoteIdsToCommand({noteIds}) {\n        const d = await import(\"../dialogs/clone_to.js\");\n        d.showDialog(noteIds);\n    }\n\n    async moveBranchIdsToCommand({branchIds}) {\n        const d = await import(\"../dialogs/move_to.js\");\n        d.showDialog(branchIds);\n    }\n\n    showOptionsCommand() {\n        import(\"../dialogs/options.js\").then(d => d.showDialog())\n    }\n\n    showHelpCommand() {\n        import(\"../dialogs/help.js\").then(d => d.showDialog())\n    }\n\n    showSQLConsoleCommand() {\n        import(\"../dialogs/sql_console.js\").then(d => d.showDialog())\n    }\n\n    showBackendLogCommand() {\n        import(\"../dialogs/backend_log.js\").then(d => d.showDialog())\n    }\n}","import utils from \"./utils.js\";\nimport dateNoteService from \"./date_notes.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport server from \"./server.js\";\nimport appContext from \"./app_context.js\";\nimport Component from \"../widgets/component.js\";\nimport toastService from \"./toast.js\";\nimport noteCreateService from \"./note_create.js\";\nimport ws from \"./ws.js\";\nimport bundleService from \"./bundle.js\";\n\nexport default class Entrypoints extends Component {\n    constructor() {\n        super();\n\n        if (jQuery.hotkeys) {\n            // hot keys are active also inside inputs and content editables\n            jQuery.hotkeys.options.filterInputAcceptingElements = false;\n            jQuery.hotkeys.options.filterContentEditable = false;\n            jQuery.hotkeys.options.filterTextInputs = false;\n        }\n\n        $(document).on('click', \"a[data-action='note-revision']\", async event => {\n            const linkEl = $(event.target);\n            const noteId = linkEl.attr('data-note-path');\n            const noteRevisionId = linkEl.attr('data-note-revision-id');\n\n            const attributesDialog = await import(\"../dialogs/note_revisions.js\");\n\n            attributesDialog.showNoteRevisionsDialog(noteId, noteRevisionId);\n\n            return false;\n        });\n    }\n\n    openDevToolsCommand() {\n        if (utils.isElectron()) {\n            utils.dynamicRequire('electron').remote.getCurrentWindow().toggleDevTools();\n        }\n    }\n\n    findInTextCommand() {\n        if (!utils.isElectron()) {\n            return;\n        }\n\n        const {remote} = utils.dynamicRequire('electron');\n        const {FindInPage} = utils.dynamicRequire('electron-find');\n        const findInPage = new FindInPage(remote.getCurrentWebContents(), {\n            offsetTop: 10,\n            offsetRight: 10,\n            boxBgColor: 'var(--main-background-color)',\n            boxShadowColor: '#000',\n            inputColor: 'var(--input-text-color)',\n            inputBgColor: 'var(--input-background-color)',\n            inputFocusColor: '#555',\n            textColor: 'var(--main-text-color)',\n            textHoverBgColor: '#555',\n            caseSelectedColor: 'var(--main-border-color)'\n        });\n\n        findInPage.openFindWindow();\n    }\n\n    async createNoteIntoDayNoteCommand() {\n        const todayNote = await dateNoteService.getTodayNote();\n\n        const {note} = await server.post(`notes/${todayNote.noteId}/children?target=into`, {\n            title: 'new note',\n            content: '',\n            type: 'text',\n            isProtected: todayNote.isProtected\n        });\n\n        await ws.waitForMaxKnownSyncId();\n\n        await appContext.tabManager.openTabWithNote(note.noteId, true);\n\n        appContext.triggerEvent('focusAndSelectTitle');\n    }\n\n    async toggleNoteHoistingCommand() {\n        const note = appContext.tabManager.getActiveTabNote();\n\n        const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n        if (note.noteId === hoistedNoteId) {\n            hoistedNoteService.unhoist();\n        }\n        else if (note.type !== 'search') {\n            hoistedNoteService.setHoistedNoteId(note.noteId);\n        }\n    }\n\n    copyWithoutFormattingCommand() {\n        utils.copySelectionToClipboard();\n    }\n\n    toggleFullscreenCommand() {\n        if (utils.isElectron()) {\n            const win = utils.dynamicRequire('electron').remote.getCurrentWindow();\n\n            if (win.isFullScreenable()) {\n                win.setFullScreen(!win.isFullScreen());\n            }\n        }\n        else {\n            // outside of electron this is handled by the browser\n            this.$widget.find(\".toggle-fullscreen-button\").hide();\n        }\n    }\n\n    toggleZenModeCommand() {\n        if (!this.zenModeActive) {\n            $(\".hide-in-zen-mode,.gutter\").addClass(\"hidden-by-zen-mode\");\n            $(\"#root-widget\").addClass(\"zen-mode\");\n            this.zenModeActive = true;\n        }\n        else {\n            // not hiding / showing explicitly since element might be hidden also for other reasons\n            $(\".hide-in-zen-mode,.gutter\").removeClass(\"hidden-by-zen-mode\");\n            $(\"#root-widget\").removeClass(\"zen-mode\");\n            this.zenModeActive = false;\n        }\n    }\n\n    reloadFrontendAppCommand() {\n        utils.reloadApp();\n    }\n\n    logoutCommand() {\n        const $logoutForm = $('<form action=\"logout\" method=\"POST\">')\n            .append($(`<input type=\"hidden\" name=\"_csrf\" value=\"${glob.csrfToken}\"/>`));\n\n        $(\"body\").append($logoutForm);\n        $logoutForm.trigger('submit');\n    }\n\n    backInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('electron').remote.getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex - 1);\n        }\n        else {\n            window.history.back();\n        }\n    }\n\n    forwardInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('electron').remote.getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex + 1);\n        }\n        else {\n            window.history.forward();\n        }\n    }\n\n    async searchForResultsCommand({searchText}) {\n        const response = await server.get('search/' + encodeURIComponent(searchText));\n\n        if (!response.success) {\n            toastService.showError(\"Search failed.\", 3000);\n            return;\n        }\n\n        this.triggerEvent('searchResults', {results: response.results});\n\n        // have at least some feedback which is good especially in situations\n        // when the result list does not change with a query\n        toastService.showMessage(\"Search finished successfully.\");\n    }\n\n    async switchToDesktopVersionCommand() {\n        utils.setCookie('trilium-device', 'desktop');\n\n        utils.reloadApp();\n    }\n\n    createTopLevelNoteCommand() { noteCreateService.createNewTopLevelNote(); }\n\n    async openInWindowCommand({notePath}) {\n        if (utils.isElectron()) {\n            const {ipcRenderer} = utils.dynamicRequire('electron');\n\n            ipcRenderer.send('create-extra-window', {notePath});\n        }\n        else {\n            const url = window.location.protocol + '//' + window.location.host + window.location.pathname + '?extra=1#' + notePath;\n\n            window.open(url, '', 'width=1000,height=800');\n        }\n    }\n\n    async openNewWindowCommand() {\n        this.openInWindowCommand({notePath: ''});\n    }\n\n    async runActiveNoteCommand() {\n        const note = appContext.tabManager.getActiveTabNote();\n\n        // ctrl+enter is also used elsewhere so make sure we're running only when appropriate\n        if (!note || note.type !== 'code') {\n            return;\n        }\n\n        if (note.mime.endsWith(\"env=frontend\")) {\n            await bundleService.getAndExecuteBundle(note.noteId);\n        }\n\n        if (note.mime.endsWith(\"env=backend\")) {\n            await server.post('script/run/' + note.noteId);\n        }\n\n        toastService.showMessage(\"Note executed\");\n    }\n}\n","import options from \"./options.js\";\nimport Component from \"../widgets/component.js\";\nimport utils from \"../services/utils.js\";\n\nconst MIN_ZOOM = 0.5;\nconst MAX_ZOOM = 2.0;\n\nclass ZoomService extends Component {\n    constructor() {\n        super();\n\n        if (utils.isElectron()) {\n            options.initializedPromise.then(() => {\n                this.setZoomFactor(options.getFloat('zoomFactor'));\n            });\n        }\n    }\n\n    setZoomFactor(zoomFactor) {\n        zoomFactor = parseFloat(zoomFactor);\n\n        const webFrame = utils.dynamicRequire('electron').webFrame;\n        webFrame.setZoomFactor(zoomFactor);\n    }\n\n    async setZoomFactorAndSave(zoomFactor) {\n        if (zoomFactor >= MIN_ZOOM && zoomFactor <= MAX_ZOOM) {\n            this.setZoomFactor(zoomFactor);\n\n            await options.save('zoomFactor', zoomFactor);\n        }\n        else {\n            console.log(`Zoom factor ${zoomFactor} outside of the range, ignored.`);\n        }\n    }\n\n    getCurrentZoom() {\n        return utils.dynamicRequire('electron').webFrame.getZoomFactor();\n    }\n\n    zoomOutEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() - 0.1);\n    }\n\n    zoomInEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() + 0.1);\n    }\n\n    setZoomFactorAndSaveEvent({zoomFactor}) {\n        this.setZoomFactorAndSave(zoomFactor);\n    }\n}\n\nconst zoomService = new ZoomService();\n\nexport default zoomService;\n","import protectedSessionHolder from \"./protected_session_holder.js\";\nimport server from \"./server.js\";\nimport utils from \"./utils.js\";\nimport appContext from \"./app_context.js\";\nimport treeService from \"./tree.js\";\nimport Component from \"../widgets/component.js\";\nimport treeCache from \"./tree_cache.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\n\nclass TabContext extends Component {\n    /**\n     * @param {string|null} tabId\n     */\n    constructor(tabId = null) {\n        super();\n\n        this.tabId = tabId || utils.randomString(4);\n    }\n\n    setEmpty() {\n        this.triggerEvent('tabNoteSwitched', {\n            tabContext: this,\n            notePath: this.notePath\n        });\n    }\n\n    async setNote(inputNotePath, triggerSwitchEvent = true) {\n        const noteId = treeService.getNoteIdFromNotePath(inputNotePath);\n        let notePath;\n\n        if ((await treeCache.getNote(noteId)).isDeleted) {\n            // no point in trying to resolve canonical notePath\n            notePath = inputNotePath;\n        }\n        else {\n            notePath = await treeService.resolveNotePath(inputNotePath);\n\n            if (!notePath) {\n                console.error(`Cannot resolve note path ${inputNotePath}`);\n                return;\n            }\n\n            if (notePath === this.notePath) {\n                return;\n            }\n\n            if (await hoistedNoteService.checkNoteAccess(notePath) === false) {\n                return; // note is outside of hoisted subtree and user chose not to unhoist\n            }\n        }\n\n        await this.triggerEvent('beforeNoteSwitch', {tabContext: this});\n\n        utils.closeActiveDialog();\n\n        this.notePath = notePath;\n        this.noteId = noteId;\n\n        this.autoBookDisabled = false;\n        this.textPreviewDisabled = false;\n        this.codePreviewDisabled = false;\n\n        setTimeout(async () => {\n            // we include the note into recent list only if the user stayed on the note at least 5 seconds\n            if (notePath && notePath === this.notePath) {\n                await server.post('recent-notes', {\n                    noteId: this.note.noteId,\n                    notePath: this.notePath\n                });\n            }\n        }, 5000);\n\n        protectedSessionHolder.touchProtectedSessionIfNecessary(this.note);\n\n        if (triggerSwitchEvent) {\n            await this.triggerEvent('tabNoteSwitched', {\n                tabContext: this,\n                notePath: this.notePath\n            });\n        }\n    }\n\n    /** @property {NoteShort} */\n    get note() {\n        return treeCache.notes[this.noteId];\n    }\n\n    /** @return {NoteComplement} */\n    async getNoteComplement() {\n        if (!this.noteId) {\n            return null;\n        }\n\n        return await treeCache.getNoteComplement(this.noteId);\n    }\n\n    isActive() {\n        return appContext.tabManager.activeTabId === this.tabId;\n    }\n\n    getTabState() {\n        if (!this.notePath) {\n            return null;\n        }\n\n        return {\n            tabId: this.tabId,\n            notePath: this.notePath,\n            active: this.isActive()\n        }\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        if (loadResults.isNoteReloaded(this.noteId)) {\n            const note = await treeCache.getNote(this.noteId);\n\n            if (note.isDeleted) {\n                this.noteId = null;\n                this.notePath = null;\n\n                this.triggerEvent('tabNoteSwitched', {\n                    tabContext: this,\n                    notePath: this.notePath\n                });\n            }\n        }\n    }\n}\n\nexport default TabContext;\n","import Component from \"../widgets/component.js\";\nimport SpacedUpdate from \"./spaced_update.js\";\nimport server from \"./server.js\";\nimport options from \"./options.js\";\nimport treeCache from \"./tree_cache.js\";\nimport treeService from \"./tree.js\";\nimport utils from \"./utils.js\";\nimport TabContext from \"./tab_context.js\";\nimport appContext from \"./app_context.js\";\n\nexport default class TabManager extends Component {\n    constructor() {\n        super();\n\n        this.activeTabId = null;\n\n        this.tabsUpdate = new SpacedUpdate(async () => {\n            if (!appContext.isMainWindow) {\n                return;\n            }\n\n            const openTabs = this.tabContexts\n                .map(tc => tc.getTabState())\n                .filter(t => !!t);\n\n            await server.put('options', {\n                openTabs: JSON.stringify(openTabs)\n            });\n        });\n    }\n\n    /** @type {TabContext[]} */\n    get tabContexts() {\n        return this.children;\n    }\n\n    async loadTabs() {\n        const tabsToOpen = appContext.isMainWindow\n            ? (options.getJson('openTabs') || [])\n            : [];\n\n        // if there's notePath in the URL, make sure it's open and active\n        // (useful, among others, for opening clipped notes from clipper)\n        if (window.location.hash) {\n            const notePath = window.location.hash.substr(1);\n            const noteId = treeService.getNoteIdFromNotePath(notePath);\n\n            if (noteId && await treeCache.noteExists(noteId)) {\n                for (const tab of tabsToOpen) {\n                    tab.active = false;\n                }\n\n                const foundTab = tabsToOpen.find(tab => noteId === treeService.getNoteIdFromNotePath(tab.notePath));\n\n                if (foundTab) {\n                    foundTab.active = true;\n                }\n                else {\n                    tabsToOpen.push({\n                        notePath: notePath,\n                        active: true\n                    });\n                }\n            }\n        }\n\n        let filteredTabs = [];\n\n        for (const openTab of tabsToOpen) {\n            const noteId = treeService.getNoteIdFromNotePath(openTab.notePath);\n\n            if (await treeCache.noteExists(noteId)) {\n                // note doesn't exist so don't try to open tab for it\n                filteredTabs.push(openTab);\n            }\n        }\n\n        if (utils.isMobile()) {\n            // mobile frontend doesn't have tabs so show only the active tab\n            filteredTabs = filteredTabs.filter(tab => tab.active);\n        }\n\n        if (filteredTabs.length === 0) {\n            filteredTabs.push({\n                notePath: this.isMainWindow ? 'root' : '',\n                active: true\n            });\n        }\n\n        if (!filteredTabs.find(tab => tab.active)) {\n            filteredTabs[0].active = true;\n        }\n\n        await this.tabsUpdate.allowUpdateWithoutChange(async () => {\n            for (const tab of filteredTabs) {\n                await this.openTabWithNote(tab.notePath, tab.active, tab.tabId);\n            }\n        });\n    }\n\n    tabNoteSwitchedEvent({tabContext}) {\n        if (tabContext.isActive()) {\n            this.setCurrentNotePathToHash();\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    setCurrentNotePathToHash() {\n        const activeTabContext = this.getActiveTabContext();\n\n        if (window.history.length === 0 // first history entry\n            || (activeTabContext && activeTabContext.notePath !== treeService.getHashValueFromAddress()[0])) {\n            const url = '#' + (activeTabContext.notePath || \"\") + \"-\" + activeTabContext.tabId;\n\n            // using pushState instead of directly modifying document.location because it does not trigger hashchange\n            window.history.pushState(null, \"\", url);\n\n            document.title = \"Trilium Notes\";\n\n            if (activeTabContext.note) {\n                // it helps navigating in history if note title is included in the title\n                document.title += \" - \" + activeTabContext.note.title;\n            }\n        }\n\n        this.triggerEvent('activeNoteChanged'); // trigger this even in on popstate event\n    }\n\n    /** @return {TabContext[]} */\n    getTabContexts() {\n        return this.tabContexts;\n    }\n\n    /** @returns {TabContext} */\n    getTabContextById(tabId) {\n        return this.tabContexts.find(tc => tc.tabId === tabId);\n    }\n\n    /** @returns {TabContext} */\n    getActiveTabContext() {\n        return this.getTabContextById(this.activeTabId);\n    }\n\n    /** @returns {string|null} */\n    getActiveTabNotePath() {\n        const activeContext = this.getActiveTabContext();\n        return activeContext ? activeContext.notePath : null;\n    }\n\n    /** @return {NoteShort} */\n    getActiveTabNote() {\n        const activeContext = this.getActiveTabContext();\n        return activeContext ? activeContext.note : null;\n    }\n\n    /** @return {string|null} */\n    getActiveTabNoteId() {\n        const activeNote = this.getActiveTabNote();\n\n        return activeNote ? activeNote.noteId : null;\n    }\n\n    /** @return {string|null} */\n    getActiveTabNoteType() {\n        const activeNote = this.getActiveTabNote();\n\n        return activeNote ? activeNote.type : null;\n    }\n\n    async switchToTab(tabId, notePath) {\n        const tabContext = this.tabContexts.find(tc => tc.tabId === tabId)\n            || await this.openEmptyTab();\n\n        this.activateTab(tabContext.tabId);\n        await tabContext.setNote(notePath);\n    }\n\n    async openAndActivateEmptyTab() {\n        const tabContext = await this.openEmptyTab();\n\n        await this.activateTab(tabContext.tabId);\n\n        await tabContext.setEmpty();\n    }\n\n    async openEmptyTab(tabId) {\n        const tabContext = new TabContext(tabId);\n        this.child(tabContext);\n\n        await this.triggerEvent('newTabOpened', {tabContext});\n\n        return tabContext;\n    }\n\n    async openTabWithNote(notePath, activate, tabId = null) {\n        const tabContext = await this.openEmptyTab(tabId);\n\n        if (notePath) {\n            await tabContext.setNote(notePath, !activate); // if activate is false then send normal noteSwitched event\n        }\n\n        if (activate) {\n            this.activateTab(tabContext.tabId, false);\n\n            await this.triggerEvent('tabNoteSwitchedAndActivated', {\n                tabContext,\n                notePath: tabContext.notePath // resolved note path\n            });\n        }\n    }\n\n    async activateOrOpenNote(noteId) {\n        for (const tabContext of this.getTabContexts()) {\n            if (tabContext.note && tabContext.note.noteId === noteId) {\n                this.activateTab(tabContext.tabId);\n\n                return;\n            }\n        }\n\n        // if no tab with this note has been found we'll create new tab\n\n        await this.openTabWithNote(noteId, true);\n    }\n\n    activateTab(tabId, triggerEvent = true) {\n        if (tabId === this.activeTabId) {\n            return;\n        }\n\n        this.activeTabId = tabId;\n\n        if (triggerEvent) {\n            this.triggerEvent('activeTabChanged', {\n                tabContext: this.getTabContextById(tabId)\n            });\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n\n        this.setCurrentNotePathToHash();\n    }\n\n    async removeTab(tabId) {\n        const tabContextToRemove = this.getTabContextById(tabId);\n\n        if (!tabContextToRemove) {\n            return;\n        }\n\n        // close dangling autocompletes after closing the tab\n        $(\".aa-input\").autocomplete(\"close\");\n\n        await this.triggerEvent('beforeTabRemove', {tabId});\n\n        if (this.tabContexts.length <= 1) {\n            this.openAndActivateEmptyTab();\n        }\n        else if (tabContextToRemove.isActive()) {\n            const idx = this.tabContexts.findIndex(tc => tc.tabId === tabId);\n\n            if (idx === this.tabContexts.length - 1) {\n                this.activatePreviousTabCommand();\n            }\n            else {\n                this.activateNextTabCommand();\n            }\n        }\n\n        this.children = this.children.filter(tc => tc.tabId !== tabId);\n\n        this.triggerEvent('tabRemoved', {tabId});\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    tabReorderEvent({tabIdsInOrder}) {\n        const order = {};\n\n        for (const i in tabIdsInOrder) {\n            order[tabIdsInOrder[i]] = i;\n        }\n\n        this.children.sort((a, b) => order[a.tabId] < order[b.tabId] ? -1 : 1);\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    activateNextTabCommand() {\n        const oldIdx = this.tabContexts.findIndex(tc => tc.tabId === this.activeTabId);\n        const newActiveTabId = this.tabContexts[oldIdx === this.tabContexts.length - 1 ? 0 : oldIdx + 1].tabId;\n\n        this.activateTab(newActiveTabId);\n    }\n\n    activatePreviousTabCommand() {\n        const oldIdx = this.tabContexts.findIndex(tc => tc.tabId === this.activeTabId);\n        const newActiveTabId = this.tabContexts[oldIdx === 0 ? this.tabContexts.length - 1 : oldIdx - 1].tabId;\n\n        this.activateTab(newActiveTabId);\n    }\n\n    closeActiveTabCommand() {\n        this.removeTab(this.activeTabId);\n    }\n\n    beforeUnloadEvent() {\n        this.tabsUpdate.updateNowIfNecessary();\n    }\n\n    openNewTabCommand() {\n        this.openAndActivateEmptyTab();\n    }\n\n    async removeAllTabsCommand() {\n        for (const tabIdToRemove of this.tabContexts.map(tc => tc.tabId)) {\n            await this.removeTab(tabIdToRemove);\n        }\n    }\n\n    async removeAllTabsExceptForThisCommand({tabId}) {\n        for (const tabIdToRemove of this.tabContexts.map(tc => tc.tabId)) {\n            if (tabIdToRemove !== tabId) {\n                await this.removeTab(tabIdToRemove);\n            }\n        }\n    }\n\n    moveTabToNewWindowCommand({tabId}) {\n        const notePath = this.getTabContextById(tabId).notePath;\n\n        this.removeTab(tabId);\n\n        this.triggerCommand('openInWindow', {notePath});\n    }\n\n    async hoistedNoteChangedEvent({hoistedNoteId}) {\n        if (hoistedNoteId === 'root') {\n            return;\n        }\n\n        for (const tc of this.tabContexts.splice()) {\n            if (tc.notePath && !tc.notePath.split(\"/\").includes(hoistedNoteId)) {\n                await this.removeTab(tc.tabId);\n            }\n        }\n    }\n}\n","import Component from \"../component.js\";\n\nexport default class MobileScreenSwitcherExecutor extends Component {\n    setActiveScreenCommand({screen}) {\n        if (screen !== this.activeScreen) {\n            this.activeScreen = screen;\n\n            this.triggerEvent('activeScreenChanged', {activeScreen: screen});\n        }\n    }\n\n    initialRenderCompleteEvent() {\n        this.setActiveScreenCommand({screen: 'tree'});\n    }\n}","import appContext from \"./app_context.js\";\nimport noteCreateService from \"./note_create.js\";\nimport treeService from \"./tree.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport Component from \"../widgets/component.js\";\nimport ws from \"./ws.js\";\n\n/**\n * This class contains command executors which logically belong to the NoteTree widget, but for better user experience\n * the keyboard shortcuts must be active on the whole screen and not just on the widget itself, so the executors\n * must be at the root of the component tree.\n */\nexport default class MainTreeExecutors extends Component {\n    get tree() {\n        return appContext.mainTreeWidget;\n    }\n\n    async cloneNotesToCommand() {\n        const selectedOrActiveNoteIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.noteId);\n\n        this.triggerCommand('cloneNoteIdsTo', {noteIds: selectedOrActiveNoteIds});\n    }\n\n    async moveNotesToCommand() {\n        const selectedOrActiveBranchIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.branchId);\n\n        this.triggerCommand('moveBranchIdsTo', {branchIds: selectedOrActiveBranchIds});\n    }\n\n    async createNoteIntoCommand() {\n        const activeNote = appContext.tabManager.getActiveTabNote();\n\n        if (!activeNote) {\n            return;\n        }\n\n        await noteCreateService.createNote(activeNote.noteId, {\n            isProtected: activeNote.isProtected,\n            saveSelection: false\n        });\n    }\n\n    async createNoteAfterCommand() {\n        const node = this.tree.getActiveNode();\n        const parentNoteId = node.data.parentNoteId;\n        const isProtected = await treeService.getParentProtectedStatus(node);\n\n        if (node.data.noteId === 'root' || node.data.noteId === hoistedNoteService.getHoistedNoteId()) {\n            return;\n        }\n\n        await noteCreateService.createNote(parentNoteId, {\n            target: 'after',\n            targetBranchId: node.data.branchId,\n            isProtected: isProtected,\n            saveSelection: false\n        });\n    }\n}\n","import treeCache from \"./tree_cache.js\";\nimport bundleService from \"./bundle.js\";\nimport DialogCommandExecutor from \"./dialog_command_executor.js\";\nimport Entrypoints from \"./entrypoints.js\";\nimport options from \"./options.js\";\nimport utils from \"./utils.js\";\nimport zoomService from \"./zoom.js\";\nimport TabManager from \"./tab_manager.js\";\nimport treeService from \"./tree.js\";\nimport Component from \"../widgets/component.js\";\nimport keyboardActionsService from \"./keyboard_actions.js\";\nimport MobileScreenSwitcherExecutor from \"../widgets/mobile_widgets/mobile_screen_switcher.js\";\nimport MainTreeExecutors from \"./main_tree_executors.js\";\n\nclass AppContext extends Component {\n    constructor(isMainWindow) {\n        super();\n\n        this.isMainWindow = isMainWindow;\n        this.executors = [];\n    }\n\n    setLayout(layout) {\n        this.layout = layout;\n    }\n\n    async start() {\n        await Promise.all([treeCache.initializedPromise, options.initializedPromise]);\n\n        $(\"#loading-indicator\").hide();\n\n        this.showWidgets();\n\n        this.tabManager.loadTabs();\n\n        if (utils.isDesktop()) {\n            setTimeout(() => bundleService.executeStartupBundles(), 2000);\n        }\n    }\n\n    showWidgets() {\n        const rootWidget = this.layout.getRootWidget(this);\n        const $renderedWidget = rootWidget.render();\n\n        keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n        $(\"body\").append($renderedWidget);\n\n        $renderedWidget.on('click', \"[data-trigger-command]\", function() {\n            const commandName = $(this).attr('data-trigger-command');\n            const $component = $(this).closest(\".component\");\n            const component = $component.prop(\"component\");\n\n            component.triggerCommand(commandName, {$el: $(this)});\n        });\n\n        this.tabManager = new TabManager();\n\n        this.executors = [\n            this.tabManager,\n            new DialogCommandExecutor(),\n            new Entrypoints(),\n            new MainTreeExecutors()\n        ];\n\n        if (utils.isMobile()) {\n            this.executors.push(new MobileScreenSwitcherExecutor());\n        }\n\n        this.child(rootWidget);\n\n        for (const executor of this.executors) {\n            this.child(executor);\n        }\n\n        if (utils.isElectron()) {\n            this.child(zoomService);\n        }\n\n        this.triggerEvent('initialRenderComplete');\n    }\n\n    /** @return {Promise} */\n    triggerEvent(name, data) {\n        return this.handleEvent(name, data);\n    }\n\n    /** @return {Promise} */\n    triggerCommand(name, data = {}) {\n        for (const executor of this.executors) {\n            const fun = executor[name + \"Command\"];\n\n            if (fun) {\n                return executor.callMethod(fun, data);\n            }\n        }\n\n        // this might hint at error but sometimes this is used by components which are at different places\n        // in the component tree to communicate with each other\n        console.debug(`Unhandled command ${name}, converting to event.`);\n\n        return this.triggerEvent(name, data);\n    }\n\n    getComponentByEl(el) {\n        return $(el).closest(\".component\").prop('component');\n    }\n}\n\nconst appContext = new AppContext(window.glob.isMainWindow);\n\n// we should save all outstanding changes before the page/app is closed\n$(window).on('beforeunload', () => {\n    appContext.triggerEvent('beforeUnload');\n});\n\nfunction isNotePathInAddress() {\n    const [notePath, tabId] = treeService.getHashValueFromAddress();\n\n    return notePath.startsWith(\"root\")\n        // empty string is for empty/uninitialized tab\n        || (notePath === '' && !!tabId);\n}\n\n$(window).on('hashchange', function() {\n    if (isNotePathInAddress()) {\n        const [notePath, tabId] = treeService.getHashValueFromAddress();\n\n        if (!notePath) {\n            console.log(`Invalid hash value \"${document.location.hash}\", ignoring.`);\n            return;\n        }\n\n        appContext.tabManager.switchToTab(tabId, notePath);\n    }\n});\n\nexport default appContext;\n","import server from \"./server.js\";\n\n/**\n * @param $el - element on which to init autocomplete\n * @param attributeType - \"relation\" or \"label\" or callback providing one of those values as a type of autocompleted attributes\n * @param open - should the autocomplete be opened after init?\n */\nfunction initAttributeNameAutocomplete({ $el, attributeType, open }) {\n    if (!$el.hasClass(\"aa-input\")) {\n        $el.autocomplete({\n            appendTo: document.querySelector('body'),\n            hint: false,\n            openOnFocus: true,\n            minLength: 0,\n            tabAutocomplete: false\n        }, [{\n            displayKey: 'name',\n            // disabling cache is important here because otherwise cache can stay intact when switching between attribute type which will lead to autocomplete displaying attribute names for incorrect attribute type\n            cache: false,\n            source: async (term, cb) => {\n                const type = typeof attributeType === \"function\" ? attributeType() : attributeType;\n\n                const names = await server.get(`attributes/names/?type=${type}&query=${encodeURIComponent(term)}`);\n                const result = names.map(name => ({name}));\n\n                cb(result);\n            }\n        }]);\n    }\n\n    if (open) {\n        $el.autocomplete(\"open\");\n    }\n}\n\nasync function initLabelValueAutocomplete({ $el, open }) {\n    if (!$el.hasClass(\"aa-input\")) {\n        const attributeName = $el.parent().parent().find('.attribute-name').val();\n\n        if (attributeName.trim() === \"\") {\n            return;\n        }\n\n        const attributeValues = (await server.get('attributes/values/' + encodeURIComponent(attributeName)))\n            .map(attribute => ({ value: attribute }));\n\n        if (attributeValues.length === 0) {\n            return;\n        }\n\n        $el.autocomplete({\n            appendTo: document.querySelector('body'),\n            hint: false,\n            openOnFocus: true,\n            minLength: 0,\n            tabAutocomplete: false\n        }, [{\n            displayKey: 'value',\n            source: function (term, cb) {\n                term = term.toLowerCase();\n\n                const filtered = attributeValues.filter(attr => attr.value.toLowerCase().includes(term));\n\n                cb(filtered);\n            }\n        }]);\n    }\n\n    if (open) {\n        $el.autocomplete(\"open\");\n    }\n}\n\nexport default {\n    initAttributeNameAutocomplete,\n    initLabelValueAutocomplete\n}","import utils from './utils.js';\nimport server from './server.js';\nimport toastService from \"./toast.js\";\nimport treeCache from \"./tree_cache.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport ws from \"./ws.js\";\n\nasync function moveBeforeBranch(branchIdsToMove, beforeBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    if (beforeBranchId === 'root') {\n        alert('Cannot move notes before root note.');\n        return;\n    }\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const resp = await server.put(`branches/${branchIdToMove}/move-before/${beforeBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function moveAfterBranch(branchIdsToMove, afterBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    const afterNote = await treeCache.getBranch(afterBranchId).getNote();\n\n    if (afterNote.noteId === 'root' || afterNote.noteId === hoistedNoteService.getHoistedNoteId()) {\n        alert('Cannot move notes after root note.');\n        return;\n    }\n\n    branchIdsToMove.reverse(); // need to reverse to keep the note order\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const resp = await server.put(`branches/${branchIdToMove}/move-after/${afterBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function moveToParentNote(branchIdsToMove, newParentBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const branchToMove = treeCache.getBranch(branchIdToMove);\n\n        if (branchToMove.noteId === hoistedNoteService.getHoistedNoteId()\n            || (await branchToMove.getParentNote()).type === 'search') {\n            continue;\n        }\n\n        const resp = await server.put(`branches/${branchIdToMove}/move-to/${newParentBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function deleteNotes(branchIdsToDelete) {\n    branchIdsToDelete = filterRootNote(branchIdsToDelete);\n\n    if (branchIdsToDelete.length === 0) {\n        return false;\n    }\n\n    const $deleteClonesCheckbox = $('<div class=\"form-check\">')\n        .append($('<input type=\"checkbox\" class=\"form-check-input\" id=\"delete-clones-checkbox\">'))\n        .append($('<label for=\"delete-clones-checkbox\">')\n                    .text(\"delete also all note clones\")\n                    .attr(\"title\", \"all clones of selected notes will be deleted and as such the whole note will be deleted.\"));\n\n    const $nodeTitles = $(\"<ul>\");\n\n    for (const branchId of branchIdsToDelete) {\n        const note = await treeCache.getBranch(branchId).getNote();\n\n        $nodeTitles.append($(\"<li>\").text(note.title));\n    }\n\n    const $confirmText = $(\"<div>\")\n        .append($(\"<p>\").text('This will delete the following notes and their sub-notes: '))\n        .append($nodeTitles)\n        .append($deleteClonesCheckbox);\n\n    const confirmDialog = await import('../dialogs/confirm.js');\n\n    if (!await confirmDialog.confirm($confirmText)) {\n        return false;\n    }\n\n    const deleteClones = $deleteClonesCheckbox.find(\"input\").is(\":checked\");\n\n    const taskId = utils.randomString(10);\n\n    let counter = 0;\n\n    for (const branchIdToDelete of branchIdsToDelete) {\n        counter++;\n\n        const last = counter === branchIdsToDelete.length;\n        const query = `?taskId=${taskId}&last=${last ? 'true' : 'false'}`;\n\n        const branch = treeCache.getBranch(branchIdToDelete);\n\n        if (deleteClones) {\n            await server.remove(`notes/${branch.noteId}` + query);\n        }\n        else {\n            await server.remove(`branches/${branchIdToDelete}` + query);\n        }\n    }\n\n    return true;\n}\n\nasync function moveNodeUpInHierarchy(node) {\n    if (hoistedNoteService.isRootNode(node)\n        || hoistedNoteService.isTopLevelNode(node)\n        || node.getParent().data.noteType === 'search') {\n        return;\n    }\n\n    const resp = await server.put('branches/' + node.data.branchId + '/move-after/' + node.getParent().data.branchId);\n\n    if (!resp.success) {\n        alert(resp.message);\n        return;\n    }\n\n    if (!hoistedNoteService.isTopLevelNode(node) && node.getParent().getChildren().length <= 1) {\n        node.getParent().folder = false;\n        node.getParent().renderTitle();\n    }\n}\n\nfunction filterRootNote(branchIds) {\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    return branchIds.filter(branchId => {\n       const branch = treeCache.getBranch(branchId);\n\n        return branch.noteId !== 'root'\n            && branch.noteId !== hoistedNoteId;\n    });\n}\n\nfunction makeToast(id, message) {\n    return {\n        id: id,\n        title: \"Delete status\",\n        message: message,\n        icon: \"trash\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'delete-notes') {\n        return;\n    }\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message.taskId, \"Delete notes in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message.taskId, \"Delete finished successfully.\");\n        toast.closeAfter = 5000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'undelete-notes') {\n        return;\n    }\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message.taskId, \"Undeleting notes in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message.taskId, \"Undeleting notes finished successfully.\");\n        toast.closeAfter = 5000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nasync function cloneNoteTo(childNoteId, parentBranchId, prefix) {\n    const resp = await server.put(`notes/${childNoteId}/clone-to/${parentBranchId}`, {\n        prefix: prefix\n    });\n\n    if (!resp.success) {\n        alert(resp.message);\n    }\n}\n\n// beware that first arg is noteId and second is branchId!\nasync function cloneNoteAfter(noteId, afterBranchId) {\n    const resp = await server.put('notes/' + noteId + '/clone-after/' + afterBranchId);\n\n    if (!resp.success) {\n        alert(resp.message);\n    }\n}\n\nexport default {\n    moveBeforeBranch,\n    moveAfterBranch,\n    moveToParentNote,\n    deleteNotes,\n    moveNodeUpInHierarchy,\n    cloneNoteAfter,\n    cloneNoteTo\n};\n","import ScriptContext from \"./script_context.js\";\nimport server from \"./server.js\";\nimport toastService from \"./toast.js\";\n\nasync function getAndExecuteBundle(noteId, originEntity = null) {\n    const bundle = await server.get('script/bundle/' + noteId);\n\n    return await executeBundle(bundle, originEntity);\n}\n\nasync function executeBundle(bundle, originEntity, $container) {\n    const apiContext = await ScriptContext(bundle.noteId, bundle.allNoteIds, originEntity, $container);\n\n    try {\n        return await (function () {\n            return eval(`const apiContext = this; (async function() { ${bundle.script}\\r\\n})()`);\n        }.call(apiContext));\n    }\n    catch (e) {\n        toastService.showAndLogError(`Execution of ${bundle.noteId} failed with error: ${e.message}`);\n    }\n}\n\nasync function executeStartupBundles() {\n    const scriptBundles = await server.get(\"script/startup\");\n\n    for (const bundle of scriptBundles) {\n        await executeBundle(bundle);\n    }\n}\n\nclass WidgetsByParent {\n    constructor() {\n        this.byParent = {};\n    }\n\n    add(widget) {\n        if (!widget.parentWidget) {\n            console.log(`Custom widget does not have mandatory 'getParent()' method defined`);\n            return;\n        }\n\n        this.byParent[widget.parentWidget] = this.byParent[widget.parentWidget] || [];\n        this.byParent[widget.parentWidget].push(widget);\n    }\n\n    get(parentName) {\n        return this.byParent[parentName] || [];\n    }\n}\n\nasync function getWidgetBundlesByParent() {\n    const scriptBundles = await server.get(\"script/widgets\");\n\n    const widgetsByParent = new WidgetsByParent();\n\n    for (const bundle of scriptBundles) {\n        let widget;\n\n        try {\n            widget = await executeBundle(bundle);\n        }\n        catch (e) {\n            console.error(\"Widget initialization failed: \", e);\n            continue;\n        }\n\n        widgetsByParent.add(widget);\n    }\n\n    return widgetsByParent;\n}\n\nexport default {\n    executeBundle,\n    getAndExecuteBundle,\n    executeStartupBundles,\n    getWidgetBundlesByParent\n}\n","import branchService from \"./branches.js\";\nimport toastService from \"./toast.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport treeCache from \"./tree_cache.js\";\n\nlet clipboardBranchIds = [];\nlet clipboardMode = null;\n\nasync function pasteAfter(afterBranchId) {\n    if (isClipboardEmpty()) {\n        return;\n    }\n\n    if (clipboardMode === 'cut') {\n        await branchService.moveAfterBranch(clipboardBranchIds, afterBranchId);\n\n        clipboardBranchIds = [];\n        clipboardMode = null;\n    }\n    else if (clipboardMode === 'copy') {\n        const clipboardBranches = clipboardBranchIds.map(branchId => treeCache.getBranch(branchId));\n\n        for (const clipboardBranch of clipboardBranches) {\n            const clipboardNote = await clipboardBranch.getNote();\n\n            await branchService.cloneNoteAfter(clipboardNote.noteId, afterBranchId);\n        }\n\n        // copy will keep clipboardBranchIds and clipboardMode so it's possible to paste into multiple places\n    }\n    else {\n        toastService.throwError(\"Unrecognized clipboard mode=\" + clipboardMode);\n    }\n}\n\nasync function pasteInto(parentBranchId) {\n    if (isClipboardEmpty()) {\n        return;\n    }\n\n    if (clipboardMode === 'cut') {\n        await branchService.moveToParentNote(clipboardBranchIds, parentBranchId);\n\n        clipboardBranchIds = [];\n        clipboardMode = null;\n    }\n    else if (clipboardMode === 'copy') {\n        const clipboardBranches = clipboardBranchIds.map(branchId => treeCache.getBranch(branchId));\n\n        for (const clipboardBranch of clipboardBranches) {\n            const clipboardNote = await clipboardBranch.getNote();\n\n            await branchService.cloneNoteTo(clipboardNote.noteId, parentBranchId);\n        }\n\n        // copy will keep clipboardBranchIds and clipboardMode so it's possible to paste into multiple places\n    }\n    else {\n        toastService.throwError(\"Unrecognized clipboard mode=\" + mode);\n    }\n}\n\nfunction copy(branchIds) {\n    clipboardBranchIds = branchIds;\n    clipboardMode = 'copy';\n\n    toastService.showMessage(\"Note(s) have been copied into clipboard.\");\n}\n\nfunction cut(branchIds) {\n    clipboardBranchIds = branchIds;\n\n    if (clipboardBranchIds.length > 0) {\n        clipboardMode = 'cut';\n\n        toastService.showMessage(\"Note(s) have been cut into clipboard.\");\n    }\n}\n\nfunction isClipboardEmpty() {\n    clipboardBranchIds = clipboardBranchIds.filter(branchId => !!treeCache.getBranch(branchId));\n\n    return clipboardBranchIds.length === 0;\n}\n\nexport default {\n    pasteAfter,\n    pasteInto,\n    cut,\n    copy,\n    isClipboardEmpty\n}\n","import keyboardActionService from './keyboard_actions.js';\n\nclass ContextMenu {\n    constructor() {\n        this.$widget = $(\"#context-menu-container\");\n        this.dateContextMenuOpenedMs = 0;\n\n        $(document).on('click', () => this.hide());\n    }\n    \n    async show(options) {\n        this.options = options;\n        \n        this.$widget.empty();\n\n        this.addItems(this.$widget, options.items);\n\n        keyboardActionService.updateDisplayedShortcuts(this.$widget);\n\n        this.positionMenu();\n\n        this.dateContextMenuOpenedMs = Date.now();\n    }\n\n    positionMenu() {\n        // code below tries to detect when dropdown would overflow from page\n        // in such case we'll position it above click coordinates so it will fit into client\n        const clientHeight = document.documentElement.clientHeight;\n        const contextMenuHeight = this.$widget.outerHeight() + 30;\n        let top;\n\n        if (this.options.y + contextMenuHeight > clientHeight) {\n            top = clientHeight - contextMenuHeight - 10;\n        } else {\n            top = this.options.y - 10;\n        }\n\n        this.$widget.css({\n            display: \"block\",\n            top: top,\n            left: this.options.x - 20\n        }).addClass(\"show\");\n    }\n\n    addItems($parent, items) {\n        for (const item of items) {\n            if (item.title === '----') {\n                $parent.append($(\"<div>\").addClass(\"dropdown-divider\"));\n            } else {\n                const $icon = $(\"<span>\");\n\n                if (item.uiIcon) {\n                    $icon.addClass(\"bx bx-\" + item.uiIcon);\n                } else {\n                    $icon.append(\"&nbsp;\");\n                }\n\n                const $link = $(\"<span>\")\n                    .append($icon)\n                    .append(\" &nbsp; \") // some space between icon and text\n                    .append(item.title);\n\n                const $item = $(\"<li>\")\n                    .addClass(\"dropdown-item\")\n                    .append($link)\n                    // important to use mousedown instead of click since the former does not change focus\n                    // (especially important for focused text for spell check)\n                    .on('mousedown', (e) => {\n                        e.stopPropagation();\n\n                        this.hide();\n\n                        if (item.handler) {\n                            item.handler(item, e);\n                        }\n\n                        this.options.selectMenuItemHandler(item, e);\n\n                        // it's important to stop the propagation especially for sub-menus, otherwise the event\n                        // might be handled again by top-level menu\n                        return false;\n                    });\n\n                if (item.enabled !== undefined && !item.enabled) {\n                    $item.addClass(\"disabled\");\n                }\n\n                if (item.items) {\n                    $item.addClass(\"dropdown-submenu\");\n                    $link.addClass(\"dropdown-toggle\");\n\n                    const $subMenu = $(\"<ul>\").addClass(\"dropdown-menu\");\n\n                    this.addItems($subMenu, item.items);\n\n                    $item.append($subMenu);\n                }\n\n                $parent.append($item);\n            }\n        }\n    }\n\n    hide() {\n        // this date checking comes from change in FF66 - https://github.com/zadam/trilium/issues/468\n        // \"contextmenu\" event also triggers \"click\" event which depending on the timing can close just opened context menu\n        // we might filter out right clicks, but then it's better if even right clicks close the context menu\n        if (Date.now() - this.dateContextMenuOpenedMs > 300) {\n            this.$widget.hide();\n        }\n    }\n}\n\nconst contextMenu = new ContextMenu();\n\nexport default contextMenu;","import treeCache from \"./tree_cache.js\";\nimport server from \"./server.js\";\n\n/** @return {NoteShort} */\nasync function getTodayNote() {\n    return await getDateNote(dayjs().format(\"YYYY-MM-DD\"));\n}\n\n/** @return {NoteShort} */\nasync function getDateNote(date) {\n    const note = await server.get('date-notes/date/' + date, \"date-note\");\n\n    return await treeCache.getNote(note.noteId);\n}\n\n/** @return {NoteShort} */\nasync function getMonthNote(month) {\n    const note = await server.get('date-notes/month/' + month, \"date-note\");\n\n    return await treeCache.getNote(note.noteId);\n}\n\n/** @return {NoteShort} */\nasync function getYearNote(year) {\n    const note = await server.get('date-notes/year/' + year, \"date-note\");\n\n    return await treeCache.getNote(note.noteId);\n}\n\nexport default {\n    getTodayNote,\n    getDateNote,\n    getMonthNote,\n    getYearNote\n}","import options from './options.js';\nimport appContext from \"./app_context.js\";\nimport treeService from \"./tree.js\";\n\nfunction getHoistedNoteId() {\n    return options.get('hoistedNoteId');\n}\n\nasync function setHoistedNoteId(noteId) {\n    await options.save('hoistedNoteId', noteId);\n\n    // FIXME - just use option load event\n    appContext.triggerEvent('hoistedNoteChanged', {noteId});\n}\n\nasync function unhoist() {\n    await setHoistedNoteId('root');\n}\n\nfunction isTopLevelNode(node) {\n    return isRootNode(node.getParent());\n}\n\nfunction isRootNode(node) {\n    // even though check for 'root' should not be necessary, we keep it just in case\n    return node.data.noteId === \"root\"\n        || node.data.noteId === getHoistedNoteId();\n}\n\nasync function checkNoteAccess(notePath) {\n    // notePath argument can contain only noteId which is not good when hoisted since\n    // then we need to check the whole note path\n    const runNotePath = await treeService.getRunPath(notePath);\n\n    if (!runNotePath) {\n        console.log(\"Cannot activate \" + notePath);\n        return false;\n    }\n\n    const hoistedNoteId = getHoistedNoteId();\n\n    if (hoistedNoteId !== 'root' && !runNotePath.includes(hoistedNoteId)) {\n        const confirmDialog = await import('../dialogs/confirm.js');\n\n        if (!await confirmDialog.confirm(\"Requested note is outside of hoisted note subtree and you must unhoist to access the note. Do you want to proceed with unhoisting?\")) {\n            return false;\n        }\n\n        // unhoist so we can activate the note\n        await unhoist();\n    }\n\n    return true;\n}\n\nexport default {\n    getHoistedNoteId,\n    setHoistedNoteId,\n    unhoist,\n    isTopLevelNode,\n    isRootNode,\n    checkNoteAccess\n}","import server from \"./server.js\";\nimport utils from \"./utils.js\";\nimport appContext from \"./app_context.js\";\n\nconst keyboardActionRepo = {};\n\nconst keyboardActionsLoaded = server.get('keyboard-actions').then(actions => {\n\tactions = actions.filter(a => !!a.actionName); // filter out separators\n\n\tfor (const action of actions) {\n\t\taction.effectiveShortcuts = action.effectiveShortcuts.filter(shortcut => !shortcut.startsWith(\"global:\"));\n\n\t\tkeyboardActionRepo[action.actionName] = action;\n\t}\n\n\treturn actions;\n});\n\nasync function getActionsForScope(scope) {\n\tconst actions = await keyboardActionsLoaded;\n\n\treturn actions.filter(action => action.scope === scope);\n}\n\nasync function setupActionsForElement(scope, $el, component) {\n\tconst actions = await getActionsForScope(scope);\n\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tutils.bindElShortcut($el, shortcut, () => component.triggerCommand(action.actionName));\n\t\t}\n\t}\n}\n\ngetActionsForScope(\"window\").then(actions => {\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tutils.bindGlobalShortcut(shortcut, () => appContext.triggerCommand(action.actionName));\n\t\t}\n\t}\n});\n\nserver.get('keyboard-shortcuts-for-notes').then(shortcutForNotes => {\n\tfor (const shortcut in shortcutForNotes) {\n\t\tutils.bindGlobalShortcut(shortcut, async () => {\n\t\t\tappContext.tabManager.getActiveTabContext().setNote(shortcutForNotes[shortcut]);\n\t\t});\n\t}\n});\n\nfunction setElementActionHandler($el, actionName, handler) {\n\tkeyboardActionsLoaded.then(() => {\n\t\tconst action = keyboardActionRepo[actionName];\n\n\t\tif (!action) {\n\t\t\tthrow new Error(`Cannot find keyboard action '${actionName}'`);\n\t\t}\n\n\t\t// not setting action.handler since this is not global\n\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tif (shortcut) {\n\t\t\t\tutils.bindElShortcut($el, shortcut, handler);\n\t\t\t}\n\t\t}\n\t});\n}\n\nasync function getAction(actionName, silent = false) {\n\tawait keyboardActionsLoaded;\n\n\tconst action = keyboardActionRepo[actionName];\n\n\tif (!action) {\n\t\tif (silent) {\n\t\t\tconsole.log(`Cannot find action ${actionName}`);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`Cannot find action ${actionName}`);\n\t\t}\n\t}\n\n\treturn action;\n}\n\nfunction updateDisplayedShortcuts($container) {\n\t$container.find('kbd[data-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\t$(el).text(action.effectiveShortcuts.join(', '));\n\t\t}\n\t});\n\n\t$container.find('[data-trigger-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-trigger-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\tconst title = $(el).attr('title');\n\t\t\tconst shortcuts = action.effectiveShortcuts.join(', ');\n\t\t\tconst newTitle = !title || !title.trim() ? shortcuts : `${title} (${shortcuts})`;\n\n\t\t\t$(el).attr('title', newTitle);\n\t\t}\n\t});\n}\n\nexport default {\n\tsetElementActionHandler,\n\tupdateDisplayedShortcuts,\n\tsetupActionsForElement,\n\tgetActionsForScope\n};","const CKEDITOR = {\"js\": [\"libraries/ckeditor/ckeditor.js\"]};\n\nconst CODE_MIRROR = {\n    js: [\n        \"libraries/codemirror/codemirror.js\",\n        \"libraries/codemirror/addon/mode/loadmode.js\",\n        \"libraries/codemirror/addon/fold/xml-fold.js\",\n        \"libraries/codemirror/addon/edit/matchbrackets.js\",\n        \"libraries/codemirror/addon/edit/matchtags.js\",\n        \"libraries/codemirror/addon/search/match-highlighter.js\",\n        \"libraries/codemirror/mode/meta.js\",\n        \"libraries/codemirror/addon/lint/lint.js\",\n        \"libraries/codemirror/addon/lint/eslint.js\"\n    ],\n    css: [\n        \"libraries/codemirror/codemirror.css\",\n        \"libraries/codemirror/addon/lint/lint.css\"\n    ]\n};\n\nconst ESLINT = {js: [\"libraries/eslint.js\"]};\n\nconst COMMONMARK = {js: [\"libraries/commonmark.min.js\"]};\n\nconst RELATION_MAP = {\n    js: [\n        \"libraries/jsplumb.js\",\n        \"libraries/panzoom.js\"\n    ],\n    css: [\n        \"stylesheets/relation_map.css\"\n    ]\n};\n\nconst LINK_MAP = {\n    js: [\n        \"libraries/jsplumb.js\",\n        \"libraries/panzoom.js\",\n        \"libraries/springy.js\"\n    ],\n    css: [\n        \"stylesheets/link_map.css\"\n    ]\n};\n\nconst PRINT_THIS = {js: [\"libraries/printThis.js\"]};\n\nconst KNOCKOUT = {js: [\"libraries/knockout.min.js\"]};\n\nconst CALENDAR_WIDGET = {css: [\"stylesheets/calendar.css\"]};\n\nasync function requireLibrary(library) {\n    if (library.css) {\n        library.css.map(cssUrl => requireCss(cssUrl));\n    }\n\n    if (library.js) {\n        for (const scriptUrl of library.js) {\n            await requireScript(scriptUrl);\n        }\n    }\n}\n\n// we save the promises in case of the same script being required concurrently multiple times\nconst loadedScriptPromises = {};\n\nasync function requireScript(url) {\n    if (!loadedScriptPromises[url]) {\n        loadedScriptPromises[url] = $.ajax({\n            url: url,\n            dataType: \"script\",\n            cache: true\n        });\n    }\n\n    await loadedScriptPromises[url];\n}\n\nasync function requireCss(url) {\n    const cssLinks = Array\n        .from(document.querySelectorAll('link'))\n        .map(el => el.href);\n\n    if (!cssLinks.some(l => l.endsWith(url))) {\n        $('head').append($('<link rel=\"stylesheet\" type=\"text/css\" />').attr('href', url));\n    }\n}\n\nexport default {\n    requireCss,\n    requireLibrary,\n    CKEDITOR,\n    CODE_MIRROR,\n    ESLINT,\n    COMMONMARK,\n    RELATION_MAP,\n    LINK_MAP,\n    PRINT_THIS,\n    KNOCKOUT,\n    CALENDAR_WIDGET\n}","import treeService from './tree.js';\nimport contextMenu from \"./context_menu.js\";\nimport appContext from \"./app_context.js\";\n\nfunction getNotePathFromUrl(url) {\n    const notePathMatch = /#(root[A-Za-z0-9/]*)$/.exec(url);\n\n    return notePathMatch === null ? null : notePathMatch[1];\n}\n\nasync function createNoteLink(notePath, options = {}) {\n    if (!notePath || !notePath.trim()) {\n        console.error(\"Missing note path\");\n\n        return $(\"<span>\").text(\"[missing note]\");\n    }\n\n    let noteTitle = options.title;\n    const showTooltip = options.showTooltip === undefined ? true : options.showTooltip;\n    const showNotePath = options.showNotePath === undefined ? false : options.showNotePath;\n\n    if (!noteTitle) {\n        const {noteId, parentNoteId} = treeService.getNoteIdAndParentIdFromNotePath(notePath);\n\n        noteTitle = await treeService.getNoteTitle(noteId, parentNoteId);\n    }\n\n    const $noteLink = $(\"<a>\", {\n        href: 'javascript:',\n        text: noteTitle\n    }).attr('data-action', 'note')\n        .attr('data-note-path', notePath);\n\n    if (!showTooltip) {\n        $noteLink.addClass(\"no-tooltip-preview\");\n    }\n\n    const $container = $(\"<span>\").append($noteLink);\n\n    if (showNotePath) {\n        notePath = await treeService.resolveNotePath(notePath);\n\n        if (notePath) {\n            const noteIds = notePath.split(\"/\");\n            noteIds.pop(); // remove last element\n\n            const parentNotePath = noteIds.join(\"/\").trim();\n\n            if (parentNotePath) {\n                $container.append($(\"<small>\").text(\" (\" + await treeService.getNotePathTitle(parentNotePath) + \")\"));\n            }\n        }\n    }\n\n    return $container;\n}\n\nfunction getNotePathFromLink($link) {\n    const notePathAttr = $link.attr(\"data-note-path\");\n\n    if (notePathAttr) {\n        return notePathAttr;\n    }\n\n    const url = $link.attr('href');\n\n    return url ? getNotePathFromUrl(url) : null;\n}\n\nfunction goToLink(e) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    const $link = $(e.target).closest(\"a\");\n\n    const notePath = getNotePathFromLink($link);\n\n    if (notePath) {\n        if ((e.which === 1 && e.ctrlKey) || e.which === 2) {\n            appContext.tabManager.openTabWithNote(notePath);\n        }\n        else if (e.which === 1) {\n            const activeTabContext = appContext.tabManager.getActiveTabContext();\n            activeTabContext.setNote(notePath);\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        if (e.which === 1) {\n            const address = $link.attr('href');\n\n            if (address && address.startsWith('http')) {\n                window.open(address, '_blank');\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction linkContextMenu(e) {\n    const $link = $(e.target).closest(\"a\");\n\n    const notePath = getNotePathFromLink($link);\n\n    if (!notePath) {\n        return;\n    }\n\n    e.preventDefault();\n\n    contextMenu.show({\n        x: e.pageX,\n        y: e.pageY,\n        items: [\n            {title: \"Open note in new tab\", command: \"openNoteInNewTab\", uiIcon: \"empty\"},\n            {title: \"Open note in new window\", command: \"openNoteInNewWindow\", uiIcon: \"window-open\"}\n        ],\n        selectMenuItemHandler: ({command}) => {\n            if (command === 'openNoteInNewTab') {\n                appContext.tabManager.openTabWithNote(notePath);\n            }\n            else if (command === 'openNoteInNewWindow') {\n                appContext.openInNewWindow(notePath);\n            }\n        }\n    });\n}\n\n// when click on link popup, in case of internal link, just go the the referenced note instead of default behavior\n// of opening the link in new window/tab\n$(document).on('mousedown', \"a[data-action='note']\", goToLink);\n$(document).on('mousedown', 'div.popover-content a, div.ui-tooltip-content a', goToLink);\n$(document).on('dblclick', '.note-detail-text a', goToLink);\n$(document).on('mousedown', '.note-detail-text a:not(.reference-link)', function (e) {\n    const $link = $(e.target).closest(\"a\");\n    const notePath = getNotePathFromLink($link);\n\n    if ((e.which === 1 && e.ctrlKey) || e.which === 2) {\n        // if it's a ctrl-click, then we open on new tab, otherwise normal flow (CKEditor opens link-editing dialog)\n        e.preventDefault();\n\n        if (notePath) {\n            appContext.tabManager.openTabWithNote(notePath, false);\n        }\n        else {\n            const address = $link.attr('href');\n\n            window.open(address, '_blank');\n        }\n\n        return true;\n    }\n});\n\n$(document).on('mousedown', '.note-detail-book a', goToLink);\n$(document).on('mousedown', '.note-detail-render a', goToLink);\n$(document).on('mousedown', '.note-detail-text a.reference-link', goToLink);\n$(document).on('mousedown', '.note-detail-readonly-text a.reference-link', goToLink);\n$(document).on('mousedown', '.note-detail-readonly-text a', goToLink);\n$(document).on('mousedown', 'a.ck-link-actions__preview', goToLink);\n$(document).on('click', 'section.include-note a', goToLink);\n$(document).on('click', 'a.ck-link-actions__preview', e => {\n    e.preventDefault();\n    e.stopPropagation();\n});\n\n$(document).on('contextmenu', 'a.ck-link-actions__preview', linkContextMenu);\n$(document).on('contextmenu', '.note-detail-text a', linkContextMenu);\n$(document).on('contextmenu', '.note-detail-readonly-text a', linkContextMenu);\n$(document).on('contextmenu', \"a[data-action='note']\", linkContextMenu);\n$(document).on('contextmenu', \".note-detail-render a\", linkContextMenu);\n$(document).on('contextmenu', \".note-paths-widget a\", linkContextMenu);\n$(document).on('contextmenu', \"section.include-note a\", linkContextMenu);\n\nexport default {\n    getNotePathFromUrl,\n    createNoteLink,\n    goToLink\n};\n","import options from \"./options.js\";\n\nconst MIME_TYPES_DICT = [\n    { default: true, title: \"Plain text\", mime: \"text/plain\" },\n    { title: \"APL\", mime: \"text/apl\" },\n    { title: \"PGP\", mime: \"application/pgp\" },\n    { title: \"ASN.1\", mime: \"text/x-ttcn-asn\" },\n    { title: \"Asterisk\", mime: \"text/x-asterisk\" },\n    { title: \"Brainfuck\", mime: \"text/x-brainfuck\" },\n    { default: true, title: \"C\", mime: \"text/x-csrc\" },\n    { default: true, title: \"C++\", mime: \"text/x-c++src\" },\n    { title: \"Cobol\", mime: \"text/x-cobol\" },\n    { default: true, title: \"C#\", mime: \"text/x-csharp\" },\n    { title: \"Clojure\", mime: \"text/x-clojure\" },\n    { title: \"ClojureScript\", mime: \"text/x-clojurescript\" },\n    { title: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\" },\n    { title: \"CMake\", mime: \"text/x-cmake\" },\n    { title: \"CoffeeScript\", mime: \"text/coffeescript\" },\n    { title: \"Common Lisp\", mime: \"text/x-common-lisp\" },\n    { title: \"Cypher\", mime: \"application/x-cypher-query\" },\n    { title: \"Cython\", mime: \"text/x-cython\" },\n    { title: \"Crystal\", mime: \"text/x-crystal\" },\n    { default: true, title: \"CSS\", mime: \"text/css\" },\n    { title: \"CQL\", mime: \"text/x-cassandra\" },\n    { title: \"D\", mime: \"text/x-d\" },\n    { title: \"Dart\", mime: \"application/dart\" },\n    { title: \"diff\", mime: \"text/x-diff\" },\n    { title: \"Django\", mime: \"text/x-django\" },\n    { title: \"Dockerfile\", mime: \"text/x-dockerfile\" },\n    { title: \"DTD\", mime: \"application/xml-dtd\" },\n    { title: \"Dylan\", mime: \"text/x-dylan\" },\n    { title: \"EBNF\", mime: \"text/x-ebnf\" },\n    { title: \"ECL\", mime: \"text/x-ecl\" },\n    { title: \"edn\", mime: \"application/edn\" },\n    { title: \"Eiffel\", mime: \"text/x-eiffel\" },\n    { title: \"Elm\", mime: \"text/x-elm\" },\n    { title: \"Embedded Javascript\", mime: \"application/x-ejs\" },\n    { title: \"Embedded Ruby\", mime: \"application/x-erb\" },\n    { title: \"Erlang\", mime: \"text/x-erlang\" },\n    { title: \"Esper\", mime: \"text/x-esper\" },\n    { title: \"Factor\", mime: \"text/x-factor\" },\n    { title: \"FCL\", mime: \"text/x-fcl\" },\n    { title: \"Forth\", mime: \"text/x-forth\" },\n    { title: \"Fortran\", mime: \"text/x-fortran\" },\n    { title: \"F#\", mime: \"text/x-fsharp\" },\n    { title: \"Gas\", mime: \"text/x-gas\" },\n    { title: \"Gherkin\", mime: \"text/x-feature\" },\n    { title: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\" },\n    { default: true, title: \"Go\", mime: \"text/x-go\" },\n    { default: true, title: \"Groovy\", mime: \"text/x-groovy\" },\n    { title: \"HAML\", mime: \"text/x-haml\" },\n    { default: true, title: \"Haskell\", mime: \"text/x-haskell\" },\n    { title: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\" },\n    { title: \"Haxe\", mime: \"text/x-haxe\" },\n    { title: \"HXML\", mime: \"text/x-hxml\" },\n    { title: \"ASP.NET\", mime: \"application/x-aspx\" },\n    { default: true, title: \"HTML\", mime: \"text/html\" },\n    { default: true, title: \"HTTP\", mime: \"message/http\" },\n    { title: \"IDL\", mime: \"text/x-idl\" },\n    { title: \"Pug\", mime: \"text/x-pug\" },\n    { default: true, title: \"Java\", mime: \"text/x-java\" },\n    { title: \"Java Server Pages\", mime: \"application/x-jsp\" },\n    { default: true, title: 'JS frontend', mime: 'application/javascript;env=frontend' },\n    { default: true, title: 'JS backend', mime: 'application/javascript;env=backend' },\n    { default: true, title: \"JSON\", mime: \"application/json\" },\n    { title: \"JSON-LD\", mime: \"application/ld+json\" },\n    { title: \"JSX\", mime: \"text/jsx\" },\n    { title: \"Jinja2\", mime: \"text/jinja2\" },\n    { title: \"Julia\", mime: \"text/x-julia\" },\n    { default: true, title: \"Kotlin\", mime: \"text/x-kotlin\" },\n    { title: \"LESS\", mime: \"text/x-less\" },\n    { title: \"LiveScript\", mime: \"text/x-livescript\" },\n    { title: \"Lua\", mime: \"text/x-lua\" },\n    { default: true, title: \"Markdown\", mime: \"text/x-markdown\" },\n    { title: \"mIRC\", mime: \"text/mirc\" },\n    { title: \"MariaDB SQL\", mime: \"text/x-mariadb\" },\n    { title: \"Mathematica\", mime: \"text/x-mathematica\" },\n    { title: \"Modelica\", mime: \"text/x-modelica\" },\n    { title: \"MUMPS\", mime: \"text/x-mumps\" },\n    { title: \"MS SQL\", mime: \"text/x-mssql\" },\n    { title: \"mbox\", mime: \"application/mbox\" },\n    { title: \"MySQL\", mime: \"text/x-mysql\" },\n    { title: \"Nginx\", mime: \"text/x-nginx-conf\" },\n    { title: \"NSIS\", mime: \"text/x-nsis\" },\n    { title: \"NTriples\", mime: \"application/n-triples\" },\n    { title: \"Objective-C\", mime: \"text/x-objectivec\" },\n    { title: \"OCaml\", mime: \"text/x-ocaml\" },\n    { title: \"Octave\", mime: \"text/x-octave\" },\n    { title: \"Oz\", mime: \"text/x-oz\" },\n    { title: \"Pascal\", mime: \"text/x-pascal\" },\n    { title: \"PEG.js\", mime: \"null\" },\n    { default: true, title: \"Perl\", mime: \"text/x-perl\" },\n    { default: true, title: \"PHP\", mime: \"text/x-php\" },\n    { title: \"Pig\", mime: \"text/x-pig\" },\n    { title: \"PLSQL\", mime: \"text/x-plsql\" },\n    { title: \"PostgreSQL\", mime: \"text/x-pgsql\" },\n    { title: \"PowerShell\", mime: \"application/x-powershell\" },\n    { title: \"Properties files\", mime: \"text/x-properties\" },\n    { title: \"ProtoBuf\", mime: \"text/x-protobuf\" },\n    { default: true, title: \"Python\", mime: \"text/x-python\" },\n    { title: \"Puppet\", mime: \"text/x-puppet\" },\n    { title: \"Q\", mime: \"text/x-q\" },\n    { title: \"R\", mime: \"text/x-rsrc\" },\n    { title: \"reStructuredText\", mime: \"text/x-rst\" },\n    { title: \"RPM Changes\", mime: \"text/x-rpm-changes\" },\n    { title: \"RPM Spec\", mime: \"text/x-rpm-spec\" },\n    { default: true, title: \"Ruby\", mime: \"text/x-ruby\" },\n    { title: \"Rust\", mime: \"text/x-rustsrc\" },\n    { title: \"SAS\", mime: \"text/x-sas\" },\n    { title: \"Sass\", mime: \"text/x-sass\" },\n    { title: \"Scala\", mime: \"text/x-scala\" },\n    { title: \"Scheme\", mime: \"text/x-scheme\" },\n    { title: \"SCSS\", mime: \"text/x-scss\" },\n    { default: true, title: \"Shell\", mime: \"text/x-sh\" },\n    { title: \"Sieve\", mime: \"application/sieve\" },\n    { title: \"Slim\", mime: \"text/x-slim\" },\n    { title: \"Smalltalk\", mime: \"text/x-stsrc\" },\n    { title: \"Smarty\", mime: \"text/x-smarty\" },\n    { title: \"Solr\", mime: \"text/x-solr\" },\n    { title: \"SML\", mime: \"text/x-sml\" },\n    { title: \"Soy\", mime: \"text/x-soy\" },\n    { title: \"SPARQL\", mime: \"application/sparql-query\" },\n    { title: \"Spreadsheet\", mime: \"text/x-spreadsheet\" },\n    { default: true, title: \"SQL\", mime: \"text/x-sql\" },\n    { title: \"SQLite\", mime: \"text/x-sqlite\" },\n    { title: \"Squirrel\", mime: \"text/x-squirrel\" },\n    { title: \"Stylus\", mime: \"text/x-styl\" },\n    { default: true, title: \"Swift\", mime: \"text/x-swift\" },\n    { title: \"sTeX\", mime: \"text/x-stex\" },\n    { title: \"LaTeX\", mime: \"text/x-latex\" },\n    { title: \"SystemVerilog\", mime: \"text/x-systemverilog\" },\n    { title: \"Tcl\", mime: \"text/x-tcl\" },\n    { title: \"Textile\", mime: \"text/x-textile\" },\n    { title: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\" },\n    { title: \"Tiki wiki\", mime: \"text/tiki\" },\n    { title: \"TOML\", mime: \"text/x-toml\" },\n    { title: \"Tornado\", mime: \"text/x-tornado\" },\n    { title: \"troff\", mime: \"text/troff\" },\n    { title: \"TTCN\", mime: \"text/x-ttcn\" },\n    { title: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\" },\n    { title: \"Turtle\", mime: \"text/turtle\" },\n    { title: \"TypeScript\", mime: \"application/typescript\" },\n    { title: \"TypeScript-JSX\", mime: \"text/typescript-jsx\" },\n    { title: \"Twig\", mime: \"text/x-twig\" },\n    { title: \"Web IDL\", mime: \"text/x-webidl\" },\n    { title: \"VB.NET\", mime: \"text/x-vb\" },\n    { title: \"VBScript\", mime: \"text/vbscript\" },\n    { title: \"Velocity\", mime: \"text/velocity\" },\n    { title: \"Verilog\", mime: \"text/x-verilog\" },\n    { title: \"VHDL\", mime: \"text/x-vhdl\" },\n    { title: \"Vue.js Component\", mime: \"text/x-vue\" },\n    { default: true, title: \"XML\", mime: \"text/xml\" },\n    { title: \"XQuery\", mime: \"application/xquery\" },\n    { title: \"Yacas\", mime: \"text/x-yacas\" },\n    { default: true, title: \"YAML\", mime: \"text/x-yaml\" },\n    { title: \"Z80\", mime: \"text/x-z80\" },\n    { title: \"mscgen\", mime: \"text/x-mscgen\" },\n    { title: \"xu\", mime: \"text/x-xu\" },\n    { title: \"msgenny\", mime: \"text/x-msgenny\" }\n];\n\nlet mimeTypes = null;\n\nfunction loadMimeTypes() {\n    mimeTypes = JSON.parse(JSON.stringify(MIME_TYPES_DICT)); // clone\n\n    const enabledMimeTypes = options.getJson('codeNotesMimeTypes')\n        || MIME_TYPES_DICT.filter(mt => mt.default).map(mt => mt.mime);\n\n    for (const mt of mimeTypes) {\n        mt.enabled = enabledMimeTypes.includes(mt.mime) || mt.mime === 'text/plain'; // text/plain is always enabled\n    }\n}\n\nasync function getMimeTypes() {\n    if (mimeTypes === null) {\n        loadMimeTypes();\n    }\n\n    return mimeTypes;\n}\n\nexport default {\n    getMimeTypes,\n    loadMimeTypes\n}","/**\n * Purpose of this class is to cache list of attributes for notes.\n *\n * Cache invalidation granularity is global - whenever a write operation is detected to notes, branches or attributes\n * we invalidate the whole cache. That's OK, since the purpose for this is to speed up batch read-only operations, such\n * as loading the tree which uses attributes heavily.\n */\nclass NoteAttributeCache {\n    constructor() {\n        this.attributes = {};\n    }\n\n    invalidate() {\n        this.attributes = {};\n    }\n}\n\nconst noteAttributeCache = new NoteAttributeCache();\n\nexport default noteAttributeCache;","import server from \"./server.js\";\nimport appContext from \"./app_context.js\";\nimport utils from './utils.js';\n\n// this key needs to have this value so it's hit by the tooltip\nconst SELECTED_PATH_KEY = \"data-note-path\";\n\nasync function autocompleteSource(term, cb) {\n    const result = await server.get('autocomplete'\n        + '?query=' + encodeURIComponent(term)\n        + '&activeNoteId=' + appContext.tabManager.getActiveTabNoteId());\n\n    if (result.length === 0) {\n        result.push({\n            pathTitle: \"No results\",\n            path: \"\"\n        });\n    }\n\n    cb(result);\n}\n\nfunction clearText($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\").trigger('change');\n}\n\nfunction showRecentNotes($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\");\n    $el.trigger('focus');\n}\n\nfunction initNoteAutocomplete($el, options) {\n    if ($el.hasClass(\"note-autocomplete-input\") || utils.isMobile()) {\n        return $el;\n    }\n\n    options = options || {};\n\n    $el.addClass(\"note-autocomplete-input\");\n\n    const $clearTextButton = $(\"<a>\")\n            .addClass(\"input-group-text input-clearer-button bx bx-x\")\n            .prop(\"title\", \"Clear text field\");\n\n    const $showRecentNotesButton = $(\"<a>\")\n            .addClass(\"input-group-text show-recent-notes-button bx bx-time\")\n            .prop(\"title\", \"Show recent notes\");\n\n    const $goToSelectedNoteButton = $(\"<a>\")\n        .addClass(\"input-group-text go-to-selected-note-button bx bx-arrow-to-right\")\n        .attr(\"data-action\", \"note\");\n\n    const $sideButtons = $(\"<div>\")\n        .addClass(\"input-group-append\")\n        .append($clearTextButton)\n        .append($showRecentNotesButton);\n\n    if (!options.hideGoToSelectedNoteButton) {\n        $sideButtons.append($goToSelectedNoteButton);\n    }\n\n    $el.after($sideButtons);\n\n    $clearTextButton.on('click', () => clearText($el));\n\n    $showRecentNotesButton.on('click', e => {\n        showRecentNotes($el);\n\n        // this will cause the click not give focus to the \"show recent notes\" button\n        // this is important because otherwise input will lose focus immediatelly and not show the results\n        return false;\n    });\n\n    $el.autocomplete({\n        appendTo: document.querySelector('body'),\n        hint: false,\n        autoselect: true,\n        openOnFocus: true,\n        minLength: 0,\n        tabAutocomplete: false\n    }, [\n        {\n            source: autocompleteSource,\n            displayKey: 'pathTitle',\n            templates: {\n                suggestion: function(suggestion) {\n                    return suggestion.highlightedTitle;\n                }\n            },\n            // we can't cache identical searches because notes can be created / renamed, new recent notes can be added\n            cache: false\n        }\n    ]);\n\n    $el.on('autocomplete:selected', (event, suggestion) => $el.setSelectedPath(suggestion.path));\n    $el.on('autocomplete:closed', () => {\n        if (!$el.val().trim()) {\n            clearText($el);\n        }\n    });\n\n    return $el;\n}\n\nfunction init() {\n    $.fn.getSelectedPath = function () {\n        if (!$(this).val().trim()) {\n            return \"\";\n        } else {\n            return $(this).attr(SELECTED_PATH_KEY);\n        }\n    };\n\n    $.fn.setSelectedPath = function (path) {\n        path = path || \"\";\n\n        $(this).attr(SELECTED_PATH_KEY, path);\n\n        $(this)\n            .closest(\".input-group\")\n            .find(\".go-to-selected-note-button\")\n            .toggleClass(\"disabled\", !path.trim())\n            .attr(SELECTED_PATH_KEY, path); // we also set attr here so tooltip can be displayed\n    };\n}\n\nexport default {\n    autocompleteSource,\n    initNoteAutocomplete,\n    showRecentNotes,\n    init\n}","import hoistedNoteService from \"./hoisted_note.js\";\nimport appContext from \"./app_context.js\";\nimport utils from \"./utils.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport server from \"./server.js\";\nimport ws from \"./ws.js\";\nimport treeCache from \"./tree_cache.js\";\nimport toastService from \"./toast.js\";\n\nasync function createNewTopLevelNote() {\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    await createNote(hoistedNoteId);\n}\n\nasync function createNote(parentNoteId, options = {}) {\n    options = Object.assign({\n        activate: true,\n        target: 'into'\n    }, options);\n\n    // if isProtected isn't available (user didn't enter password yet), then note is created as unencrypted\n    // but this is quite weird since user doesn't see WHERE the note is being created so it shouldn't occur often\n    if (!options.isProtected || !protectedSessionHolder.isProtectedSessionAvailable()) {\n        options.isProtected = false;\n    }\n\n    if (appContext.tabManager.getActiveTabNoteType() !== 'text') {\n        options.saveSelection = false;\n    }\n\n    if (options.saveSelection && utils.isCKEditorInitialized()) {\n        [options.title, options.content] = parseSelectedHtml(window.cutToNote.getSelectedHtml());\n    }\n\n    const newNoteName = options.title || \"new note\";\n\n    const {note, branch} = await server.post(`notes/${parentNoteId}/children?target=${options.target}&targetBranchId=${options.targetBranchId}`, {\n        title: newNoteName,\n        content: options.content || \"\",\n        isProtected: options.isProtected,\n        type: options.type\n    });\n\n    if (options.saveSelection && utils.isCKEditorInitialized()) {\n        // we remove the selection only after it was saved to server to make sure we don't lose anything\n        window.cutToNote.removeSelection();\n    }\n\n    if (options.activate) {\n        await ws.waitForMaxKnownSyncId();\n\n        const activeTabContext = appContext.tabManager.getActiveTabContext();\n        await activeTabContext.setNote(note.noteId);\n\n        appContext.triggerCommand('focusAndSelectTitle');\n    }\n\n    return {note, branch};\n}\n\n/* If first element is heading, parse it out and use it as a new heading. */\nfunction parseSelectedHtml(selectedHtml) {\n    const dom = $.parseHTML(selectedHtml);\n\n    if (dom.length > 0 && dom[0].tagName && dom[0].tagName.match(/h[1-6]/i)) {\n        const title = $(dom[0]).text();\n        // remove the title from content (only first occurence)\n        const content = selectedHtml.replace(dom[0].outerHTML, \"\");\n\n        return [title, content];\n    }\n    else {\n        return [null, selectedHtml];\n    }\n}\n\nasync function duplicateNote(noteId, parentNoteId) {\n    const {note} = await server.post(`notes/${noteId}/duplicate/${parentNoteId}`);\n\n    await ws.waitForMaxKnownSyncId();\n\n    await appContext.tabManager.activateOrOpenNote(note.noteId);\n\n    const origNote = await treeCache.getNote(noteId);\n    toastService.showMessage(`Note \"${origNote.title}\" has been duplicated`);\n}\n\nexport default {\n    createNote,\n    createNewTopLevelNote,\n    duplicateNote\n};","import server from \"./server.js\";\n\nclass Options {\n    constructor() {\n        this.initializedPromise = server.get('options').then(data => this.load(data));\n    }\n\n    load(arr) {\n        this.arr = arr;\n    }\n\n    get(key) {\n        return this.arr[key];\n    }\n\n    getNames() {\n        return Object.keys(this.arr);\n    }\n\n    getJson(key) {\n        try {\n            return JSON.parse(this.arr[key]);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n\n    getInt(key) {\n        return parseInt(this.arr[key]);\n    }\n\n    getFloat(key) {\n        return parseFloat(this.arr[key]);\n    }\n\n    is(key) {\n        return this.arr[key] === 'true';\n    }\n\n    set(key, value) {\n        this.arr[key] = value;\n    }\n\n    async save(key, value) {\n        this.set(key, value);\n\n        const payload = {};\n        payload[key] = value;\n\n        await server.put(`options`, payload);\n    }\n}\n\nconst options = new Options();\n\nexport default options;","import utils from './utils.js';\nimport server from './server.js';\nimport protectedSessionHolder from './protected_session_holder.js';\nimport toastService from \"./toast.js\";\nimport ws from \"./ws.js\";\nimport appContext from \"./app_context.js\";\nimport treeCache from \"./tree_cache.js\";\n\nlet protectedSessionDeferred = null;\n\nasync function leaveProtectedSession() {\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        protectedSessionHolder.resetProtectedSession();\n    }\n}\n\n/** returned promise resolves with true if new protected session was established, false if no action was necessary */\nfunction enterProtectedSession() {\n    const dfd = $.Deferred();\n\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        dfd.resolve(false);\n    }\n    else {\n        // using deferred instead of promise because it allows resolving from outside\n        protectedSessionDeferred = dfd;\n\n        import(\"../dialogs/protected_session.js\").then(dialog => dialog.show());\n    }\n\n    return dfd.promise();\n}\n\nasync function reloadData() {\n    const allNoteIds = Object.keys(treeCache.notes);\n\n    await treeCache.loadInitialTree();\n\n    // make sure that all notes used in the application are loaded, including the ones not shown in the tree\n    await treeCache.reloadNotes(allNoteIds, true);\n}\n\nasync function setupProtectedSession(password) {\n    const response = await enterProtectedSessionOnServer(password);\n\n    if (!response.success) {\n        toastService.showError(\"Wrong password.\", 3000);\n        return;\n    }\n\n    protectedSessionHolder.setProtectedSessionId(response.protectedSessionId);\n    protectedSessionHolder.touchProtectedSession();\n\n    await reloadData();\n\n    await appContext.triggerEvent('treeCacheReloaded');\n\n    appContext.triggerEvent('protectedSessionStarted');\n\n    if (protectedSessionDeferred !== null) {\n        import(\"../dialogs/protected_session.js\").then(dialog => dialog.close());\n\n        protectedSessionDeferred.resolve(true);\n        protectedSessionDeferred = null;\n    }\n\n    toastService.showMessage(\"Protected session has been started.\");\n}\n\nasync function enterProtectedSessionOnServer(password) {\n    return await server.post('login/protected', {\n        password: password\n    });\n}\n\nasync function protectNote(noteId, protect, includingSubtree) {\n    await enterProtectedSession();\n\n    await server.put(`notes/${noteId}/protect/${protect ? 1 : 0}?subtree=${includingSubtree ? 1 : 0}`);\n}\n\nfunction makeToast(message, protectingLabel, text) {\n    return {\n        id: message.taskId,\n        title: protectingLabel + \" status\",\n        message: text,\n        icon: message.data.protect ? \"check-shield\" : \"shield\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'protect-notes') {\n        return;\n    }\n\n    const protectingLabel = message.data.protect ? \"Protecting\" : \"Unprotecting\";\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message, protectingLabel,protectingLabel + \" in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message, protectingLabel, protectingLabel + \" finished successfully.\");\n        toast.closeAfter = 3000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nexport default {\n    protectNote,\n    enterProtectedSession,\n    leaveProtectedSession,\n    setupProtectedSession\n};\n","import utils from \"./utils.js\";\nimport options from './options.js';\n\nconst PROTECTED_SESSION_ID_KEY = 'protectedSessionId';\n\nlet lastProtectedSessionOperationDate = 0;\n\nsetInterval(() => {\n    const protectedSessionTimeout = options.getInt('protectedSessionTimeout');\n    if (lastProtectedSessionOperationDate\n        && Date.now() - lastProtectedSessionOperationDate > protectedSessionTimeout * 1000) {\n\n        resetProtectedSession();\n    }\n}, 5000);\n\nfunction setProtectedSessionId(id) {\n    // using session cookie so that it disappears after browser/tab is closed\n    utils.setSessionCookie(PROTECTED_SESSION_ID_KEY, id);\n}\n\nfunction resetProtectedSession() {\n    utils.setSessionCookie(PROTECTED_SESSION_ID_KEY, null);\n\n    // most secure solution - guarantees nothing remained in memory\n    // since this expires because user doesn't use the app, it shouldn't be disruptive\n    utils.reloadApp();\n}\n\nfunction isProtectedSessionAvailable() {\n    return !!utils.getCookie(PROTECTED_SESSION_ID_KEY);\n}\n\nfunction touchProtectedSession() {\n    if (isProtectedSessionAvailable()) {\n        lastProtectedSessionOperationDate = Date.now();\n\n        setProtectedSessionId(utils.getCookie(PROTECTED_SESSION_ID_KEY));\n    }\n}\n\nfunction touchProtectedSessionIfNecessary(note) {\n    if (note && note.isProtected && isProtectedSessionAvailable()) {\n        touchProtectedSession();\n    }\n}\n\nexport default {\n    setProtectedSessionId,\n    resetProtectedSession,\n    isProtectedSessionAvailable,\n    touchProtectedSession,\n    touchProtectedSessionIfNecessary\n};","import treeService from \"./tree.js\";\nimport linkService from \"./link.js\";\nimport treeCache from \"./tree_cache.js\";\nimport utils from \"./utils.js\";\n\nfunction setupGlobalTooltip() {\n    $(document).on(\"mouseenter\", \"a\", mouseEnterHandler);\n    $(document).on(\"mouseleave\", \"a\", mouseLeaveHandler);\n\n    // close any note tooltip after click, this fixes the problem that sometimes tooltips remained on the screen\n    $(document).on(\"click\", () => $('.note-tooltip').remove());\n}\n\nfunction setupElementTooltip($el) {\n    $el.on('mouseenter', mouseEnterHandler);\n    $el.on('mouseleave', mouseLeaveHandler);\n}\n\nasync function mouseEnterHandler() {\n    const $link = $(this);\n\n    if ($link.hasClass(\"no-tooltip-preview\")\n        || $link.hasClass(\"disabled\")\n        || $link.attr(\"data-action\") === 'note-revision') {\n        return;\n    }\n\n    // this is to avoid showing tooltip from inside CKEditor link editor dialog\n    if ($link.closest(\".ck-link-actions\").length) {\n        return;\n    }\n\n    let notePath = linkService.getNotePathFromUrl($link.attr(\"href\"));\n\n    if (!notePath) {\n        notePath = $link.attr(\"data-note-path\");\n    }\n\n    if (!notePath) {\n        return;\n    }\n\n    const noteId = treeService.getNoteIdFromNotePath(notePath);\n\n    const note = await treeCache.getNote(noteId);\n    const noteComplement = await treeCache.getNoteComplement(noteId);\n\n    const html = await renderTooltip(note, noteComplement);\n\n    // we need to check if we're still hovering over the element\n    // since the operation to get tooltip content was async, it is possible that\n    // we now create tooltip which won't close because it won't receive mouseleave event\n    if ($(this).is(\":hover\")) {\n        $(this).tooltip({\n            delay: {\"show\": 300, \"hide\": 100},\n            container: 'body',\n            placement: 'auto',\n            trigger: 'manual',\n            boundary: 'window',\n            title: html,\n            html: true,\n            template: '<div class=\"tooltip note-tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n            sanitize: false\n        });\n\n        $(this).tooltip('show');\n    }\n}\n\nfunction mouseLeaveHandler() {\n    $(this).tooltip('dispose');\n}\n\nasync function renderTooltip(note, noteComplement) {\n    if (note.isDeleted) {\n        return '<div>Note has been deleted.</div>';\n    }\n\n    const attributes = note.getAttributes();\n\n    let content = '';\n\n    const promoted = attributes\n        .filter(attr => attr.type === 'label-definition' || attr.type === 'relation-definition')\n        .filter(attr => !attr.name.startsWith(\"child:\"))\n        .filter(attr => {\n            const json = attr.jsonValue;\n\n            return json && json.isPromoted;\n        });\n\n    if (promoted.length > 0) {\n        const $table = $(\"<table>\").addClass(\"promoted-attributes-in-tooltip\");\n\n        for (const definitionAttr of promoted) {\n            const definitionType = definitionAttr.type;\n            const valueType = definitionType.substr(0, definitionType.length - 11);\n\n            let valueAttrs = attributes.filter(el => el.name === definitionAttr.name && el.type === valueType);\n\n            for (const valueAttr of valueAttrs) {\n                if (!valueAttr.value) {\n                    continue;\n                }\n\n                let $value = \"\";\n\n                if (valueType === 'label') {\n                    $value = $(\"<td>\").text(valueAttr.value);\n                }\n                else if (valueType === 'relation' && valueAttr.value) {\n                    $value = $(\"<td>\").append(await linkService.createNoteLink(valueAttr.value));\n                }\n\n                const $row = $(\"<tr>\")\n                    .append($(\"<th>\").text(definitionAttr.name))\n                    .append($value);\n\n                $table.append($row);\n            }\n        }\n\n        content += $table.prop('outerHTML');\n    }\n\n    if (note.type === 'text' && !utils.isHtmlEmpty(noteComplement.content)) {\n        content += '<div class=\"ck-content\">' + noteComplement.content + '</div>';\n    }\n    else if (note.type === 'code' && noteComplement.content && noteComplement.content.trim()) {\n        content += $(\"<pre>\")\n            .text(noteComplement.content)\n            .prop('outerHTML');\n    }\n    else if (note.type === 'image') {\n        content += $(\"<img>\")\n            .prop(\"src\", `api/images/${note.noteId}/${note.title}`)\n            .prop('outerHTML');\n    }\n    // other types of notes don't have tooltip preview\n\n    return content;\n}\n\nexport default {\n    setupGlobalTooltip,\n    setupElementTooltip\n}","import TabAwareWidget from \"./tab_aware_widget.js\";\nimport options from \"../services/options.js\";\n\nconst WIDGET_TPL = `\n<div class=\"card widget\">\n    <div class=\"card-header\">\n        <div>           \n            <button class=\"btn btn-sm widget-title\" data-toggle=\"collapse\" data-target=\"#[to be set]\">\n                Collapsible Group Item\n            </button>\n            \n            <a class=\"widget-help external no-arrow bx bx-info-circle\"></a>\n        </div>\n        \n        <div class=\"widget-header-actions\"></div>\n    </div>\n\n    <div id=\"[to be set]\" class=\"collapse body-wrapper\" style=\"transition: none; \">\n        <div class=\"card-body\"></div>\n    </div>\n</div>`;\n\nexport default class CollapsibleWidget extends TabAwareWidget {\n    get widgetTitle() { return \"Untitled widget\"; }\n\n    get headerActions() { return []; }\n\n    get help() { return {}; }\n\n    doRender() {\n        this.$widget = $(WIDGET_TPL);\n        this.$widget.find('[data-target]').attr('data-target', \"#\" + this.componentId);\n\n        this.$bodyWrapper = this.$widget.find('.body-wrapper');\n        this.$bodyWrapper.attr('id', this.componentId); // for toggle to work we need id\n\n        // not using constructor name because of webpack mangling class names ...\n        this.widgetName = this.widgetTitle.replace(/[^[a-zA-Z0-9]/g, \"_\");\n\n        if (!options.is(this.widgetName + 'Collapsed')) {\n            this.$bodyWrapper.collapse(\"show\");\n        }\n\n        // using immediate variants of the event so that the previous collapse is not caught\n        this.$bodyWrapper.on('hide.bs.collapse', () => this.saveCollapsed(true));\n        this.$bodyWrapper.on('show.bs.collapse', () => this.saveCollapsed(false));\n\n        this.$body = this.$bodyWrapper.find('.card-body');\n\n        this.$title = this.$widget.find('.widget-title');\n        this.$title.text(this.widgetTitle);\n\n        this.$help = this.$widget.find('.widget-help');\n\n        if (this.help.title) {\n            this.$help.attr(\"title\", this.help.title);\n            this.$help.attr(\"href\", this.help.url || \"javascript:\");\n\n            if (!this.help.url) {\n                this.$help.addClass('no-link');\n            }\n        }\n        else {\n            this.$help.hide();\n        }\n\n        this.$headerActions = this.$widget.find('.widget-header-actions');\n        this.$headerActions.append(...this.headerActions);\n\n        this.initialized = this.doRenderBody();\n\n        this.decorateWidget();\n\n        return this.$widget;\n    }\n\n    saveCollapsed(collapse) {\n        options.save(this.widgetName + 'Collapsed', collapse.toString());\n\n        this.triggerEvent(`widgetCollapsedStateChanged`, {widgetName: this.widgetName, collapse});\n    }\n\n    /**\n     * This event is used to synchronize collapsed state of all the tab-cached widgets since they are all rendered\n     * separately but should behave uniformly for the user.\n     */\n    widgetCollapsedStateChangedEvent({widgetName, collapse}) {\n        if (widgetName === this.widgetName) {\n            this.$bodyWrapper.toggleClass('show', !collapse);\n        }\n    }\n\n    /** for overriding */\n    decorateWidget() {}\n\n    /** for overriding */\n    async doRenderBody() {}\n\n    isExpanded() {\n        return this.$bodyWrapper.hasClass(\"show\");\n    }\n}","import TabAwareWidget from \"./tab_aware_widget.js\";\nimport keyboardActionsService from \"../services/keyboard_actions.js\";\n\nexport default class TabCachingWidget extends TabAwareWidget {\n    constructor(widgetFactory) {\n        super();\n\n        this.widgetFactory = widgetFactory;\n        this.widgets = {};\n    }\n\n    doRender() {\n        return this.$widget = $(`<div class=\"marker\" style=\"display: none;\">`);\n    }\n\n    async newTabOpenedEvent({tabContext}) {\n        const {tabId} = tabContext;\n\n        if (this.widgets[tabId]) {\n            return;\n        }\n\n        this.widgets[tabId] = this.widgetFactory();\n\n        const $renderedWidget = this.widgets[tabId].render();\n        this.widgets[tabId].toggleExt(false); // new tab is always not active, can be activated after creation\n\n        this.$widget.after($renderedWidget);\n\n        keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n        await this.widgets[tabId].handleEvent('setTabContext', {tabContext});\n\n        this.child(this.widgets[tabId]); // add as child only once it is ready (rendered with tabContext)\n    }\n\n    tabRemovedEvent({tabId}) {\n        const widget = this.widgets[tabId];\n\n        if (widget) {\n            widget.remove();\n            delete this.widgets[tabId];\n\n            this.children = this.children.filter(ch => ch !== widget);\n        }\n    }\n\n    async refresh() {\n        this.toggleExt(true);\n    }\n\n    toggleInt(show) {} // not needed\n\n    toggleExt(show) {\n        for (const tabId in this.widgets) {\n            this.widgets[tabId].toggleExt(show && this.isTab(tabId));\n        }\n    }\n\n    /**\n     * widget.hasBeenAlreadyShown is intended for lazy loading of cached tabs - initial note switches of new tabs\n     * are not executed, we're waiting for the first tab activation and then we update the tab. After this initial\n     * activation further note switches are always propagated to the tabs.\n     */\n    handleEventInChildren(name, data) {\n        if (['tabNoteSwitched', 'tabNoteSwitchedAndActivated'].includes(name)) {\n            // this event is propagated only to the widgets of a particular tab\n            const widget = this.widgets[data.tabContext.tabId];\n\n            if (widget && (widget.hasBeenAlreadyShown || name === 'tabNoteSwitchedAndActivated')) {\n                widget.hasBeenAlreadyShown = true;\n\n                return widget.handleEvent('tabNoteSwitched', data);\n            }\n            else {\n                return Promise.resolve();\n            }\n        }\n\n        if (name === 'activeTabChanged') {\n            const widget = this.widgets[data.tabContext.tabId];\n\n            if (widget.hasBeenAlreadyShown) {\n                return Promise.resolve();\n            }\n            else {\n                widget.hasBeenAlreadyShown = true;\n\n                return widget.handleEvent(name, data);\n            }\n        } else {\n            return super.handleEventInChildren(name, data);\n        }\n    }\n}","import treeService from './tree.js';\nimport server from './server.js';\nimport utils from './utils.js';\nimport toastService from './toast.js';\nimport linkService from './link.js';\nimport treeCache from './tree_cache.js';\nimport noteTooltipService from './note_tooltip.js';\nimport protectedSessionService from './protected_session.js';\nimport dateNotesService from './date_notes.js';\nimport CollapsibleWidget from '../widgets/collapsible_widget.js';\nimport ws from \"./ws.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport appContext from \"./app_context.js\";\nimport TabAwareWidget from \"../widgets/tab_aware_widget.js\";\nimport TabCachingWidget from \"../widgets/tab_caching_widget.js\";\nimport BasicWidget from \"../widgets/basic_widget.js\";\n\n/**\n * This is the main frontend API interface for scripts. It's published in the local \"api\" object.\n *\n * @constructor\n * @hideconstructor\n */\nfunction FrontendScriptApi(startNote, currentNote, originEntity = null, $container = null) {\n    const $pluginButtons = $(\"#plugin-buttons\");\n\n    /** @property {jQuery} container of all the rendered script content */\n    this.$container = $container;\n\n    /** @property {object} note where script started executing */\n    this.startNote = startNote;\n    /** @property {object} note where script is currently executing */\n    this.currentNote = currentNote;\n    /** @property {object|null} entity whose event triggered this execution */\n    this.originEntity = originEntity;\n\n    // to keep consistency with backend API\n    this.dayjs = dayjs;\n\n    /** @property {CollapsibleWidget} */\n    this.CollapsibleWidget = CollapsibleWidget;\n\n    /** @property {TabAwareWidget} */\n    this.TabAwareWidget = TabAwareWidget;\n\n    /** @property {TabCachingWidget} */\n    this.TabCachingWidget = TabCachingWidget;\n\n    /** @property {BasicWidget} */\n    this.BasicWidget = BasicWidget;\n\n    /**\n     * Activates note in the tree and in the note detail.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @returns {Promise<void>}\n     */\n    this.activateNote = async notePath => {\n        await appContext.tabManager.getActiveTabContext().setNote(notePath);\n    };\n\n    /**\n     * Activates newly created note. Compared to this.activateNote() also makes sure that frontend has been fully synced.\n     *\n     * @param {string} notePath (or noteId)\n     * @return {Promise<void>}\n     */\n    this.activateNewNote = async notePath => {\n        await ws.waitForMaxKnownSyncId();\n\n        await appContext.tabManager.getActiveTabContext().setNote(notePath);\n        appContext.triggerEvent('focusAndSelectTitle');\n    };\n\n    /**\n     * @typedef {Object} ToolbarButtonOptions\n     * @property {string} title\n     * @property {string} [icon] - name of the boxicon to be used (e.g. \"time\" for \"bx-time\" icon)\n     * @property {function} action - callback handling the click on the button\n     * @property {string} [shortcut] - keyboard shortcut for the button, e.g. \"alt+t\"\n     */\n\n    /**\n     * Adds new button the the plugin area.\n     *\n     * @param {ToolbarButtonOptions} opts\n     */\n    this.addButtonToToolbar = opts => {\n        const buttonId = \"toolbar-button-\" + opts.title.replace(/[^a-zA-Z0-9]/g, \"-\");\n\n        const button = $('<button>')\n            .addClass(\"btn btn-sm\")\n            .on('click', opts.action);\n\n        if (opts.icon) {\n            button.append($(\"<span>\").addClass(\"bx bx-\" + opts.icon))\n                  .append(\"&nbsp;\");\n        }\n\n        button.append($(\"<span>\").text(opts.title));\n\n        button.attr('id', buttonId);\n\n        if ($(\"#\" + buttonId).replaceWith(button).length === 0) {\n            $pluginButtons.append(button);\n        }\n\n        if (opts.shortcut) {\n            utils.bindGlobalShortcut(opts.shortcut, opts.action);\n\n            button.attr(\"title\", \"Shortcut \" + opts.shortcut);\n        }\n    };\n\n    function prepareParams(params) {\n        if (!params) {\n            return params;\n        }\n\n        return params.map(p => {\n            if (typeof p === \"function\") {\n                return \"!@#Function: \" + p.toString();\n            }\n            else {\n                return p;\n            }\n        });\n    }\n\n    /**\n     * Executes given anonymous function on the backend.\n     * Internally this serializes the anonymous function into string and sends it to backend via AJAX.\n     *\n     * @param {string} script - script to be executed on the backend\n     * @param {Array.<?>} params - list of parameters to the anonymous function to be send to backend\n     * @return {Promise<*>} return value of the executed function on the backend\n     */\n    this.runOnBackend = async (script, params = []) => {\n        if (typeof script === \"function\") {\n            script = script.toString();\n        }\n\n        const ret = await server.post('script/exec', {\n            script: script,\n            params: prepareParams(params),\n            startNoteId: startNote.noteId,\n            currentNoteId: currentNote.noteId,\n            originEntityName: \"notes\", // currently there's no other entity on frontend which can trigger event\n            originEntityId: originEntity ? originEntity.noteId : null\n        }, \"script\");\n\n        if (ret.success) {\n            // wait until all the changes done in the script has been synced to frontend before continuing\n            await ws.waitForSyncId(ret.maxSyncId);\n\n            return ret.executionResult;\n        }\n        else {\n            throw new Error(\"server error: \" + ret.error);\n        }\n    };\n\n    /**\n     * @deprecated new name of this API call is runOnBackend so use that\n     * @method\n     */\n    this.runOnServer = this.runOnBackend;\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"@dateModified =* MONTH AND @log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<NoteShort[]>}\n     */\n    this.searchForNotes = async searchString => {\n        const noteIds = await this.runOnServer(async searchString => {\n            const notes = await api.searchForNotes(searchString);\n\n            return notes.map(note => note.noteId);\n        }, [searchString]);\n\n        return await treeCache.getNotes(noteIds);\n    };\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"@dateModified =* MONTH AND @log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<NoteShort|null>}\n     */\n    this.searchForNote = async searchString => {\n        const notes = await this.searchForNotes(searchString);\n\n        return notes.length > 0 ? notes[0] : null;\n    };\n\n    /**\n     * Returns note by given noteId. If note is missing from cache, it's loaded.\n     **\n     * @param {string} noteId\n     * @return {Promise<NoteShort>}\n     */\n    this.getNote = async noteId => await treeCache.getNote(noteId);\n\n    /**\n     * Returns list of notes. If note is missing from cache, it's loaded.\n     *\n     * This is often used to bulk-fill the cache with notes which would have to be picked one by one\n     * otherwise (by e.g. createNoteLink())\n     *\n     * @param {string[]} noteIds\n     * @param {boolean} [silentNotFoundError] - don't report error if the note is not found\n     * @return {Promise<NoteShort[]>}\n     */\n    this.getNotes = async (noteIds, silentNotFoundError = false) => await treeCache.getNotes(noteIds, silentNotFoundError);\n\n    /**\n     * Update frontend tree (note) cache from the backend.\n     *\n     * @param {string[]} noteIds\n     * @method\n     */\n    this.reloadNotes = async noteIds => await treeCache.reloadNotes(noteIds);\n\n    /**\n     * Instance name identifies particular Trilium instance. It can be useful for scripts\n     * if some action needs to happen on only one specific instance.\n     *\n     * @return {string}\n     */\n    this.getInstanceName = () => window.glob.instanceName;\n\n    /**\n     * @method\n     * @param {Date} date\n     * @returns {string} date in YYYY-MM-DD format\n     */\n    this.formatDateISO = utils.formatDateISO;\n\n    /**\n     * @method\n     * @param {string} str\n     * @returns {Date} parsed object\n     */\n    this.parseDate = utils.parseDate;\n\n    /**\n     * Show info message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showMessage = toastService.showMessage;\n\n    /**\n     * Show error message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showError = toastService.showError;\n\n    /**\n     * @method\n     * @deprecated - this is now no-op since all the changes should be gracefully handled per widget\n     */\n    this.refreshTree = () => {};\n\n    /**\n     * Create note link (jQuery object) for given note.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {string} [noteTitle] - if not present we'll use note title\n     */\n    this.createNoteLink = linkService.createNoteLink;\n\n    /**\n     * Adds given text to the editor cursor\n     *\n     * @param {string} text - this must be clear text, HTML is not supported.\n     * @method\n     */\n    this.addTextToActiveTabEditor = text => appContext.triggerCommand('addTextToActiveEditor', {text});\n\n    /**\n     * @method\n     * @returns {NoteShort} active note (loaded into right pane)\n     */\n    this.getActiveTabNote = () => appContext.tabManager.getActiveTabNote();\n\n    /**\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html for a documentation on the returned instance.\n     *\n     * @method\n     * @param callback - method receiving \"textEditor\" instance\n     */\n    this.getActiveTabTextEditor = callback => appContext.triggerCommand('executeInActiveEditor', {callback});\n\n    /**\n     * @method\n     * @returns {Promise<string|null>} returns note path of active note or null if there isn't active note\n     */\n    this.getActiveTabNotePath = () => appContext.tabManager.getActiveTabNotePath();\n\n    /**\n     * @method\n     * @param {object} $el - jquery object on which to setup the tooltip\n     */\n    this.setupElementTooltip = noteTooltipService.setupElementTooltip;\n\n    /**\n     * @deprecated use protectNote and protectSubtree instead\n     * @method\n     */\n    this.protectActiveNote = async () => {\n        const activeNote = appContext.tabManager.getActiveTabNote();\n\n        await protectedSessionService.protectNote(activeNote.noteId, true, false);\n    };\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect note, false to unprotect\n     */\n    this.protectNote = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, false);\n    };\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect subtree, false to unprotect\n     */\n    this.protectSubTree = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, true);\n    };\n\n    /**\n     * Returns date-note for today. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @return {Promise<NoteShort>}\n     */\n    this.getTodayNote = dateNotesService.getTodayNote;\n\n    /**\n     * Returns date-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} date - e.g. \"2019-04-29\"\n     * @return {Promise<NoteShort>}\n     */\n    this.getDateNote = dateNotesService.getDateNote;\n\n    /**\n     * Returns month-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} month - e.g. \"2019-04\"\n     * @return {Promise<NoteShort>}\n     */\n    this.getMonthNote = dateNotesService.getMonthNote;\n\n    /**\n     * Returns year-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} year - e.g. \"2019\"\n     * @return {Promise<NoteShort>}\n     */\n    this.getYearNote = dateNotesService.getYearNote;\n\n    /**\n     * Hoist note. See https://github.com/zadam/trilium/wiki/Note-hoisting\n     *\n     * @method\n     * @param {string} noteId - set hoisted note. 'root' will effectively unhoist\n     * @return {Promise}\n     */\n    this.setHoistedNoteId = hoistedNoteService.setHoistedNoteId;\n\n    /**\n     * @method\n     * @param {string} keyboardShortcut - e.g. \"ctrl+shift+a\"\n     * @param {function} handler\n     */\n    this.bindGlobalShortcut = utils.bindGlobalShortcut;\n\n    /**\n     * Trilium runs in backend and frontend process, when something is changed on the backend from script,\n     * frontend will get asynchronously synchronized.\n     *\n     * This method returns a promise which resolves once all the backend -> frontend synchronization is finished.\n     * Typical use case is when new note has been created, we should wait until it is synced into frontend and only then activate it.\n     *\n     * @method\n     */\n    this.waitUntilSynced = ws.waitForMaxKnownSyncId;\n\n    /**\n     * This will refresh all currently opened notes which have included note specified in the parameter\n     *\n     * @param includedNoteId - noteId of the included note\n     */\n    this.refreshIncludedNote = includedNoteId => appContext.triggerEvent('refreshIncludedNote', {noteId: includedNoteId});\n}\n\nexport default FrontendScriptApi;\n","import FrontendScriptApi from './frontend_script_api.js';\nimport utils from './utils.js';\nimport treeCache from './tree_cache.js';\n\nasync function ScriptContext(startNoteId, allNoteIds, originEntity = null, $container = null) {\n    const modules = {};\n\n    await treeCache.initializedPromise;\n\n    const startNote = await treeCache.getNote(startNoteId);\n    const allNotes = await treeCache.getNotes(allNoteIds);\n\n    return {\n        modules: modules,\n        notes: utils.toObject(allNotes, note => [note.noteId, note]),\n        apis: utils.toObject(allNotes, note => [note.noteId, new FrontendScriptApi(startNote, note, originEntity, $container)]),\n        require: moduleNoteIds => {\n            return moduleName => {\n                const candidates = allNotes.filter(note => moduleNoteIds.includes(note.noteId));\n                const note = candidates.find(c => c.title === moduleName);\n\n                if (!note) {\n                    throw new Error(\"Could not find module note \" + moduleName);\n                }\n\n                return modules[note.noteId].exports;\n            }\n        }\n    };\n}\n\nexport default ScriptContext;","import utils from './utils.js';\n\nconst REQUEST_LOGGING_ENABLED = false;\n\nfunction getHeaders(headers) {\n    // headers need to be lowercase because node.js automatically converts them to lower case\n    // so hypothetical protectedSessionId becomes protectedsessionid on the backend\n    // also avoiding using underscores instead of dashes since nginx filters them out by default\n    const allHeaders = {\n        'trilium-source-id': glob.sourceId,\n        'trilium-local-now-datetime': utils.localNowDateTime(),\n        'x-csrf-token': glob.csrfToken\n    };\n\n    for (const headerName in headers) {\n        if (headers[headerName]) {\n            allHeaders[headerName] = headers[headerName];\n        }\n    }\n\n    if (utils.isElectron()) {\n        // passing it explicitely here because of the electron HTTP bypass\n        allHeaders.cookie = document.cookie;\n    }\n\n    return allHeaders;\n}\n\nasync function get(url, sourceId) {\n    return await call('GET', url, null, {'trilium-source-id': sourceId});\n}\n\nasync function post(url, data, sourceId) {\n    return await call('POST', url, data, {'trilium-source-id': sourceId});\n}\n\nasync function put(url, data, sourceId) {\n    return await call('PUT', url, data, {'trilium-source-id': sourceId});\n}\n\nasync function remove(url, sourceId) {\n    return await call('DELETE', url, null, {'trilium-source-id': sourceId});\n}\n\nlet i = 1;\nconst reqResolves = {};\n\nlet maxKnownSyncId = 0;\n\nasync function call(method, url, data, headers = {}) {\n    let resp;\n\n    const start = Date.now();\n\n    if (utils.isElectron()) {\n        const ipc = utils.dynamicRequire('electron').ipcRenderer;\n        const requestId = i++;\n\n        resp = await new Promise((resolve, reject) => {\n            reqResolves[requestId] = resolve;\n\n            if (REQUEST_LOGGING_ENABLED) {\n                console.log(utils.now(), \"Request #\" + requestId + \" to \" + method + \" \" + url);\n            }\n\n            ipc.send('server-request', {\n                requestId: requestId,\n                headers: getHeaders(headers),\n                method: method,\n                url: \"/\" + baseApiUrl + url,\n                data: data\n            });\n        });\n    }\n    else {\n        resp = await ajax(url, method, data, headers);\n    }\n\n    const end = Date.now();\n\n    if (glob.PROFILING_LOG) {\n        console.log(`${method} ${url} took ${end - start}ms`);\n    }\n\n    const maxSyncIdStr = resp.headers['trilium-max-sync-id'];\n\n    if (maxSyncIdStr && maxSyncIdStr.trim()) {\n        maxKnownSyncId = Math.max(maxKnownSyncId, parseInt(maxSyncIdStr));\n    }\n\n    return resp.body;\n}\n\nfunction ajax(url, method, data, headers) {\n    return new Promise((res, rej) => {\n        const options = {\n            url: baseApiUrl + url,\n            type: method,\n            headers: getHeaders(headers),\n            timeout: 60000,\n            success: (body, textStatus, jqXhr) => {\n                const respHeaders = {};\n\n                jqXhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(line => {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    respHeaders[header] = parts.join(': ');\n                });\n\n                res({\n                    body,\n                    headers: respHeaders\n                });\n            },\n            error: async (jqXhr, textStatus, error) => {\n                const message = \"Error when calling \" + method + \" \" + url + \": \" + textStatus + \" - \" + error;\n                const toastService = (await import(\"./toast.js\")).default;\n                toastService.showError(message);\n                toastService.throwError(message);\n\n                rej(error);\n            }\n        };\n\n        if (data) {\n            try {\n                options.data = JSON.stringify(data);\n            } catch (e) {\n                console.log(\"Can't stringify data: \", data, \" because of error: \", e)\n            }\n            options.contentType = \"application/json\";\n        }\n\n        $.ajax(options);\n    });\n}\n\nif (utils.isElectron()) {\n    const ipc = utils.dynamicRequire('electron').ipcRenderer;\n\n    ipc.on('server-response', (event, arg) => {\n        if (REQUEST_LOGGING_ENABLED) {\n            console.log(utils.now(), \"Response #\" + arg.requestId + \": \" + arg.statusCode);\n        }\n\n        reqResolves[arg.requestId]({\n            body: arg.body,\n            headers: arg.headers\n        });\n\n        delete reqResolves[arg.requestId];\n    });\n}\n\nexport default {\n    get,\n    post,\n    put,\n    remove,\n    ajax,\n    // don't remove, used from CKEditor image upload!\n    getHeaders,\n    getMaxKnownSyncId: () => maxKnownSyncId\n};","export default class SpacedUpdate {\n    constructor(updater, updateInterval = 1000) {\n        this.updater = updater;\n        this.lastUpdated = Date.now();\n        this.changed = false;\n        this.updateInterval = updateInterval;\n    }\n\n    scheduleUpdate() {\n        if (!this.changeForbidden) {\n            this.changed = true;\n            setTimeout(() => this.triggerUpdate());\n        }\n    }\n\n    async updateNowIfNecessary() {\n        if (this.changed) {\n            this.changed = false;\n            await this.updater();\n        }\n    }\n\n    triggerUpdate() {\n        if (!this.changed) {\n            return;\n        }\n\n        if (Date.now() - this.lastUpdated > this.updateInterval) {\n            this.updater();\n            this.lastUpdated = Date.now();\n            this.changed = false;\n        }\n        else {\n            // update not triggered but changes are still pending so we need to schedule another check\n            this.scheduleUpdate();\n        }\n    }\n\n    async allowUpdateWithoutChange(callback) {\n        this.changeForbidden = true;\n\n        try {\n            await callback();\n        }\n        finally {\n            this.changeForbidden = false;\n        }\n    }\n}\n","import ws from \"./ws.js\";\nimport utils from \"./utils.js\";\n\nfunction toast(options) {\n    const $toast = $(`<div class=\"toast\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n    <div class=\"toast-header\">\n        <strong class=\"mr-auto\"><span class=\"bx bx-${options.icon}\"></span> ${options.title}</strong>\n        <button type=\"button\" class=\"ml-2 mb-1 close\" data-dismiss=\"toast\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n        </button>\n    </div>\n    <div class=\"toast-body\">\n        ${options.message}\n    </div>\n</div>`);\n\n    if (options.id) {\n        $toast.attr(\"id\", \"toast-\" + options.id);\n    }\n\n    $(\"#toast-container\").append($toast);\n\n    $toast.toast({\n        delay: options.delay || 3000,\n        autohide: !!options.autohide\n    });\n\n    $toast.on('hidden.bs.toast', e => e.target.remove());\n\n    $toast.toast(\"show\");\n\n    return $toast;\n}\n\nfunction showPersistent(options) {\n    let $toast = $(\"#toast-\" + options.id);\n\n    if ($toast.length > 0) {\n        $toast.find('.toast-body').html(options.message);\n    }\n    else {\n        options.autohide = false;\n\n        $toast = toast(options);\n    }\n\n    if (options.closeAfter) {\n        setTimeout(() => $toast.remove(), options.closeAfter);\n    }\n}\n\nfunction closePersistent(id) {\n    $(\"#toast-\" + id).remove();\n}\n\nfunction showMessage(message, delay = 2000) {\n    console.debug(utils.now(), \"message: \", message);\n\n    toast({\n        title: \"Info\",\n        icon: \"check\",\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction showAndLogError(message, delay = 10000) {\n    showError(message, delay);\n\n    ws.logError(message);\n}\n\nfunction showError(message, delay = 10000) {\n    console.log(utils.now(), \"error: \", message);\n\n    toast({\n        title: \"Error\",\n        icon: 'alert',\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction throwError(message) {\n    ws.logError(message);\n\n    throw new Error(message);\n}\n\nexport default {\n    showMessage,\n    showError,\n    showAndLogError,\n    throwError,\n    showPersistent,\n    closePersistent\n}","import ws from './ws.js';\nimport utils from './utils.js';\nimport server from './server.js';\nimport treeCache from './tree_cache.js';\nimport hoistedNoteService from '../services/hoisted_note.js';\nimport appContext from \"./app_context.js\";\n\n/**\n * Accepts notePath which might or might not be valid and returns an existing path as close to the original\n * notePath as possible.\n * @return {string|null}\n */\nasync function resolveNotePath(notePath) {\n    const runPath = await getRunPath(notePath);\n\n    return runPath ? runPath.join(\"/\") : null;\n}\n\n/**\n * Accepts notePath and tries to resolve it. Part of the path might not be valid because of note moving (which causes\n * path change) or other corruption, in that case this will try to get some other valid path to the correct note.\n *\n * @return {string[]}\n */\nasync function getRunPath(notePath, logErrors = true) {\n    utils.assertArguments(notePath);\n\n    notePath = notePath.split(\"-\")[0].trim();\n\n    if (notePath.length === 0) {\n        return;\n    }\n\n    const path = notePath.split(\"/\").reverse();\n\n    if (!path.includes(\"root\")) {\n        path.push('root');\n    }\n\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    const effectivePath = [];\n    let childNoteId = null;\n    let i = 0;\n\n    while (true) {\n        if (i >= path.length) {\n            break;\n        }\n\n        const parentNoteId = path[i++];\n\n        if (childNoteId !== null) {\n            const child = await treeCache.getNote(childNoteId);\n\n            if (!child) {\n                console.log(\"Can't find note \" + childNoteId);\n                return;\n            }\n\n            const parents = child.getParentNotes();\n\n            if (!parents) {\n                ws.logError(\"No parents found for \" + childNoteId);\n                return;\n            }\n\n            if (!parents.some(p => p.noteId === parentNoteId)) {\n                if (logErrors) {\n                    console.log(utils.now(), \"Did not find parent \" + parentNoteId + \" for child \" + childNoteId);\n                }\n\n                if (parents.length > 0) {\n                    if (logErrors) {\n                        console.log(utils.now(), \"Available parents:\", parents);\n                    }\n\n                    const someNotePath = await getSomeNotePath(parents[0]);\n\n                    if (someNotePath) { // in case it's root the path may be empty\n                        const pathToRoot = someNotePath.split(\"/\").reverse();\n\n                        for (const noteId of pathToRoot) {\n                            effectivePath.push(noteId);\n                        }\n\n                        effectivePath.push('root');\n                    }\n\n                    break;\n                }\n                else {\n                    if (logErrors) {\n                        console.log(\"No parents so no run path.\");\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        effectivePath.push(parentNoteId);\n        childNoteId = parentNoteId;\n\n        if (parentNoteId === hoistedNoteId) {\n            break;\n        }\n    }\n\n    return effectivePath.reverse();\n}\n\nasync function getSomeNotePath(note) {\n    utils.assertArguments(note);\n\n    const path = [];\n\n    let cur = note;\n\n    while (cur.noteId !== 'root') {\n        path.push(cur.noteId);\n\n        const parents = cur.getParentNotes();\n\n        if (!parents.length) {\n            console.error(`Can't find parents for note ${cur.noteId}`);\n            return;\n        }\n\n        cur = parents[0];\n    }\n\n    path.push('root');\n\n    return path.reverse().join('/');\n}\n\nasync function sortAlphabetically(noteId) {\n    await server.put('notes/' + noteId + '/sort');\n}\n\nws.subscribeToMessages(message => {\n   if (message.type === 'open-note') {\n       appContext.tabManager.activateOrOpenNote(message.noteId);\n\n       if (utils.isElectron()) {\n           const currentWindow = utils.dynamicRequire(\"electron\").remote.getCurrentWindow();\n\n           currentWindow.show();\n       }\n   }\n});\n\nfunction getParentProtectedStatus(node) {\n    return hoistedNoteService.isRootNode(node) ? 0 : node.getParent().data.isProtected;\n}\n\nfunction getNoteIdFromNotePath(notePath) {\n    if (!notePath) {\n        return null;\n    }\n\n    const path = notePath.split(\"/\");\n\n    const lastSegment = path[path.length - 1];\n\n    // path could have also tabId suffix\n    return lastSegment.split(\"-\")[0];\n}\n\nfunction getNoteIdAndParentIdFromNotePath(notePath) {\n    if (notePath === 'root') {\n        return {\n            noteId: 'root',\n            parentNoteId: 'none'\n        };\n    }\n\n    let parentNoteId = 'root';\n    let noteId = '';\n\n    if (notePath) {\n        const path = notePath.split(\"/\");\n\n        const lastSegment = path[path.length - 1];\n\n        // path could have also tabId suffix\n        noteId = lastSegment.split(\"-\")[0];\n\n        if (path.length > 1) {\n            parentNoteId = path[path.length - 2];\n        }\n    }\n\n    return {\n        parentNoteId,\n        noteId\n    }\n}\n\nfunction getNotePath(node) {\n    if (!node) {\n        console.error(\"Node is null\");\n        return \"\";\n    }\n\n    const path = [];\n\n    while (node && !hoistedNoteService.isRootNode(node)) {\n        if (node.data.noteId) {\n            path.push(node.data.noteId);\n        }\n\n        node = node.getParent();\n    }\n\n    if (node) { // null node can happen directly after unhoisting when tree is still hoisted but option has been changed already\n        path.push(node.data.noteId); // root or hoisted noteId\n    }\n\n    return path.reverse().join(\"/\");\n}\n\nasync function getNoteTitle(noteId, parentNoteId = null) {\n    utils.assertArguments(noteId);\n\n    const note = await treeCache.getNote(noteId);\n    if (!note) {\n        return \"[not found]\";\n    }\n\n    let {title} = note;\n\n    if (parentNoteId !== null) {\n        const branchId = note.parentToBranch[parentNoteId];\n\n        if (branchId) {\n            const branch = treeCache.getBranch(branchId);\n\n            if (branch && branch.prefix) {\n                title = branch.prefix + ' - ' + title;\n            }\n        }\n    }\n\n    return title;\n}\n\nasync function getNotePathTitle(notePath) {\n    utils.assertArguments(notePath);\n\n    const titlePath = [];\n\n    if (notePath.startsWith('root/')) {\n        notePath = notePath.substr(5);\n    }\n\n    // special case when we want just root's title\n    if (notePath === 'root') {\n        return await getNoteTitle(notePath);\n    }\n\n    let parentNoteId = 'root';\n\n    for (const noteId of notePath.split('/')) {\n        titlePath.push(await getNoteTitle(noteId, parentNoteId));\n\n        parentNoteId = noteId;\n    }\n\n    return titlePath.join(' / ');\n}\n\nfunction getHashValueFromAddress() {\n    const str = document.location.hash ? document.location.hash.substr(1) : \"\"; // strip initial #\n\n    return str.split(\"-\");\n}\n\nfunction parseNotePath(notePath) {\n    let noteIds = notePath.split('/');\n\n    if (noteIds[0] !== 'root') {\n        noteIds = ['root'].concat(noteIds);\n    }\n\n    return noteIds;\n}\n\nexport default {\n    sortAlphabetically,\n    resolveNotePath,\n    getSomeNotePath,\n    getRunPath,\n    getParentProtectedStatus,\n    getNotePath,\n    getNoteIdFromNotePath,\n    getNoteIdAndParentIdFromNotePath,\n    getNoteTitle,\n    getNotePathTitle,\n    getHashValueFromAddress,\n    parseNotePath\n};\n","import server from '../services/server.js';\nimport Attribute from './attribute.js';\nimport noteAttributeCache from \"../services/note_attribute_cache.js\";\n\nconst LABEL = 'label';\nconst LABEL_DEFINITION = 'label-definition';\nconst RELATION = 'relation';\nconst RELATION_DEFINITION = 'relation-definition';\n\n/**\n * FIXME: since there's no \"full note\" anymore we can rename this to Note\n *\n * This note's representation is used in note tree and is kept in TreeCache.\n */\nclass NoteShort {\n    /**\n     * @param {TreeCache} treeCache\n     * @param {Object.<string, Object>} row\n     */\n    constructor(treeCache, row) {\n        this.treeCache = treeCache;\n\n        /** @type {string[]} */\n        this.attributes = [];\n\n        /** @type {string[]} */\n        this.targetRelations = [];\n\n        /** @type {string[]} */\n        this.parents = [];\n        /** @type {string[]} */\n        this.children = [];\n\n        /** @type {Object.<string, string>} */\n        this.parentToBranch = {};\n\n        /** @type {Object.<string, string>} */\n        this.childToBranch = {};\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @param {string} */\n        this.noteId = row.noteId;\n        /** @param {string} */\n        this.title = row.title;\n        /** @param {int} */\n        this.contentLength = row.contentLength;\n        /** @param {boolean} */\n        this.isProtected = !!row.isProtected;\n        /** @param {string} one of 'text', 'code', 'file' or 'render' */\n        this.type = row.type;\n        /** @param {string} content-type, e.g. \"application/json\" */\n        this.mime = row.mime;\n        /** @param {boolean} */\n        this.isDeleted = row.isDeleted;\n    }\n\n    addParent(parentNoteId, branchId) {\n        if (!this.parents.includes(parentNoteId)) {\n            this.parents.push(parentNoteId);\n        }\n\n        this.parentToBranch[parentNoteId] = branchId;\n    }\n\n    addChild(childNoteId, branchId) {\n        if (!this.children.includes(childNoteId)) {\n            this.children.push(childNoteId);\n        }\n\n        this.childToBranch[childNoteId] = branchId;\n\n        const branchIdPos = {};\n\n        for (const branchId of Object.values(this.childToBranch)) {\n            branchIdPos[branchId] = this.treeCache.getBranch(branchId).notePosition;\n        }\n\n        this.children.sort((a, b) => branchIdPos[this.childToBranch[a]] < branchIdPos[this.childToBranch[b]] ? -1 : 1);\n    }\n\n    /** @returns {boolean} */\n    isJson() {\n        return this.mime === \"application/json\";\n    }\n\n    async getContent() {\n        // we're not caching content since these objects are in treeCache and as such pretty long lived\n        const note = await server.get(\"notes/\" + this.noteId);\n\n        return note.content;\n    }\n\n    async getJsonContent() {\n        const content = await this.getContent();\n\n        try {\n            return JSON.parse(content);\n        }\n        catch (e) {\n            console.log(`Cannot parse content of note ${this.noteId}: `, e.message);\n\n            return null;\n        }\n    }\n\n    /** @returns {string[]} */\n    getBranchIds() {\n        return Object.values(this.parentToBranch);\n    }\n\n    /** @returns {Branch[]} */\n    getBranches() {\n        const branchIds = Object.values(this.parentToBranch);\n\n        return this.treeCache.getBranches(branchIds);\n    }\n\n    /** @returns {boolean} */\n    hasChildren() {\n        return this.children.length > 0;\n    }\n\n    /** @returns {Branch[]} */\n    getChildBranches() {\n        // don't use Object.values() to guarantee order\n        const branchIds = this.children.map(childNoteId => this.childToBranch[childNoteId]);\n\n        return this.treeCache.getBranches(branchIds);\n    }\n\n    /** @returns {string[]} */\n    getParentNoteIds() {\n        return this.parents;\n    }\n\n    /** @returns {NoteShort[]} */\n    getParentNotes() {\n        return this.treeCache.getNotesFromCache(this.parents);\n    }\n\n    /** @returns {string[]} */\n    getChildNoteIds() {\n        return this.children;\n    }\n\n    /** @returns {Promise<NoteShort[]>} */\n    async getChildNotes() {\n        return await this.treeCache.getNotes(this.children);\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {Attribute[]} all note's attributes, including inherited ones\n     */\n    getOwnedAttributes(type, name) {\n        const attrs = this.attributes\n            .map(attributeId => this.treeCache.attributes[attributeId])\n            .filter(Boolean); // filter out nulls;\n\n        return this.__filterAttrs(attrs, type, name);\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {Attribute[]} all note's attributes, including inherited ones\n     */\n    getAttributes(type, name) {\n        return this.__filterAttrs(this.__getCachedAttributes([]), type, name);\n    }\n\n    __getCachedAttributes(path) {\n        // notes/clones cannot form tree cycles, it is possible to create attribute inheritance cycle via templates\n        // when template instance is a parent of template itself\n        if (path.includes(this.noteId)) {\n            return [];\n        }\n\n        if (!(this.noteId in noteAttributeCache)) {\n            const ownedAttributes = this.getOwnedAttributes();\n\n            const attrArrs = [\n                ownedAttributes\n            ];\n\n            const newPath = [...path, this.noteId];\n\n            for (const templateAttr of ownedAttributes.filter(oa => oa.type === 'relation' && oa.name === 'template')) {\n                const templateNote = this.treeCache.notes[templateAttr.value];\n\n                if (templateNote && templateNote.noteId !== this.noteId) {\n                    attrArrs.push(templateNote.__getCachedAttributes(newPath));\n                }\n            }\n\n            if (this.noteId !== 'root') {\n                for (const parentNote of this.getParentNotes()) {\n                    // these virtual parent-child relationships are also loaded into frontend tree cache\n                    if (parentNote.type !== 'search') {\n                        attrArrs.push(parentNote.__getInheritableAttributes(newPath));\n                    }\n                }\n            }\n\n            noteAttributeCache.attributes[this.noteId] = attrArrs.flat();\n        }\n\n        return noteAttributeCache.attributes[this.noteId];\n    }\n\n    __filterAttrs(attributes, type, name) {\n        if (!type && !name) {\n            return attributes;\n        } else if (type && name) {\n            return attributes.filter(attr => attr.type === type && attr.name === name);\n        } else if (type) {\n            return attributes.filter(attr => attr.type === type);\n        } else if (name) {\n            return attributes.filter(attr => attr.name === name);\n        }\n    }\n\n    __getInheritableAttributes(path) {\n        const attrs = this.__getCachedAttributes(path);\n\n        return attrs.filter(attr => attr.isInheritable);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {Attribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getOwnedLabels(name) {\n        return this.getOwnedAttributes(LABEL, name);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {Attribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getLabels(name) {\n        return this.getAttributes(LABEL, name);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {Attribute[]} all note's label definitions, including inherited ones\n     */\n    getLabelDefinitions(name) {\n        return this.getAttributes(LABEL_DEFINITION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Attribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getOwnedRelations(name) {\n        return this.getOwnedAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Attribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getRelations(name) {\n        return this.getAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Attribute[]} all note's relation definitions including inherited ones\n     */\n    getRelationDefinitions(name) {\n        return this.getAttributes(RELATION_DEFINITION, name);\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasAttribute(type, name) {\n        return !!this.getAttribute(type, name);\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasOwnedAttribute(type, name) {\n        return !!this.getOwnedAttribute(type, name);\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {Attribute} attribute of given type and name. If there's more such attributes, first is  returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getOwnedAttribute(type, name) {\n        const attributes = this.getOwnedAttributes(type, name);\n\n        return attributes.length > 0 ? attributes[0] : 0;\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {Attribute} attribute of given type and name. If there's more such attributes, first is  returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getAttribute(type, name) {\n        const attributes = this.getAttributes(type, name);\n\n        return attributes.length > 0 ? attributes[0] : 0;\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of given type and name or null if no such attribute exists.\n     */\n    getOwnedAttributeValue(type, name) {\n        const attr = this.getOwnedAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of given type and name or null if no such attribute exists.\n     */\n    getAttributeValue(type, name) {\n        const attr = this.getAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (excluding inherited)\n     */\n    hasOwnedLabel(name) { return this.hasOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (including inherited)\n     */\n    hasLabel(name) { return this.hasAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (excluding inherited)\n     */\n    hasOwnedRelation(name) { return this.hasOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (including inherited)\n     */\n    hasRelation(name) { return this.hasAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {Attribute} label if it exists, null otherwise\n     */\n    getOwnedLabel(name) { return this.getOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {Attribute} label if it exists, null otherwise\n     */\n    getLabel(name) { return this.getAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {Attribute} relation if it exists, null otherwise\n     */\n    getOwnedRelation(name) { return this.getOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {Attribute} relation if it exists, null otherwise\n     */\n    getRelation(name) { return this.getAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getOwnedLabelValue(name) { return this.getOwnedAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getLabelValue(name) { return this.getAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getOwnedRelationValue(name) { return this.getOwnedAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getRelationValue(name) { return this.getAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name\n     * @returns {Promise<NoteShort>|null} target note of the relation or null (if target is empty or note was not found)\n     */\n    async getRelationTarget(name) {\n        const targets = await this.getRelationTargets(name);\n\n        return targets.length > 0 ? targets[0] : null;\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Promise<NoteShort[]>}\n     */\n    async getRelationTargets(name) {\n        const relations = this.getRelations(name);\n        const targets = [];\n\n        for (const relation of relations) {\n            targets.push(await this.treeCache.getNote(relation.value));\n        }\n\n        return targets;\n    }\n\n    /**\n     * @returns {NoteShort[]}\n     */\n    getTemplateNotes() {\n        const relations = this.getRelations('template');\n\n        return relations.map(rel => this.treeCache.notes[rel.value]);\n    }\n\n    hasAncestor(ancestorNote) {\n        if (this.noteId === ancestorNote.noteId) {\n            return true;\n        }\n\n        for (const templateNote of this.getTemplateNotes()) {\n            if (templateNote.hasAncestor(ancestorNote)) {\n                return true;\n            }\n        }\n\n        for (const parentNote of this.getParentNotes()) {\n            if (parentNote.hasAncestor(ancestorNote)) {console.log(parentNote);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Clear note's attributes cache to force fresh reload for next attribute request.\n     * Cache is note instance scoped.\n     */\n    invalidateAttributeCache() {\n        this.__attributeCache = null;\n    }\n\n    /**\n     * Get relations which target this note\n     *\n     * @returns {Attribute[]}\n     */\n    getTargetRelations() {\n        return this.targetRelations\n            .map(attributeId => this.treeCache.attributes[attributeId]);\n    }\n\n    /**\n     * Return note complement which is most importantly note's content\n     *\n     * @return {Promise<NoteComplement>}\n     */\n    async getNoteComplement() {\n        return await this.treeCache.getNoteComplement(this.noteId);\n    }\n\n    get toString() {\n        return `Note(noteId=${this.noteId}, title=${this.title})`;\n    }\n\n    get dto() {\n        const dto = Object.assign({}, this);\n        delete dto.treeCache;\n\n        return dto;\n    }\n\n    getCssClass() {\n        const labels = this.getLabels('cssClass');\n        return labels.map(l => l.value).join(' ');\n    }\n}\n\nexport default NoteShort;\n","/**\n * Complements the NoteShort with the main note content and other extra attributes\n */\nclass NoteComplement {\n    constructor(row) {\n        /** @param {string} */\n        this.noteId = row.noteId;\n\n        /** @param {string} */\n        this.content = row.content;\n\n        /** @param {string} */\n        this.dateCreated = row.dateCreated;\n\n        /** @param {string} */\n        this.dateModified = row.dateModified;\n\n        /** @param {string} */\n        this.utcDateCreated = row.utcDateCreated;\n\n        /** @param {string} */\n        this.utcDateModified = row.utcDateModified;\n    }\n}\n\nexport default NoteComplement;","import Branch from \"../entities/branch.js\";\nimport NoteShort from \"../entities/note_short.js\";\nimport Attribute from \"../entities/attribute.js\";\nimport server from \"./server.js\";\nimport NoteComplement from \"../entities/note_complement.js\";\n\n/**\n * TreeCache keeps a read only cache of note tree structure in frontend's memory.\n * - notes are loaded lazily when unknown noteId is requested\n * - when note is loaded, all its parent and child branches are loaded as well. For a branch to be used, it's not must be loaded before\n * - deleted notes are present in the cache as well, but they don't have any branches. As a result check for deleted branch is done by presence check - if the branch is not there even though the corresponding note has been loaded, we can infer it is deleted.\n *\n * Note and branch deletions are corner cases and usually not needed.\n */\nclass TreeCache {\n    constructor() {\n        this.initializedPromise = this.loadInitialTree();\n    }\n\n    async loadInitialTree() {\n        const resp = await server.get('tree');\n\n        await this.loadParents(resp, false);\n\n        // clear the cache only directly before adding new content which is important for e.g. switching to protected session\n\n        /** @type {Object.<string, NoteShort>} */\n        this.notes = {};\n\n        /** @type {Object.<string, Branch>} */\n        this.branches = {};\n\n        /** @type {Object.<string, Attribute>} */\n        this.attributes = {};\n\n        /** @type {Object.<string, Promise<NoteComplement>>} */\n        this.noteComplementPromises = {};\n\n        this.addResp(resp);\n    }\n\n    async loadParents(resp, additiveLoad) {\n        const noteIds = new Set(resp.notes.map(note => note.noteId));\n        const missingNoteIds = [];\n        const existingNotes = additiveLoad ? this.notes : {};\n\n        for (const branch of resp.branches) {\n            if (!(branch.parentNoteId in existingNotes) && !noteIds.has(branch.parentNoteId) && branch.parentNoteId !== 'none') {\n                missingNoteIds.push(branch.parentNoteId);\n            }\n        }\n\n        for (const attr of resp.attributes) {\n            if (attr.type === 'relation' && attr.name === 'template' && !(attr.value in existingNotes) && !noteIds.has(attr.value)) {\n                missingNoteIds.push(attr.value);\n            }\n\n            if (!(attr.noteId in existingNotes) && !noteIds.has(attr.noteId)) {\n                missingNoteIds.push(attr.noteId);\n            }\n        }\n\n        if (missingNoteIds.length > 0) {\n            const newResp = await server.post('tree/load', { noteIds: missingNoteIds });\n\n            resp.notes = resp.notes.concat(newResp.notes);\n            resp.branches = resp.branches.concat(newResp.branches);\n            resp.attributes = resp.attributes.concat(newResp.attributes);\n\n            await this.loadParents(resp, additiveLoad);\n        }\n    }\n\n    addResp(resp) {\n        const noteRows = resp.notes;\n        const branchRows = resp.branches;\n        const attributeRows = resp.attributes;\n\n        for (const noteRow of noteRows) {\n            const {noteId} = noteRow;\n\n            const oldNote = this.notes[noteId];\n\n            if (oldNote) {\n                for (const childNoteId of oldNote.children) {\n                    const childNote = this.notes[childNoteId];\n\n                    if (childNote) {\n                        childNote.parents = childNote.parents.filter(p => p !== noteId);\n\n                        delete this.branches[childNote.parentToBranch[noteId]];\n                        delete childNote.parentToBranch[noteId];\n                    }\n                }\n\n                for (const parentNoteId of oldNote.parents) {\n                    const parentNote = this.notes[parentNoteId];\n\n                    if (parentNote) {\n                        parentNote.children = parentNote.children.filter(p => p !== noteId);\n\n                        delete this.branches[parentNote.childToBranch[noteId]];\n                        delete parentNote.childToBranch[noteId];\n                    }\n                }\n            }\n\n            const note = new NoteShort(this, noteRow);\n\n            this.notes[note.noteId] = note;\n        }\n\n        for (const branchRow of branchRows) {\n            const branch = new Branch(this, branchRow);\n\n            this.branches[branch.branchId] = branch;\n\n            const childNote = this.notes[branch.noteId];\n\n            if (childNote) {\n                childNote.addParent(branch.parentNoteId, branch.branchId);\n            }\n\n            const parentNote = this.notes[branch.parentNoteId];\n\n            if (parentNote) {\n                parentNote.addChild(branch.noteId, branch.branchId);\n            }\n        }\n\n        for (const attributeRow of attributeRows) {\n            const {attributeId} = attributeRow;\n\n            this.attributes[attributeId] = new Attribute(this, attributeRow);\n\n            const note = this.notes[attributeRow.noteId];\n\n            if (!note.attributes.includes(attributeId)) {\n                note.attributes.push(attributeId);\n            }\n\n            if (attributeRow.type === 'relation') {\n                const targetNote = this.notes[attributeRow.value];\n\n                if (targetNote) {\n                    if (!targetNote.targetRelations.includes(attributeId)) {\n                        targetNote.targetRelations.push(attributeId);\n                    }\n                }\n            }\n        }\n    }\n\n    async reloadNotes(noteIds) {\n        if (noteIds.length === 0) {\n            return;\n        }\n\n        noteIds = Array.from(new Set(noteIds)); // make noteIds unique\n\n        const resp = await server.post('tree/load', { noteIds });\n\n        await this.loadParents(resp, true);\n        this.addResp(resp);\n\n        for (const note of resp.notes) {\n            if (note.type === 'search') {\n                const searchResults = await server.get('search-note/' + note.noteId);\n\n                if (!searchResults) {\n                    throw new Error(`Search note ${note.noteId} failed.`);\n                }\n\n                // force to load all the notes at once instead of one by one\n                await this.getNotes(searchResults.map(res => res.noteId));\n\n                const branches = resp.branches.filter(b => b.noteId === note.noteId || b.parentNoteId === note.noteId);\n\n                searchResults.forEach((result, index) => branches.push({\n                    // branchId should be repeatable since sometimes we reload some notes without rerendering the tree\n                    branchId: \"virt\" + result.noteId + '-' + note.noteId,\n                    noteId: result.noteId,\n                    parentNoteId: note.noteId,\n                    prefix: this.getBranch(result.branchId).prefix,\n                    notePosition: (index + 1) * 10\n                }));\n\n                // update this note with standard (parent) branches + virtual (children) branches\n                this.addResp({\n                    notes: [note],\n                    branches,\n                    attributes: []\n                });\n            }\n        }\n    }\n\n    /** @return {NoteShort[]} */\n    getNotesFromCache(noteIds, silentNotFoundError = false) {\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.log(`Can't find note \"${noteId}\"`);\n\n                return null;\n            }\n            else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @return {Promise<NoteShort[]>} */\n    async getNotes(noteIds, silentNotFoundError = false) {\n        const missingNoteIds = noteIds.filter(noteId => !this.notes[noteId]);\n\n        await this.reloadNotes(missingNoteIds);\n\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.log(`Can't find note \"${noteId}\"`);\n\n                return null;\n            }\n            else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @return {Promise<boolean>} */\n    async noteExists(noteId) {\n        const notes = await this.getNotes([noteId], true);\n\n        return notes.length === 1;\n    }\n\n    /** @return {Promise<NoteShort>} */\n    async getNote(noteId, silentNotFoundError = false) {\n        if (noteId === 'none') {\n            console.trace(`No 'none' note.`);\n            return null;\n        }\n        else if (!noteId) {\n            console.log(`Falsy noteId ${noteId}, returning null.`);\n            return null;\n        }\n\n        return (await this.getNotes([noteId], silentNotFoundError))[0];\n    }\n\n    getNoteFromCache(noteId) {\n        return this.notes[noteId];\n    }\n\n    getBranches(branchIds, silentNotFoundError = false) {\n        return branchIds\n            .map(branchId => this.getBranch(branchId, silentNotFoundError))\n            .filter(b => !!b);\n    }\n\n    /** @return {Branch} */\n    getBranch(branchId, silentNotFoundError = false) {\n        if (!(branchId in this.branches)) {\n            if (!silentNotFoundError) {\n                console.error(`Not existing branch ${branchId}`);\n            }\n        }\n        else {\n            return this.branches[branchId];\n        }\n    }\n\n    async getBranchId(parentNoteId, childNoteId) {\n        const child = await this.getNote(childNoteId);\n\n        if (!child) {\n            console.error(`Could not find branchId for parent=${parentNoteId}, child=${childNoteId} since child does not exist`);\n\n            return null;\n        }\n\n        return child.parentToBranch[parentNoteId];\n    }\n\n    /**\n     * @return {Promise<NoteComplement>}\n     */\n    async getNoteComplement(noteId) {\n        if (!this.noteComplementPromises[noteId]) {\n            this.noteComplementPromises[noteId] = server.get('notes/' + noteId).then(row => new NoteComplement(row));\n        }\n\n        return await this.noteComplementPromises[noteId];\n    }\n}\n\nconst treeCache = new TreeCache();\n\nexport default treeCache;\n","function reloadApp() {\n    window.location.reload(true);\n}\n\nfunction parseDate(str) {\n    try {\n        return new Date(Date.parse(str));\n    }\n    catch (e) {\n        throw new Error(\"Can't parse date from \" + str + \": \" + e.stack);\n    }\n}\n\nfunction padNum(num) {\n    return (num <= 9 ? \"0\" : \"\") + num;\n}\n\nfunction formatTime(date) {\n    return padNum(date.getHours()) + \":\" + padNum(date.getMinutes());\n}\n\nfunction formatTimeWithSeconds(date) {\n    return padNum(date.getHours()) + \":\" + padNum(date.getMinutes()) + \":\" + padNum(date.getSeconds());\n}\n\n// this is producing local time!\nfunction formatDate(date) {\n//    return padNum(date.getDate()) + \". \" + padNum(date.getMonth() + 1) + \". \" + date.getFullYear();\n    // instead of european format we'll just use ISO as that's pretty unambiguous\n\n    return formatDateISO(date);\n}\n\n// this is producing local time!\nfunction formatDateISO(date) {\n    return date.getFullYear() + \"-\" + padNum(date.getMonth() + 1) + \"-\" + padNum(date.getDate());\n}\n\nfunction formatDateTime(date) {\n    return formatDate(date) + \" \" + formatTime(date);\n}\n\nfunction localNowDateTime() {\n    return dayjs().format('YYYY-MM-DD HH:mm:ss.SSSZZ')\n}\n\nfunction now() {\n    return formatTimeWithSeconds(new Date());\n}\n\nfunction isElectron() {\n    return !!(window && window.process && window.process.type);\n}\n\nfunction isMac() {\n    return navigator.platform.indexOf('Mac') > -1;\n}\n\nfunction assertArguments() {\n    for (const i in arguments) {\n        if (!arguments[i]) {\n            console.trace(`Argument idx#${i} should not be falsy: ${arguments[i]}`);\n        }\n    }\n}\n\nconst entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n};\n\nfunction escapeHtml(str) {\n    return str.replace(/[&<>\"'`=\\/]/g, s => entityMap[s]);\n}\n\nasync function stopWatch(what, func) {\n    const start = new Date();\n\n    const ret = await func();\n\n    const tookMs = Date.now() - start.getTime();\n\n    console.log(`${what} took ${tookMs}ms`);\n\n    return ret;\n}\n\nfunction formatValueWithWhitespace(val) {\n    return /[^\\w_-]/.test(val) ? '\"' + val + '\"' : val;\n}\n\nfunction formatLabel(label) {\n    let str = \"@\" + formatValueWithWhitespace(label.name);\n\n    if (label.value !== \"\") {\n        str += \"=\" + formatValueWithWhitespace(label.value);\n    }\n\n    return str;\n}\n\nfunction getHost() {\n    const url = new URL(window.location.href);\n    return url.protocol + \"//\" + url.hostname + \":\" + url.port;\n}\n\nfunction download(url) {\n    url += '?' + Date.now(); // don't use cache\n\n    if (isElectron()) {\n        const remote = dynamicRequire('electron').remote;\n\n        remote.getCurrentWebContents().downloadURL(url);\n    }\n    else {\n        window.location.href = url;\n    }\n}\n\nfunction toObject(array, fn) {\n    const obj = {};\n\n    for (const item of array) {\n        const [key, value] = fn(item);\n\n        obj[key] = value;\n    }\n\n    return obj;\n}\n\nfunction randomString(len) {\n    let text = \"\";\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    for (let i = 0; i < len; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n\n    return text;\n}\n\nfunction bindGlobalShortcut(keyboardShortcut, handler) {\n    bindElShortcut($(document), keyboardShortcut, handler);\n}\n\nfunction bindElShortcut($el, keyboardShortcut, handler) {\n    if (isDesktop()) {\n        keyboardShortcut = normalizeShortcut(keyboardShortcut);\n\n        $el.bind('keydown', keyboardShortcut, e => {\n            handler(e);\n\n            e.preventDefault();\n            e.stopPropagation();\n        });\n    }\n}\n\n/**\n * Normalize to the form expected by the jquery.hotkeys.js\n */\nfunction normalizeShortcut(shortcut) {\n    return shortcut\n        .toLowerCase()\n        .replace(\"enter\", \"return\")\n        .replace(\"delete\", \"del\")\n        .replace(\"ctrl+alt\", \"alt+ctrl\")\n        .replace(\"meta+alt\", \"alt+meta\"); // alt needs to be first;\n}\n\nfunction isMobile() {\n    return window.device === \"mobile\"\n        // window.device is not available in setup\n        || (!window.device && /Mobi/.test(navigator.userAgent));\n}\n\nfunction isDesktop() {\n    return window.device === \"desktop\"\n        // window.device is not available in setup\n        || (!window.device && !/Mobi/.test(navigator.userAgent));\n}\n\n// cookie code below works for simple use cases only - ASCII only\n// not setting path so that cookies do not leak into other websites if multiplexed with reverse proxy\n\nfunction setCookie(name, value) {\n    const date = new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000);\n    const expires = \"; expires=\" + date.toUTCString();\n\n    document.cookie = name + \"=\" + (value || \"\")  + expires + \";\";\n}\n\nfunction setSessionCookie(name, value) {\n    document.cookie = name + \"=\" + (value || \"\") + \";\";\n}\n\nfunction getCookie(name) {\n    const valueMatch = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');\n    return valueMatch ? valueMatch[2] : null;\n}\n\nfunction getNoteTypeClass(type) {\n    return \"type-\" + type;\n}\n\nfunction getMimeTypeClass(mime) {\n    const semicolonIdx = mime.indexOf(';');\n\n    if (semicolonIdx !== -1) {\n        // stripping everything following the semicolon\n        mime = mime.substr(0, semicolonIdx);\n    }\n\n    return 'mime-' + mime.toLowerCase().replace(/[\\W_]+/g,\"-\");\n}\n\nfunction closeActiveDialog() {\n    if (glob.activeDialog) {\n        glob.activeDialog.modal('hide');\n        glob.activeDialog = null;\n    }\n}\n\nlet $lastFocusedElement = null;\n\nfunction saveFocusedElement() {\n    $lastFocusedElement = $(\":focus\");\n}\n\nfunction focusSavedElement() {\n    if (!$lastFocusedElement) {\n        return;\n    }\n\n    if ($lastFocusedElement.hasClass(\"ck\")) {\n        // must handle CKEditor separately because of this bug: https://github.com/ckeditor/ckeditor5/issues/607\n\n        const editor = $lastFocusedElement\n            .closest('.ck-editor__editable')\n            .prop('ckeditorInstance');\n\n        editor.editing.view.focus();\n    } else {\n        $lastFocusedElement.focus();\n    }\n\n    $lastFocusedElement = null;\n}\n\nasync function openDialog($dialog) {\n    closeActiveDialog();\n\n    glob.activeDialog = $dialog;\n\n    saveFocusedElement();\n\n    $dialog.modal();\n\n    $dialog.on('hidden.bs.modal', () => {\n        if (!glob.activeDialog || glob.activeDialog === $dialog) {\n            focusSavedElement();\n        }\n    });\n\n    const keyboardActionsService = (await import(\"./keyboard_actions.js\")).default;\n    keyboardActionsService.updateDisplayedShortcuts($dialog);\n}\n\nfunction isHtmlEmpty(html) {\n    if (!html) {\n        return true;\n    }\n\n    html = html.toLowerCase();\n\n    return !html.includes('<img')\n        && !html.includes('<section')\n        // line below will actually attempt to load images so better to check for images first\n        && $(\"<div>\").html(html).text().trim().length === 0;\n}\n\nasync function clearBrowserCache() {\n    if (isElectron()) {\n        const win = dynamicRequire('electron').remote.getCurrentWindow();\n        await win.webContents.session.clearCache();\n    }\n}\n\n/**\n * @param url - should be without initial slash!!!\n */\nfunction getUrlForDownload(url) {\n    if (isElectron()) {\n        // electron needs absolute URL so we extract current host, port, protocol\n        return getHost() + '/' + url;\n    }\n    else {\n        // web server can be deployed on subdomain so we need to use relative path\n        return url;\n    }\n}\n\nfunction copySelectionToClipboard() {\n    const text = window.getSelection().toString();\n    if (navigator.clipboard) {\n        navigator.clipboard.writeText(text);\n    }\n}\n\nfunction isCKEditorInitialized() {\n    return !!(window && window.cutToNote);\n}\n\nfunction dynamicRequire(moduleName) {\n    if (typeof __non_webpack_require__ !== 'undefined') {\n        return __non_webpack_require__(moduleName);\n    }\n    else {\n        return require(moduleName);\n    }\n}\n\nfunction timeLimit(promise, limitMs) {\n    // better stack trace if created outside of promise\n    const error = new Error('Process exceeded time limit ' + limitMs);\n\n    return new Promise((res, rej) => {\n        let resolved = false;\n\n        promise.then(result => {\n            resolved = true;\n\n            res(result);\n        });\n\n        setTimeout(() => {\n            if (!resolved) {\n                rej(error);\n            }\n        }, limitMs);\n    });\n}\n\nexport default {\n    reloadApp,\n    parseDate,\n    padNum,\n    formatTime,\n    formatTimeWithSeconds,\n    formatDate,\n    formatDateISO,\n    formatDateTime,\n    localNowDateTime,\n    now,\n    isElectron,\n    isMac,\n    assertArguments,\n    escapeHtml,\n    stopWatch,\n    formatLabel,\n    download,\n    toObject,\n    randomString,\n    bindGlobalShortcut,\n    bindElShortcut,\n    isMobile,\n    isDesktop,\n    setCookie,\n    setSessionCookie,\n    getCookie,\n    getNoteTypeClass,\n    getMimeTypeClass,\n    closeActiveDialog,\n    openDialog,\n    saveFocusedElement,\n    focusSavedElement,\n    isHtmlEmpty,\n    clearBrowserCache,\n    getUrlForDownload,\n    normalizeShortcut,\n    copySelectionToClipboard,\n    isCKEditorInitialized,\n    dynamicRequire,\n    timeLimit\n};\n","export default class LoadResults {\n    constructor(treeCache) {\n        this.treeCache = treeCache;\n\n        this.noteIdToSourceId = {};\n        this.sourceIdToNoteIds = {};\n\n        this.branches = [];\n\n        this.attributes = [];\n\n        this.noteReorderings = [];\n\n        this.noteRevisions = [];\n\n        this.contentNoteIdToSourceId = [];\n\n        this.options = [];\n    }\n\n    addNote(noteId, sourceId) {\n        this.noteIdToSourceId[noteId] = this.noteIdToSourceId[noteId] || [];\n\n        if (!this.noteIdToSourceId[noteId].includes(sourceId)) {\n            this.noteIdToSourceId[noteId].push(sourceId);\n        }\n\n        this.sourceIdToNoteIds[sourceId] = this.sourceIdToNoteIds[sourceId] || [];\n\n        if (!this.sourceIdToNoteIds[sourceId]) {\n            this.sourceIdToNoteIds[sourceId].push(noteId);\n        }\n    }\n\n    addBranch(branchId, sourceId) {\n        this.branches.push({branchId, sourceId});\n    }\n\n    getBranches() {\n        return this.branches\n            .map(row => this.treeCache.branches[row.branchId])\n            .filter(branch => !!branch);\n    }\n\n    addNoteReordering(parentNoteId, sourceId) {\n        this.noteReorderings.push(parentNoteId);\n    }\n\n    getNoteReorderings() {\n        return this.noteReorderings;\n    }\n\n    addAttribute(attributeId, sourceId) {\n        this.attributes.push({attributeId, sourceId});\n    }\n\n    getAttributes(sourceId = 'none') {\n        return this.attributes\n            .filter(row => row.sourceId !== sourceId)\n            .map(row => this.treeCache.attributes[row.attributeId])\n            .filter(attr => !!attr);\n    }\n\n    addNoteRevision(noteRevisionId, noteId, sourceId) {\n        this.noteRevisions.push({noteRevisionId, noteId, sourceId});\n    }\n\n    hasNoteRevisionForNote(noteId) {\n        return !!this.noteRevisions.find(nr => nr.noteId === noteId);\n    }\n\n    getNoteIds() {\n        return Object.keys(this.noteIdToSourceId);\n    }\n\n    isNoteReloaded(noteId, sourceId = null) {\n        if (!noteId) {\n            return false;\n        }\n\n        const sourceIds = this.noteIdToSourceId[noteId];\n        return sourceIds && !!sourceIds.find(sId => sId !== sourceId);\n    }\n\n    addNoteContent(noteId, sourceId) {\n        this.contentNoteIdToSourceId.push({noteId, sourceId});\n    }\n\n    isNoteContentReloaded(noteId, sourceId) {\n        if (!noteId) {\n            return false;\n        }\n\n        return this.contentNoteIdToSourceId.find(l => l.noteId === noteId && l.sourceId !== sourceId);\n    }\n\n    addOption(name) {\n        this.options.push(name);\n    }\n\n    isOptionReloaded(name) {\n        this.options.includes(name);\n    }\n\n    /**\n     * @return {boolean} true if there are changes which could affect the attributes (including inherited ones)\n     *          notably changes in note itself should not have any effect on attributes\n     */\n    hasAttributeRelatedChanges() {\n        return this.branches.length === 0\n            && this.attributes.length === 0;\n    }\n\n    isEmpty() {\n        return Object.keys(this.noteIdToSourceId).length === 0\n            && this.branches.length === 0\n            && this.attributes.length === 0\n            && this.noteReorderings.length === 0\n            && this.noteRevisions.length === 0\n            && this.contentNoteIdToSourceId.length === 0\n            && this.options.length === 0;\n    }\n}\n","import utils from './utils.js';\nimport toastService from \"./toast.js\";\nimport server from \"./server.js\";\nimport LoadResults from \"./load_results.js\";\nimport Branch from \"../entities/branch.js\";\nimport Attribute from \"../entities/attribute.js\";\nimport options from \"./options.js\";\nimport treeCache from \"./tree_cache.js\";\nimport noteAttributeCache from \"./note_attribute_cache.js\";\n\nconst $outstandingSyncsCount = $(\"#outstanding-syncs-count\");\n\nconst messageHandlers = [];\n\nlet ws;\nlet lastAcceptedSyncId = window.glob.maxSyncIdAtLoad;\nlet lastProcessedSyncId = window.glob.maxSyncIdAtLoad;\nlet lastPingTs;\nlet syncDataQueue = [];\n\nfunction logError(message) {\n    console.log(utils.now(), message); // needs to be separate from .trace()\n    console.trace();\n\n    if (ws && ws.readyState === 1) {\n        ws.send(JSON.stringify({\n            type: 'log-error',\n            error: message,\n            stack: new Error().stack\n        }));\n    }\n}\n\nfunction subscribeToMessages(messageHandler) {\n    messageHandlers.push(messageHandler);\n}\n\n// used to serialize sync operations\nlet consumeQueuePromise = null;\n\n// most sync events are sent twice - once immediatelly after finishing the transaction and once during the scheduled ping\n// but we want to process only once\nconst processedSyncIds = new Set();\n\nfunction logRows(syncRows) {\n    const filteredRows = syncRows.filter(row =>\n        !processedSyncIds.has(row.id)\n        && row.entityName !== 'recent_notes'\n        && (row.entityName !== 'options' || row.entityId !== 'openTabs'));\n\n    if (filteredRows.length > 0) {\n        console.debug(utils.now(), \"Sync data: \", filteredRows);\n    }\n}\n\nasync function handleMessage(event) {\n    const message = JSON.parse(event.data);\n\n    for (const messageHandler of messageHandlers) {\n        messageHandler(message);\n    }\n\n    if (message.type === 'sync') {\n        let syncRows = message.data;\n        lastPingTs = Date.now();\n\n        $outstandingSyncsCount.html(message.outstandingSyncs);\n\n        if (syncRows.length > 0) {\n            logRows(syncRows);\n\n            syncDataQueue.push(...syncRows);\n\n            // we set lastAcceptedSyncId even before sync processing and send ping so that backend can start sending more updates\n            lastAcceptedSyncId = Math.max(lastAcceptedSyncId, syncRows[syncRows.length - 1].id);\n            sendPing();\n\n            // first wait for all the preceding consumers to finish\n            while (consumeQueuePromise) {\n                await consumeQueuePromise;\n            }\n\n            try {\n                // it's my turn so start it up\n                consumeQueuePromise = consumeSyncData();\n\n                await consumeQueuePromise;\n            }\n            finally {\n                // finish and set to null to signal somebody else can pick it up\n                consumeQueuePromise = null;\n            }\n        }\n    }\n    else if (message.type === 'sync-hash-check-failed') {\n        toastService.showError(\"Sync check failed!\", 60000);\n    }\n    else if (message.type === 'consistency-checks-failed') {\n        toastService.showError(\"Consistency checks failed! See logs for details.\", 50 * 60000);\n    }\n}\n\nlet syncIdReachedListeners = [];\n\nfunction waitForSyncId(desiredSyncId) {\n    if (desiredSyncId <= lastProcessedSyncId) {\n        return Promise.resolve();\n    }\n\n    console.debug(\"Waiting for\", desiredSyncId, 'current is', lastProcessedSyncId);\n\n    return new Promise((res, rej) => {\n        syncIdReachedListeners.push({\n            desiredSyncId,\n            resolvePromise: res,\n            start: Date.now()\n        })\n    });\n}\n\nfunction waitForMaxKnownSyncId() {\n    return waitForSyncId(server.getMaxKnownSyncId());\n}\n\nfunction checkSyncIdListeners() {\n    syncIdReachedListeners\n        .filter(l => l.desiredSyncId <= lastProcessedSyncId)\n        .forEach(l => l.resolvePromise());\n\n    syncIdReachedListeners = syncIdReachedListeners\n        .filter(l => l.desiredSyncId > lastProcessedSyncId);\n\n    syncIdReachedListeners.filter(l => Date.now() > l.start - 60000)\n        .forEach(l => console.log(`Waiting for syncId ${l.desiredSyncId} while current is ${lastProcessedSyncId} for ${Math.floor((Date.now() - l.start) / 1000)}s`));\n}\n\nasync function runSafely(syncHandler, syncData) {\n    try {\n        return await syncHandler(syncData);\n    }\n    catch (e) {\n        console.log(`Sync handler failed with ${e.message}: ${e.stack}`);\n    }\n}\n\n/**\n * TODO: we should rethink the fact that each sync row is sent twice (once at the end of transaction, once periodically)\n *       and we keep both lastProcessedSyncId and processedSyncIds\n *       it even seems incorrect that when transaction sync rows are received, we incorrectly increase lastProcessedSyncId\n *       and then some syncs might lost (or are *all* sync rows sent from transactions?)\n */\nasync function consumeSyncData() {\n    if (syncDataQueue.length > 0) {\n        const allSyncRows = syncDataQueue;\n        syncDataQueue = [];\n\n        const nonProcessedSyncRows = allSyncRows.filter(sync => !processedSyncIds.has(sync.id));\n\n        try {\n            await utils.timeLimit(processSyncRows(nonProcessedSyncRows), 5000);\n        }\n        catch (e) {\n            logError(`Encountered error ${e.message}: ${e.stack}, reloading frontend.`);\n\n            // if there's an error in updating the frontend then the easy option to recover is to reload the frontend completely\n            utils.reloadApp();\n        }\n\n        for (const syncRow of nonProcessedSyncRows) {\n            processedSyncIds.add(syncRow.id);\n        }\n\n        lastProcessedSyncId = Math.max(lastProcessedSyncId, allSyncRows[allSyncRows.length - 1].id);\n    }\n\n    checkSyncIdListeners();\n}\n\nfunction connectWebSocket() {\n    const loc = window.location;\n    const webSocketUri = (loc.protocol === \"https:\" ? \"wss:\" : \"ws:\")\n                       + \"//\" + loc.host + loc.pathname;\n\n    // use wss for secure messaging\n    const ws = new WebSocket(webSocketUri);\n    ws.onopen = () => console.debug(utils.now(), `Connected to server ${webSocketUri} with WebSocket`);\n    ws.onmessage = handleMessage;\n    // we're not handling ws.onclose here because reconnection is done in sendPing()\n\n    return ws;\n}\n\nasync function sendPing() {\n    if (Date.now() - lastPingTs > 30000) {\n        console.log(utils.now(), \"Lost websocket connection to the backend. If you keep having this issue repeatedly, you might want to check your reverse proxy (nginx, apache) configuration and allow/unblock WebSocket.\");\n    }\n\n    if (ws.readyState === ws.OPEN) {\n        ws.send(JSON.stringify({\n            type: 'ping',\n            lastSyncId: lastAcceptedSyncId\n        }));\n    }\n    else if (ws.readyState === ws.CLOSED || ws.readyState === ws.CLOSING) {\n        console.log(utils.now(), \"WS closed or closing, trying to reconnect\");\n\n        ws = connectWebSocket();\n    }\n}\n\nsetTimeout(() => {\n    ws = connectWebSocket();\n\n    lastPingTs = Date.now();\n\n    setInterval(sendPing, 1000);\n}, 0);\n\nsubscribeToMessages(message => {\n    if (message.type === 'sync-pull-in-progress') {\n        toastService.showPersistent({\n            id: 'sync',\n            title: \"Sync status\",\n            message: \"Sync update in progress\",\n            icon: \"refresh\"\n        });\n    }\n    else if (message.type === 'sync-pull-finished') {\n        // this gives user a chance to see the toast in case of fast sync finish\n        setTimeout(() => toastService.closePersistent('sync'), 1000);\n    }\n});\n\nasync function processSyncRows(syncRows) {\n    const missingNoteIds = [];\n\n    for (const {entityName, entity} of syncRows) {\n        if (entityName === 'branches' && !(entity.parentNoteId in treeCache.notes)) {\n            missingNoteIds.push(entity.parentNoteId);\n        }\n        else if (entityName === 'attributes'\n              && entity.type === 'relation'\n              && entity.name === 'template'\n              && !(entity.noteId in treeCache.notes)) {\n\n            missingNoteIds.push(entity.value);\n        }\n    }\n\n    if (missingNoteIds.length > 0) {\n        await treeCache.reloadNotes(missingNoteIds);\n    }\n\n    const loadResults = new LoadResults(treeCache);\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'notes')) {\n        const note = treeCache.notes[sync.entityId];\n\n        if (note) {\n            note.update(sync.entity);\n            loadResults.addNote(sync.entityId, sync.sourceId);\n        }\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'branches')) {\n        let branch = treeCache.branches[sync.entityId];\n        const childNote = treeCache.notes[sync.entity.noteId];\n        const parentNote = treeCache.notes[sync.entity.parentNoteId];\n\n        if (branch) {\n            branch.update(sync.entity);\n            loadResults.addBranch(sync.entityId, sync.sourceId);\n\n            if (sync.entity.isDeleted) {\n                if (childNote) {\n                    childNote.parents = childNote.parents.filter(parentNoteId => parentNoteId !== sync.entity.parentNoteId);\n                    delete childNote.parentToBranch[sync.entity.parentNoteId];\n                }\n\n                if (parentNote) {\n                    parentNote.children = parentNote.children.filter(childNoteId => childNoteId !== sync.entity.noteId);\n                    delete parentNote.childToBranch[sync.entity.noteId];\n                }\n            }\n            else {\n                if (childNote) {\n                    childNote.addParent(branch.parentNoteId, branch.branchId);\n                }\n\n                if (parentNote) {\n                    parentNote.addChild(branch.noteId, branch.branchId);\n                }\n            }\n        }\n        else if (!sync.entity.isDeleted) {\n            if (childNote || parentNote) {\n                branch = new Branch(treeCache, sync.entity);\n                treeCache.branches[branch.branchId] = branch;\n\n                loadResults.addBranch(sync.entityId, sync.sourceId);\n\n                if (childNote) {\n                    childNote.addParent(branch.parentNoteId, branch.branchId);\n                }\n\n                if (parentNote) {\n                    parentNote.addChild(branch.noteId, branch.branchId);\n                }\n            }\n        }\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'note_reordering')) {\n        for (const branchId in sync.positions) {\n            const branch = treeCache.branches[branchId];\n\n            if (branch) {\n                branch.notePosition = sync.positions[branchId];\n            }\n        }\n\n        loadResults.addNoteReordering(sync.entityId, sync.sourceId);\n    }\n\n    // missing reloading the relation target note\n    for (const sync of syncRows.filter(sync => sync.entityName === 'attributes')) {\n        let attribute = treeCache.attributes[sync.entityId];\n        const sourceNote = treeCache.notes[sync.entity.noteId];\n        const targetNote = sync.entity.type === 'relation' && treeCache.notes[sync.entity.value];\n\n        if (attribute) {\n            attribute.update(sync.entity);\n            loadResults.addAttribute(sync.entityId, sync.sourceId);\n\n            if (sync.entity.isDeleted) {\n                if (sourceNote) {\n                    sourceNote.attributes = sourceNote.attributes.filter(attributeId => attributeId !== attribute.attributeId);\n                }\n\n                if (targetNote) {\n                    targetNote.targetRelations = targetNote.targetRelations.filter(attributeId => attributeId !== attribute.attributeId);\n                }\n            }\n        }\n        else if (!sync.entity.isDeleted) {\n            if (sourceNote || targetNote) {\n                attribute = new Attribute(treeCache, sync.entity);\n\n                treeCache.attributes[attribute.attributeId] = attribute;\n\n                loadResults.addAttribute(sync.entityId, sync.sourceId);\n\n                if (sourceNote && !sourceNote.attributes.includes(attribute.attributeId)) {\n                    sourceNote.attributes.push(attribute.attributeId);\n                }\n\n                if (targetNote && !targetNote.targetRelations.includes(attribute.attributeId)) {\n                    targetNote.targetRelations.push(attribute.attributeId);\n                }\n            }\n        }\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'note_contents')) {\n        delete treeCache.noteComplementPromises[sync.entityId];\n\n        loadResults.addNoteContent(sync.entityId, sync.sourceId);\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'note_revisions')) {\n        loadResults.addNoteRevision(sync.entityId, sync.noteId, sync.sourceId);\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'options')) {\n        if (sync.entity.name === 'openTabs') {\n            continue; // only noise\n        }\n\n        options.set(sync.entity.name, sync.entity.value);\n\n        loadResults.addOption(sync.entity.name);\n    }\n\n    if (!loadResults.isEmpty()) {\n        if (loadResults.hasAttributeRelatedChanges()) {\n            noteAttributeCache.invalidate();\n        }\n\n        const appContext = (await import(\"./app_context.js\")).default;\n        await appContext.triggerEvent('entitiesReloaded', {loadResults});\n    }\n}\n\nexport default {\n    logError,\n    subscribeToMessages,\n    waitForSyncId,\n    waitForMaxKnownSyncId\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => [];\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 3676;\nmodule.exports = webpackEmptyContext;","import Component from \"./component.js\";\n\nclass BasicWidget extends Component {\n    constructor() {\n        super();\n\n        this.attrs = {\n            style: ''\n        };\n        this.classes = [];\n    }\n\n    id(id) {\n        this.attrs.id = id;\n        return this;\n    }\n\n    class(className) {\n        this.classes.push(className);\n        return this;\n    }\n\n    css(name, value) {\n        this.attrs.style += `${name}: ${value};`;\n        return this;\n    }\n\n    collapsible() {\n        this.css('min-height', '0');\n        return this;\n    }\n\n    filling() {\n        this.css('flex-grow', '1');\n        return this;\n    }\n\n    hideInZenMode() {\n        this.class('hide-in-zen-mode');\n        return this;\n    }\n\n    cssBlock(block) {\n        this.cssEl = block;\n        return this;\n    }\n\n    render() {\n        const $widget = this.doRender();\n\n        $widget.addClass('component')\n            .prop('component', this);\n\n        this.toggleInt(this.isEnabled());\n\n        if (this.cssEl) {\n            const css = this.cssEl.trim().startsWith('<style>') ? this.cssEl : `<style>${this.cssEl}</style>`;\n\n            $widget.append(css);\n        }\n\n        for (const key in this.attrs) {\n            if (key === 'style') {\n                if (this.attrs[key]) {\n                    let style = $widget.attr('style');\n                    style = style ? `${style}; ${this.attrs[key]}` : this.attrs[key];\n\n                    $widget.attr(key, style);\n                }\n            }\n            else {\n                $widget.attr(key, this.attrs[key]);\n            }\n        }\n\n        for (const className of this.classes) {\n            $widget.addClass(className);\n        }\n\n        return $widget;\n    }\n\n    isEnabled() {\n        return true;\n    }\n\n    /**\n     * for overriding\n     */\n    doRender() {}\n\n    toggleInt(show) {\n        this.$widget.toggleClass('hidden-int', !show);\n    }\n\n    toggleExt(show) {\n        this.$widget.toggleClass('hidden-ext', !show);\n    }\n\n    isVisible() {\n        return this.$widget.is(\":visible\");\n    }\n\n    getPosition() {\n        return this.position;\n    }\n\n    remove() {\n        if (this.$widget) {\n            this.$widget.remove();\n        }\n    }\n\n    cleanup() {}\n}\n\nexport default BasicWidget;\n","import utils from '../services/utils.js';\n\n/**\n * Abstract class for all components in the Trilium's frontend.\n *\n * Contains also event implementation with following properties:\n * - event / command distribution is synchronous which among others mean that events are well ordered - event\n *   which was sent out first will also be processed first by the component\n * - execution of the event / command is asynchronous - each component executes the event on its own without regard for\n *   other components.\n * - although the execution is async, we are collecting all the promises and therefore it is possible to wait until the\n *   event / command is executed in all components - by simply awaiting the `triggerEvent()`.\n */\nexport default class Component {\n    constructor() {\n        this.componentId = `comp-` + utils.randomString(8);\n        /** @type Component[] */\n        this.children = [];\n        this.initialized = Promise.resolve();\n    }\n\n    setParent(parent) {\n        /** @type Component */\n        this.parent = parent;\n        return this;\n    }\n\n    child(...components) {\n        for (const component of components) {\n            component.setParent(this);\n\n            this.children.push(component);\n        }\n\n        return this;\n    }\n\n    /** @return {Promise} */\n    handleEvent(name, data) {\n        return Promise.all([\n            this.initialized.then(() => this.callMethod(this[name + 'Event'], data)),\n            this.handleEventInChildren(name, data)\n        ]);\n    }\n\n    /** @return {Promise} */\n    triggerEvent(name, data) {\n        return this.parent.triggerEvent(name, data);\n    }\n\n    /** @return {Promise} */\n    handleEventInChildren(name, data) {\n        const promises = [];\n\n        for (const child of this.children) {\n            promises.push(child.handleEvent(name, data));\n        }\n\n        return Promise.all(promises);\n    }\n\n    /** @return {Promise} */\n    triggerCommand(name, data = {}) {\n        const fun = this[name + 'Command'];\n\n        if (fun) {\n            return this.callMethod(fun, data);\n        }\n        else {\n            return this.parent.triggerCommand(name, data);\n        }\n    }\n\n    async callMethod(fun, data) {\n        if (typeof fun !== 'function') {\n            return false;\n        }\n\n        await fun.call(this, data);\n\n        return true;\n    }\n}\n","import BasicWidget from \"./basic_widget.js\";\nimport appContext from \"../services/app_context.js\";\n\nexport default class TabAwareWidget extends BasicWidget {\n    isTab(tabId) {\n        return this.tabContext && this.tabContext.tabId === tabId;\n    }\n\n    isNote(noteId) {\n        return this.noteId === noteId;\n    }\n\n    get note() {\n        return this.tabContext && this.tabContext.note;\n    }\n\n    get noteId() {\n        return this.note && this.note.noteId;\n    }\n\n    get notePath() {\n        return this.tabContext && this.tabContext.notePath;\n    }\n\n    isEnabled() {\n        return !!this.note;\n    }\n\n    async refresh() {\n        if (this.isEnabled()) {\n            const start = Date.now();\n\n            this.toggleInt(true);\n            await this.refreshWithNote(this.note, this.notePath);\n\n            const end = Date.now();\n\n            if (glob.PROFILING_LOG && end - start > 10) {\n                console.log(`Refresh of ${this.componentId} took ${end-start}ms`);\n            }\n        }\n        else {\n            this.toggleInt(false);\n        }\n    }\n\n    async refreshWithNote(note, notePath) {}\n\n    async tabNoteSwitchedEvent({tabContext, notePath}) {\n        // if notePath does not match then the tabContext has been switched to another note in the mean time\n        if (tabContext.notePath === notePath) {\n            await this.noteSwitched();\n        }\n    }\n\n    async noteSwitched() {\n        await this.refresh();\n    }\n\n    async activeTabChangedEvent({tabContext}) {\n        this.tabContext = tabContext;\n\n        await this.activeTabChanged();\n    }\n\n    async activeTabChanged() {\n        await this.refresh();\n    }\n\n    // when note is both switched and activated, this should not produce double refresh\n    async tabNoteSwitchedAndActivatedEvent({tabContext, notePath}) {\n        this.tabContext = tabContext;\n\n        // if notePath does not match then the tabContext has been switched to another note in the mean time\n        if (this.notePath === notePath) {\n            await this.refresh();\n        }\n    }\n\n    setTabContextEvent({tabContext}) {\n        /** @var {TabContext} */\n        this.tabContext = tabContext;\n    }\n\n    async noteTypeMimeChangedEvent({noteId}) {\n        if (this.isNote(noteId)) {\n            await this.refresh();\n        }\n    }\n\n    async treeCacheReloadedEvent() {\n        await this.refresh();\n    }\n\n    async lazyLoadedEvent() {\n        if (!this.tabContext) { // has not been loaded yet\n            this.tabContext = appContext.tabManager.getActiveTabContext();\n        }\n\n        await this.refresh();\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".mobile.js\";\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"app-dist/\";","// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// Promise = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t8: 0\n};\n\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n\t\t\t\t\t});\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\tvar loadingEnded = () => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) return installedChunkData[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tvar script = document.createElement('script');\n\t\t\t\t\tvar onScriptComplete;\n\n\t\t\t\t\tscript.charset = 'utf-8';\n\t\t\t\t\tscript.timeout = 120;\n\t\t\t\t\tif (__webpack_require__.nc) {\n\t\t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t\t\t\t}\n\t\t\t\t\tscript.src = url;\n\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tonScriptComplete = (event) => {\n\t\t\t\t\t\tonScriptComplete = () => {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// avoid mem leaks in IE.\n\t\t\t\t\t\tscript.onerror = script.onload = null;\n\t\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\t\tvar reportError = loadingEnded();\n\t\t\t\t\t\tif(reportError) {\n\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\treportError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t;\n\t\t\t\t\tvar timeout = setTimeout(() => {\n\t\t\t\t\t\tonScriptComplete({ type: 'timeout', target: script })\n\t\t\t\t\t}, 120000);\n\t\t\t\t\tscript.onerror = script.onload = onScriptComplete;\n\t\t\t\t\tdocument.head.appendChild(script);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no deferred startup\n\n// install a JSONP callback for chunk loading\nfunction webpackJsonpCallback(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\n\tvar runtime = data[3];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0, resolves = [];\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tresolves.push(installedChunks[chunkId][0]);\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\tfor(moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tif(parentJsonpFunction) parentJsonpFunction(data);\n\twhile(resolves.length) {\n\t\tresolves.shift()();\n\t}\n\n};\n\nvar jsonpArray = window[\"webpackJsonptrilium\"] = window[\"webpackJsonptrilium\"] || [];\nvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\njsonpArray.push = webpackJsonpCallback;\nvar parentJsonpFunction = oldJsonpFunction;","import BasicWidget from \"./basic_widget.js\";\n\nexport default class FlexContainer extends BasicWidget {\n    constructor(direction) {\n        super();\n\n        if (!direction || !['row', 'column'].includes(direction)) {\n            throw new Error(`Direction argument given as \"${direction}\", use either 'row' or 'column'`);\n        }\n\n        this.attrs.style = `display: flex; flex-direction: ${direction};`;\n\n        this.children = [];\n\n        this.positionCounter = 10;\n    }\n\n    child(...components) {\n        if (!components) {\n            return this;\n        }\n\n        super.child(...components);\n\n        for (const component of components) {\n            if (!component.position) {\n                component.position = this.positionCounter;\n                this.positionCounter += 10;\n            }\n        }\n\n        this.children.sort((a, b) => a.position - b.position < 0 ? -1 : 1);\n\n        return this;\n    }\n\n    doRender() {\n        this.$widget = $(`<div>`);\n\n        for (const widget of this.children) {\n            this.$widget.append(widget.render());\n        }\n\n        return this.$widget;\n    }\n}","import TabAwareWidget from \"./tab_aware_widget.js\";\nimport utils from \"../services/utils.js\";\nimport protectedSessionHolder from \"../services/protected_session_holder.js\";\nimport server from \"../services/server.js\";\nimport SpacedUpdate from \"../services/spaced_update.js\";\n\nconst TPL = `\n<div class=\"note-title-container\">\n    <style>\n    .note-title-container {\n        flex-grow: 100;\n    }\n    \n    .note-title-container input.note-title {\n        font-size: 150%;\n        border: 0;\n        min-width: 5em;\n        width: 100%;\n    }\n    \n    .note-title-container input.note-title.protected {\n        text-shadow: 4px 4px 4px var(--muted-text-color);\n    }\n    </style>\n\n    <input autocomplete=\"off\" value=\"\" class=\"note-title\" tabindex=\"1\">\n</div>`;\n\nexport default class NoteTitleWidget extends TabAwareWidget {\n    constructor() {\n        super();\n\n        this.spacedUpdate = new SpacedUpdate(async () => {\n            const title = this.$noteTitle.val();\n\n            protectedSessionHolder.touchProtectedSessionIfNecessary(this.note);\n\n            await server.put(`notes/${this.noteId}/change-title`, {title});\n        });\n    }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$noteTitle = this.$widget.find(\".note-title\");\n\n        this.$noteTitle.on('input', () => this.spacedUpdate.scheduleUpdate());\n\n        utils.bindElShortcut(this.$noteTitle, 'return', () => {\n            this.triggerCommand('focusOnDetail', {tabId: this.tabContext.tabId});\n        });\n\n        return this.$widget;\n    }\n\n    async refreshWithNote(note) {\n        this.$noteTitle.val(note.title);\n\n        this.$noteTitle.prop(\"readonly\", note.isProtected && !protectedSessionHolder.isProtectedSessionAvailable());\n\n        this.setProtectedStatus(note);\n    }\n\n    setProtectedStatus(note) {\n        this.$noteTitle.toggleClass(\"protected\", !!note.isProtected);\n    }\n\n    async beforeNoteSwitchEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            await this.spacedUpdate.updateNowIfNecessary();\n        }\n    }\n\n    async beforeTabRemoveEvent({tabId}) {\n        if (this.isTab(tabId)) {\n            await this.spacedUpdate.updateNowIfNecessary();\n        }\n    }\n\n    focusOnTitleEvent() {\n        if (this.tabContext && this.tabContext.isActive()) {\n            this.$noteTitle.trigger('focus');\n        }\n    }\n\n    focusAndSelectTitleEvent() {\n        if (this.tabContext && this.tabContext.isActive()) {\n            this.$noteTitle\n                .trigger('focus')\n                .trigger('select');\n        }\n    }\n\n    entitiesReloadedEvent({loadResults}) {\n        if (loadResults.isNoteReloaded(this.noteId)) {\n            // not updating the title specifically since the synced title might be older than what the user is currently typing\n            this.setProtectedStatus(this.note);\n        }\n    }\n\n    beforeUnloadEvent() {\n        this.spacedUpdate.updateNowIfNecessary();\n    }\n}\n","import TabAwareWidget from \"../tab_aware_widget.js\";\n\nexport default class TypeWidget extends TabAwareWidget {\n    // for overriding\n    static getType() {}\n\n    /**\n     * @param {NoteShort} note\n     */\n    async doRefresh(note) {}\n\n    async refresh() {\n        const thisWidgetType = this.constructor.getType();\n        const noteWidgetType = await this.parent.getWidgetType();\n\n        if (thisWidgetType !== noteWidgetType) {\n            this.toggleInt(false);\n\n            this.cleanup();\n        }\n        else {\n            this.toggleInt(true);\n\n            await this.doRefresh(this.note);\n        }\n    }\n\n    isActive() {\n        return this.$widget.is(\":visible\");\n    }\n\n    getContent() {}\n\n    focus() {}\n\n    scrollToTop() {\n        this.$widget.scrollTop(0);\n    }\n\n    autoBookDisabledEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            this.refresh();\n        }\n    }\n\n    textPreviewDisabledEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            this.refresh();\n        }\n    }\n\n    codePreviewDisabledEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            this.refresh();\n        }\n    }\n}","import server from \"./server.js\";\nimport bundleService from \"./bundle.js\";\n\nasync function render(note, $el) {\n    const relations = note.getRelations('renderNote');\n    const renderNoteIds = relations\n        .map(rel => rel.value)\n        .filter(noteId => noteId);\n\n    $el.empty().toggle(renderNoteIds.length > 0);\n\n    for (const renderNoteId of renderNoteIds) {\n        const bundle = await server.get('script/bundle/' + renderNoteId);\n\n        const $scriptContainer = $('<div>');\n        $el.append($scriptContainer);\n\n        $scriptContainer.append(bundle.html);\n\n        // async so that scripts cannot block trilium execution\n        bundleService.executeBundle(bundle, note, $scriptContainer);\n    }\n\n    return renderNoteIds.length > 0;\n}\n\nexport default {\n    render\n}","import server from \"./server.js\";\nimport utils from \"./utils.js\";\nimport renderService from \"./render.js\";\nimport protectedSessionService from \"./protected_session.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\n\nasync function getRenderedContent(note) {\n    const type = getRenderingType(note);\n\n    let $rendered;\n\n    if (type === 'text') {\n        const fullNote = await server.get('notes/' + note.noteId);\n\n        $rendered = $('<div class=\"ck-content\">').html(fullNote.content);\n    }\n    else if (type === 'code') {\n        const fullNote = await server.get('notes/' + note.noteId);\n\n        $rendered = $(\"<pre>\").text(fullNote.content);\n    }\n    else if (type === 'image') {\n        $rendered = $(\"<img>\")\n            .attr(\"src\", `api/images/${note.noteId}/${note.title}`)\n            .css(\"max-width\", \"100%\");\n    }\n    else if (type === 'file') {\n        function getFileUrl() {\n            return utils.getUrlForDownload(\"api/notes/\" + note.noteId + \"/download\");\n        }\n\n        const $downloadButton = $('<button class=\"file-download btn btn-primary\" type=\"button\">Download</button>');\n        const $openButton = $('<button class=\"file-open btn btn-primary\" type=\"button\">Open</button>');\n\n        $downloadButton.on('click', () => utils.download(getFileUrl()));\n        $openButton.on('click', () => {\n            if (utils.isElectron()) {\n                const open = utils.dynamicRequire(\"open\");\n\n                open(getFileUrl(), {url: true});\n            }\n            else {\n                window.location.href = getFileUrl();\n            }\n        });\n\n        // open doesn't work for protected notes since it works through browser which isn't in protected session\n        $openButton.toggle(!note.isProtected);\n\n        $rendered = $('<div>');\n\n        if (note.mime === 'application/pdf' && utils.isElectron()) {\n            const $pdfPreview = $('<iframe class=\"pdf-preview\" style=\"width: 100%; height: 100%; flex-grow: 100;\"></iframe>');\n            $pdfPreview.attr(\"src\", utils.getUrlForDownload(\"api/notes/\" + note.noteId + \"/open\"));\n\n            $rendered.append($pdfPreview);\n        }\n\n        $rendered\n            .append($downloadButton)\n            .append(' &nbsp; ')\n            .append($openButton);\n    }\n    else if (type === 'render') {\n        $rendered = $('<div>');\n\n        await renderService.render(note, $rendered, this.ctx);\n    }\n    else if (type === 'protected-session') {\n        const $button = $(`<button class=\"btn btn-sm\"><span class=\"bx bx-log-in\"></span> Enter protected session</button>`)\n            .on('click', protectedSessionService.enterProtectedSession);\n\n        $rendered = $(\"<div>\")\n            .append(\"<div>This note is protected and to access it you need to enter password.</div>\")\n            .append(\"<br/>\")\n            .append($button);\n    }\n    else {\n        $rendered = $(\"<em>Content of this note cannot be displayed in the book format</em>\");\n    }\n\n    $rendered.addClass(note.getCssClass());\n\n    return {\n        renderedContent: $rendered,\n        type\n    };\n}\n\nfunction getRenderingType(note) {\n    let type = note.type;\n\n    if (note.isProtected) {\n        if (protectedSessionHolder.isProtectedSessionAvailable()) {\n            protectedSessionHolder.touchProtectedSession();\n        }\n        else {\n            type = 'protected-session';\n        }\n    }\n\n    return type;\n}\n\nexport default {\n    getRenderedContent\n};","import TypeWidget from \"./type_widget.js\";\nimport appContext from \"../../services/app_context.js\";\nimport treeCache from \"../../services/tree_cache.js\";\nimport linkService from \"../../services/link.js\";\nimport noteContentRenderer from \"../../services/note_content_renderer.js\";\n\nexport default class AbstractTextTypeWidget extends TypeWidget {\n    doRender() {\n        this.$widget.on(\"dblclick\", \"img\", e => {\n            const $img = $(e.target);\n            const src = $img.prop(\"src\");\n\n            const match = src.match(/\\/api\\/images\\/([A-Za-z0-9]+)\\//);\n\n            if (match) {\n                const noteId = match[1];\n\n                appContext.tabManager.getActiveTabContext().setNote(noteId);\n            }\n            else {\n                window.open(src, '_blank');\n            }\n        });\n    }\n\n    async loadIncludedNote(noteId, $el) {\n        const note = await treeCache.getNote(noteId);\n\n        if (note) {\n            const $link = await linkService.createNoteLink(note.noteId, {\n                showTooltip: false\n            });\n\n            $el.empty().append(\n                $('<h4 class=\"include-note-title\">')\n                    .append($link)\n            );\n\n            const {renderedContent} = await noteContentRenderer.getRenderedContent(note);\n\n            $el.append(\n                $('<div class=\"include-note-content\">')\n                    .append(renderedContent)\n            );\n        }\n    }\n\n    async loadReferenceLinkTitle(noteId, $el) {\n        const note = await treeCache.getNote(noteId, true);\n\n        let title;\n\n        if (!note) {\n            title = '[missing]';\n        }\n        else if (!note.isDeleted) {\n            title = note.title;\n        }\n        else {\n            title = note.isErased ? '[erased]' : `${note.title} (deleted)`;\n        }\n\n        $el.text(title);\n    }\n\n    refreshIncludedNote($container, noteId) {\n        if ($container) {\n            $container.find(`section[data-note-id=\"${noteId}\"]`).each((_, el) => {\n                this.loadIncludedNote(noteId, $(el));\n            });\n        }\n    }\n}\n","import libraryLoader from \"../../services/library_loader.js\";\nimport noteAutocompleteService from '../../services/note_autocomplete.js';\nimport mimeTypesService from '../../services/mime_types.js';\nimport utils from \"../../services/utils.js\";\nimport keyboardActionService from \"../../services/keyboard_actions.js\";\nimport treeCache from \"../../services/tree_cache.js\";\nimport AbstractTextTypeWidget from \"./abstract_text_type_widget.js\";\n\nconst ENABLE_INSPECTOR = false;\n\nconst mentionSetup = {\n    feeds: [\n        {\n            marker: '@',\n            feed: queryText => {\n                return new Promise((res, rej) => {\n                    noteAutocompleteService.autocompleteSource(queryText, rows => {\n                        if (rows.length === 1 && rows[0].title === 'No results') {\n                            rows = [];\n                        }\n\n                        for (const row of rows) {\n                            row.text = row.name = row.noteTitle;\n                            row.id = '@' + row.text;\n                            row.link = '#' + row.path;\n                            row.notePath = row.path;\n                        }\n\n                        res(rows);\n                    });\n                });\n            },\n            itemRenderer: item => {\n                const itemElement = document.createElement('span');\n\n                itemElement.classList.add('mentions-item');\n                itemElement.innerHTML = `${item.highlightedTitle} `;\n\n                return itemElement;\n            },\n            minimumCharacters: 0\n        }\n    ]\n};\n\nconst TPL = `\n<div class=\"note-detail-text note-detail-printable\">\n    <style>\n    .note-detail-text h1 { font-size: 2.0em; }\n    .note-detail-text h2 { font-size: 1.8em; }\n    .note-detail-text h3 { font-size: 1.6em; }\n    .note-detail-text h4 { font-size: 1.4em; }\n    .note-detail-text h5 { font-size: 1.2em; }\n    .note-detail-text h6 { font-size: 1.1em; }\n    \n    .note-detail-text {\n        overflow: auto;\n        height: 100%;\n        font-family: var(--detail-text-font-family);\n        padding-left: 12px;\n    }\n    \n    .note-detail-text-editor {\n        padding-top: 10px;\n        border: 0 !important;\n        box-shadow: none !important;\n        /* This is because with empty content height of editor is 0 and it's impossible to click into it */\n        min-height: 500px;\n    }\n    \n    .note-detail-text p:first-child, .note-detail-text::before {\n        margin-top: 0;\n    }\n    </style>\n\n    <div class=\"note-detail-text-editor\" tabindex=\"10000\"></div>\n</div>\n`;\n\nexport default class EditableTextTypeWidget extends AbstractTextTypeWidget {\n    static getType() { return \"editable-text\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$editor = this.$widget.find('.note-detail-text-editor');\n\n        this.initialized = this.initEditor();\n\n        keyboardActionService.setupActionsForElement('text-detail', this.$widget, this);\n\n        super.doRender();\n\n        return this.$widget;\n    }\n\n    async initEditor() {\n        await libraryLoader.requireLibrary(libraryLoader.CKEDITOR);\n\n        const codeBlockLanguages =\n            (await mimeTypesService.getMimeTypes())\n                .filter(mt => mt.enabled)\n                .map(mt => ({\n                        language: mt.mime.toLowerCase().replace(/[\\W_]+/g,\"-\"),\n                        label: mt.title\n                    }));\n\n        // CKEditor since version 12 needs the element to be visible before initialization. At the same time\n        // we want to avoid flicker - i.e. show editor only once everything is ready. That's why we have separate\n        // display of $widget in both branches.\n        this.$widget.show();\n\n        this.textEditor = await BalloonEditor.create(this.$editor[0], {\n            placeholder: \"Type the content of your note here ...\",\n            mention: mentionSetup,\n            codeBlock: {\n                languages: codeBlockLanguages\n            }\n        });\n\n        this.textEditor.model.document.on('change:data', () => this.spacedUpdate.scheduleUpdate());\n\n        if (glob.isDev && ENABLE_INSPECTOR) {\n            await import(/* webpackIgnore: true */'../../../libraries/ckeditor/inspector.js');\n            CKEditorInspector.attach(this.textEditor);\n        }\n    }\n\n    async doRefresh(note) {\n        const noteComplement = await treeCache.getNoteComplement(note.noteId);\n\n        await this.spacedUpdate.allowUpdateWithoutChange(() => {\n            this.textEditor.setData(noteComplement.content);\n        });\n    }\n\n    getContent() {\n        const content = this.textEditor.getData();\n\n        // if content is only tags/whitespace (typically <p>&nbsp;</p>), then just make it empty\n        // this is important when setting new note to code\n        return utils.isHtmlEmpty(content) ? '' : content;\n    }\n\n    focus() {\n        this.$editor.trigger('focus');\n    }\n\n    show() {}\n\n    getEditor() {\n        return this.textEditor;\n    }\n\n    cleanup() {\n        if (this.textEditor) {\n            this.spacedUpdate.allowUpdateWithoutChange(() => {\n                this.textEditor.setData('');\n            });\n        }\n    }\n\n    insertDateTimeToTextCommand() {\n        const date = new Date();\n        const dateString = utils.formatDateTime(date);\n\n        this.addTextToEditor(dateString);\n    }\n\n    async addLinkToEditor(linkHref, linkTitle) {\n        await this.initialized;\n\n        this.textEditor.model.change(writer => {\n            const insertPosition = this.textEditor.model.document.selection.getFirstPosition();\n            writer.insertText(linkTitle, {linkHref: linkHref}, insertPosition);\n        });\n    }\n\n    async addTextToEditor(text) {\n        await this.initialized;\n\n        this.textEditor.model.change(writer => {\n            const insertPosition = this.textEditor.model.document.selection.getFirstPosition();\n            writer.insertText(text, insertPosition);\n        });\n    }\n\n    addTextToActiveEditorEvent(text) {\n        if (!this.isActive()) {\n            return;\n        }\n\n        this.addTextToEditor(text);\n    }\n\n    async addLink(notePath, linkTitle) {\n        await this.initialized;\n\n        if (linkTitle) {\n            if (this.hasSelection()) {\n                this.textEditor.execute('link', '#' + notePath);\n            } else {\n                await this.addLinkToEditor('#' + notePath, linkTitle);\n            }\n        }\n        else {\n            this.textEditor.execute('referenceLink', { notePath: notePath });\n        }\n\n        this.textEditor.editing.view.focus();\n    }\n\n    // returns true if user selected some text, false if there's no selection\n    hasSelection() {\n        const model = this.textEditor.model;\n        const selection = model.document.selection;\n\n        return !selection.isCollapsed;\n    }\n\n    async executeInActiveEditorEvent({callback}) {\n        if (!this.isActive()) {\n            return;\n        }\n\n        await this.initialized;\n\n        callback(this.textEditor);\n    }\n\n    addLinkToTextCommand() {\n        import(\"../../dialogs/add_link.js\").then(d => d.showDialog(this));\n    }\n\n    addIncludeNoteToTextCommand() {\n        import(\"../../dialogs/include_note.js\").then(d => d.showDialog(this));\n    }\n\n    addIncludeNote(noteId, boxSize) {\n        this.textEditor.model.change( writer => {\n            // Insert <includeNote>*</includeNote> at the current selection position\n            // in a way that will result in creating a valid model structure\n            this.textEditor.model.insertContent(writer.createElement('includeNote', {\n                noteId: noteId,\n                boxSize: boxSize\n            }));\n        } );\n    }\n\n    async addImage(noteId) {\n        const note = await treeCache.getNote(noteId);\n\n        this.textEditor.model.change( writer => {\n            const src = `api/images/${note.noteId}/${note.title}`;\n\n            const imageElement = writer.createElement( 'image',  { 'src': src } );\n\n            this.textEditor.model.insertContent(imageElement, this.textEditor.model.document.selection);\n        } );\n    }\n\n    async refreshIncludedNoteEvent({noteId}) {\n        this.refreshIncludedNote(this.$editor, noteId);\n    }\n}\n","import utils from \"../../services/utils.js\";\nimport toastService from \"../../services/toast.js\";\nimport server from \"../../services/server.js\";\nimport TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"note-detail-image note-detail-printable\">\n    <div class=\"no-print\" style=\"display: flex; justify-content: space-evenly; margin: 10px;\">\n        <button class=\"image-download btn btn-sm btn-primary\" type=\"button\">Download</button>\n\n        <button class=\"image-copy-to-clipboard btn btn-sm btn-primary\" type=\"button\">Copy to clipboard</button>\n\n        <button class=\"image-upload-new-revision btn btn-sm btn-primary\" type=\"button\">Upload new revision</button>\n    </div>\n\n    <div class=\"note-detail-image-wrapper\">\n        <img class=\"note-detail-image-view\" />\n    </div>\n\n    <div style=\"display: flex; justify-content: space-evenly; margin: 10px;\">\n        <span>\n            <strong>Original file name:</strong>\n            <span class=\"image-filename\"></span>\n        </span>\n\n        <span>\n            <strong>File type:</strong>\n            <span class=\"image-filetype\"></span>\n        </span>\n\n        <span>\n            <strong>File size:</strong>\n            <span class=\"image-filesize\"></span>\n        </span>\n    </div>\n\n    <input type=\"file\" class=\"image-upload-new-revision-input\" style=\"display: none\">\n</div>`;\n\nclass ImageTypeWidget extends TypeWidget {\n    static getType() { return \"image\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$imageWrapper = this.$widget.find('.note-detail-image-wrapper');\n        this.$imageView = this.$widget.find('.note-detail-image-view');\n        this.$copyToClipboardButton = this.$widget.find(\".image-copy-to-clipboard\");\n        this.$uploadNewRevisionButton = this.$widget.find(\".image-upload-new-revision\");\n        this.$uploadNewRevisionInput = this.$widget.find(\".image-upload-new-revision-input\");\n        this.$fileName = this.$widget.find(\".image-filename\");\n        this.$fileType = this.$widget.find(\".image-filetype\");\n        this.$fileSize = this.$widget.find(\".image-filesize\");\n\n        this.$imageDownloadButton = this.$widget.find(\".image-download\");\n        this.$imageDownloadButton.on('click', () => utils.download(this.getFileUrl()));\n\n        this.$copyToClipboardButton.on('click',() => {\n            this.$imageWrapper.attr('contenteditable','true');\n\n            try {\n                this.selectImage(this.$imageWrapper.get(0));\n\n                const success = document.execCommand('copy');\n\n                if (success) {\n                    toastService.showMessage(\"Image copied to the clipboard\");\n                }\n                else {\n                    toastService.showAndLogError(\"Could not copy the image to clipboard.\");\n                }\n            }\n            finally {\n                window.getSelection().removeAllRanges();\n                this.$imageWrapper.removeAttr('contenteditable');\n            }\n        });\n\n        this.$uploadNewRevisionButton.on(\"click\", () => {\n            this.$uploadNewRevisionInput.trigger(\"click\");\n        });\n\n        this.$uploadNewRevisionInput.on('change', async () => {\n            const fileToUpload = this.$uploadNewRevisionInput[0].files[0]; // copy to allow reset below\n            this.$uploadNewRevisionInput.val('');\n\n            const formData = new FormData();\n            formData.append('upload', fileToUpload);\n\n            const result = await $.ajax({\n                url: baseApiUrl + 'images/' + this.noteId,\n                headers: server.getHeaders(),\n                data: formData,\n                type: 'PUT',\n                timeout: 60 * 60 * 1000,\n                contentType: false, // NEEDED, DON'T REMOVE THIS\n                processData: false, // NEEDED, DON'T REMOVE THIS\n            });\n\n            if (result.uploaded) {\n                toastService.showMessage(\"New image revision has been uploaded.\");\n\n                await utils.clearBrowserCache();\n\n                this.refresh();\n            }\n            else {\n                toastService.showError(\"Upload of a new image revision failed: \" + result.message);\n            }\n        });\n\n        return this.$widget;\n    }\n\n    async doRefresh(note) {\n        const attributes = note.getAttributes();\n        const attributeMap = utils.toObject(attributes, l => [l.name, l.value]);\n\n        this.$widget.show();\n\n        this.$fileName.text(attributeMap.originalFileName || \"?\");\n        this.$fileSize.text(note.contentLength + \" bytes\");\n        this.$fileType.text(note.mime);\n\n        const imageHash = utils.randomString(10);\n\n        this.$imageView.prop(\"src\", `api/images/${note.noteId}/${note.title}?${imageHash}`);\n    }\n\n    selectImage(element) {\n        const selection = window.getSelection();\n        const range = document.createRange();\n        range.selectNodeContents(element);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n\n    getFileUrl() {\n        return utils.getUrlForDownload(`api/notes/${this.noteId}/download`);\n    }\n}\n\nexport default ImageTypeWidget","import server from \"../../services/server.js\";\nimport linkService from \"../../services/link.js\";\nimport libraryLoader from \"../../services/library_loader.js\";\nimport contextMenu from \"../../services/context_menu.js\";\nimport toastService from \"../../services/toast.js\";\nimport attributeAutocompleteService from \"../../services/attribute_autocomplete.js\";\nimport TypeWidget from \"./type_widget.js\";\nimport appContext from \"../../services/app_context.js\";\nimport utils from \"../../services/utils.js\";\n\nconst uniDirectionalOverlays = [\n    [ \"Arrow\", {\n        location: 1,\n        id: \"arrow\",\n        length: 14,\n        foldback: 0.8\n    } ],\n    [ \"Label\", { label: \"\", id: \"label\", cssClass: \"connection-label\" }]\n];\n\nconst biDirectionalOverlays = [\n    [ \"Arrow\", {\n        location: 1,\n        id: \"arrow\",\n        length: 14,\n        foldback: 0.8\n    } ],\n    [ \"Label\", { label: \"\", id: \"label\", cssClass: \"connection-label\" }],\n    [ \"Arrow\", {\n        location: 0,\n        id: \"arrow2\",\n        length: 14,\n        direction: -1,\n        foldback: 0.8\n    } ]\n];\n\nconst inverseRelationsOverlays = [\n    [ \"Arrow\", {\n        location: 1,\n        id: \"arrow\",\n        length: 14,\n        foldback: 0.8\n    } ],\n    [ \"Label\", { label: \"\", location: 0.2, id: \"label-source\", cssClass: \"connection-label\" }],\n    [ \"Label\", { label: \"\", location: 0.8, id: \"label-target\", cssClass: \"connection-label\" }],\n    [ \"Arrow\", {\n        location: 0,\n        id: \"arrow2\",\n        length: 14,\n        direction: -1,\n        foldback: 0.8\n    } ]\n];\n\nconst linkOverlays = [\n    [ \"Arrow\", {\n        location: 1,\n        id: \"arrow\",\n        length: 14,\n        foldback: 0.8\n    } ]\n];\n\nconst TPL = `\n<div class=\"note-detail-relation-map note-detail-printable\">\n    <button class=\"relation-map-create-child-note btn btn-sm floating-button no-print\" type=\"button\"\n            title=\"Create new child note and add it into this relation map\">\n        <span class=\"bx bx-folder-plus\"></span>\n\n        Create child note\n    </button>\n\n    <button type=\"button\"\n            class=\"relation-map-reset-pan-zoom btn icon-button floating-button bx bx-crop no-print\"\n            title=\"Reset pan & zoom to initial coordinates and magnification\"\n            style=\"right: 70px;\"></button>\n\n    <div class=\"btn-group floating-button no-print\" style=\"right: 10px;\">\n        <button type=\"button\"\n                class=\"relation-map-zoom-in btn icon-button bx bx-zoom-in\"\n                title=\"Zoom In\"></button>\n\n        <button type=\"button\"\n                class=\"relation-map-zoom-out btn icon-button bx bx-zoom-out\"\n                title=\"Zoom Out\"></button>\n    </div>\n\n    <div class=\"relation-map-wrapper\">\n       <div class=\"relation-map-container\"></div>\n    </div>\n</div>`;\n\nlet containerCounter = 1;\n\nexport default class RelationMapTypeWidget extends TypeWidget {\n    static getType() { return \"relation-map\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$relationMapContainer = this.$widget.find(\".relation-map-container\");\n        this.$createChildNote = this.$widget.find(\".relation-map-create-child-note\");\n        this.$zoomInButton = this.$widget.find(\".relation-map-zoom-in\");\n        this.$zoomOutButton = this.$widget.find(\".relation-map-zoom-out\");\n        this.$resetPanZoomButton = this.$widget.find(\".relation-map-reset-pan-zoom\");\n\n        this.mapData = null;\n        this.jsPlumbInstance = null;\n        // outside of mapData because they are not persisted in the note content\n        this.relations = null;\n        this.pzInstance = null;\n\n        this.$relationMapWrapper = this.$widget.find('.relation-map-wrapper');\n        this.$relationMapWrapper.on('click', event => {\n            if (this.clipboard) {\n                let {x, y} = this.getMousePosition(event);\n\n                // modifying position so that cursor is on the top-center of the box\n                x -= 80;\n                y -= 15;\n\n                this.createNoteBox(this.clipboard.noteId, this.clipboard.title, x, y);\n\n                this.mapData.notes.push({ noteId: this.clipboard.noteId, x, y });\n\n                this.saveData();\n\n                this.clipboard = null;\n            }\n\n            return true;\n        });\n\n        this.$relationMapContainer.attr(\"id\", \"relation-map-container-\" + (containerCounter++));\n        this.$relationMapContainer.on(\"contextmenu\", \".note-box\", e => {\n            contextMenu.show({\n                x: e.pageX,\n                y: e.pageY,\n                items: [\n                    {title: \"Open in new tab\", command: \"openInNewTab\", uiIcon: \"empty\"},\n                    {title: \"Remove note\", command: \"remove\", uiIcon: \"trash\"},\n                    {title: \"Edit title\", command: \"editTitle\", uiIcon: \"pencil\"},\n                ],\n                selectMenuItemHandler: ({command}) => this.contextMenuHandler(command, e.target)\n            });\n\n            return false;\n        });\n\n        this.clipboard = null;\n\n        this.$createChildNote.on('click', async () => {\n            const promptDialog = await import('../../dialogs/prompt.js');\n            const title = await promptDialog.ask({ message: \"Enter title of new note\",  defaultValue: \"new note\" });\n\n            if (!title.trim()) {\n                return;\n            }\n\n            const {note} = await server.post(`notes/${this.noteId}/children?target=into`, {\n                title,\n                content: '',\n                type: 'text'\n            });\n\n            toastService.showMessage(\"Click on canvas to place new note\");\n\n            this.clipboard = { noteId: note.noteId, title };\n        });\n\n        this.$resetPanZoomButton.on('click', () => {\n            // reset to initial pan & zoom state\n            this.pzInstance.zoomTo(0, 0, 1 / this.getZoom());\n            this.pzInstance.moveTo(0, 0);\n        });\n\n        this.$widget.on(\"drop\", ev => this.dropNoteOntoRelationMapHandler(ev));\n        this.$widget.on(\"dragover\", ev => ev.preventDefault());\n\n        this.initialized = new Promise(async res => {\n            await libraryLoader.requireLibrary(libraryLoader.RELATION_MAP);\n\n            jsPlumb.ready(res);\n        });\n\n        return this.$widget;\n    }\n\n    async contextMenuHandler(command, originalTarget) {\n        const $noteBox = $(originalTarget).closest(\".note-box\");\n        const $title = $noteBox.find(\".title a\");\n        const noteId = this.idToNoteId($noteBox.prop(\"id\"));\n\n        if (command === \"openInNewTab\") {\n            appContext.tabManager.openTabWithNote(noteId);\n        }\n        else if (command === \"remove\") {\n            const confirmDialog = await import('../../dialogs/confirm.js');\n\n            if (!await confirmDialog.confirmDeleteNoteBoxWithNote($title.text())) {\n                return;\n            }\n\n            this.jsPlumbInstance.remove(this.noteIdToId(noteId));\n\n            if (confirmDialog.isDeleteNoteChecked()) {\n                const taskId = utils.randomString(10);\n\n                await server.remove(`notes/${noteId}?taskId=${taskId}&last=true`);\n            }\n\n            this.mapData.notes = this.mapData.notes.filter(note => note.noteId !== noteId);\n\n            this.relations = this.relations.filter(relation => relation.sourceNoteId !== noteId && relation.targetNoteId !== noteId);\n\n            this.saveData();\n        }\n        else if (command === \"editTitle\") {\n            const promptDialog = await import(\"../../dialogs/prompt.js\");\n            const title = await promptDialog.ask({\n                message: \"Enter new note title:\",\n                defaultValue: $title.text()\n            });\n\n            if (!title) {\n                return;\n            }\n\n            await server.put(`notes/${noteId}/change-title`, { title });\n\n            $title.text(title);\n        }\n    }\n\n    async loadMapData() {\n        this.mapData = {\n            notes: [],\n            // it is important to have this exact value here so that initial transform is same as this\n            // which will guarantee note won't be saved on first conversion to relation map note type\n            // this keeps the principle that note type change doesn't destroy note content unless user\n            // does some actual change\n            transform: {\n                x: 0,\n                y: 0,\n                scale: 1\n            }\n        };\n\n        const noteComplement = await this.tabContext.getNoteComplement();\n\n        if (noteComplement.content) {\n            try {\n                this.mapData = JSON.parse(noteComplement.content);\n            } catch (e) {\n                console.log(\"Could not parse content: \", e);\n            }\n        }\n    }\n\n    noteIdToId(noteId) {\n        return \"rel-map-note-\" + noteId;\n    }\n\n    idToNoteId(id) {\n        return id.substr(13);\n    }\n\n    async doRefresh(note) {\n        await this.loadMapData();\n\n        this.initJsPlumbInstance();\n\n        this.initPanZoom();\n\n        this.loadNotesAndRelations();\n    }\n\n    clearMap() {\n        // delete all endpoints and connections\n        // this is done at this point (after async operations) to reduce flicker to the minimum\n        this.jsPlumbInstance.deleteEveryEndpoint();\n\n        // without this we still end up with note boxes remaining in the canvas\n        this.$relationMapContainer.empty();\n    }\n\n    async loadNotesAndRelations() {\n        const noteIds = this.mapData.notes.map(note => note.noteId);\n        const data = await server.post(\"notes/relation-map\", {noteIds});\n\n        this.relations = [];\n\n        for (const relation of data.relations) {\n            const match = this.relations.find(rel =>\n                rel.name === data.inverseRelations[relation.name]\n                && ((rel.sourceNoteId === relation.sourceNoteId && rel.targetNoteId === relation.targetNoteId)\n                || (rel.sourceNoteId === relation.targetNoteId && rel.targetNoteId === relation.sourceNoteId)));\n\n            if (match) {\n                match.type = relation.type = relation.name === data.inverseRelations[relation.name] ? 'biDirectional' : 'inverse';\n                relation.render = false; // don't render second relation\n            } else {\n                relation.type = 'uniDirectional';\n                relation.render = true;\n            }\n\n            this.relations.push(relation);\n        }\n\n        this.mapData.notes = this.mapData.notes.filter(note => note.noteId in data.noteTitles);\n\n        this.jsPlumbInstance.batch(async () => {\n            this.clearMap();\n\n            for (const note of this.mapData.notes) {\n                const title = data.noteTitles[note.noteId];\n\n                await this.createNoteBox(note.noteId, title, note.x, note.y);\n            }\n\n            for (const relation of this.relations) {\n                if (!relation.render) {\n                    continue;\n                }\n\n                const connection = this.jsPlumbInstance.connect({\n                    source: this.noteIdToId(relation.sourceNoteId),\n                    target: this.noteIdToId(relation.targetNoteId),\n                    type: relation.type\n                });\n\n                connection.id = relation.attributeId;\n\n                if (relation.type === 'inverse') {\n                    connection.getOverlay(\"label-source\").setLabel(relation.name);\n                    connection.getOverlay(\"label-target\").setLabel(data.inverseRelations[relation.name]);\n                }\n                else {\n                    connection.getOverlay(\"label\").setLabel(relation.name);\n                }\n\n                connection.canvas.setAttribute(\"data-connection-id\", connection.id);\n            }\n        });\n    }\n\n    initPanZoom() {\n        if (this.pzInstance) {\n            return;\n        }\n\n        this.pzInstance = panzoom(this.$relationMapContainer[0], {\n            maxZoom: 2,\n            minZoom: 0.3,\n            smoothScroll: false,\n            filterKey: function(e, dx, dy, dz) {\n                // if ALT is pressed then panzoom should bubble the event up\n                // this is to preserve ALT-LEFT, ALT-RIGHT navigation working\n                return e.altKey;\n            }\n        });\n\n        this.pzInstance.on('transform', () => { // gets triggered on any transform change\n            this.jsPlumbInstance.setZoom(this.getZoom());\n\n            this.saveCurrentTransform();\n        });\n\n        if (this.mapData.transform) {\n            this.pzInstance.zoomTo(0, 0, this.mapData.transform.scale);\n\n            this.pzInstance.moveTo(this.mapData.transform.x, this.mapData.transform.y);\n        }\n        else {\n            // set to initial coordinates\n            this.pzInstance.moveTo(0, 0);\n        }\n\n        this.$zoomInButton.on('click', () => this.pzInstance.zoomTo(0, 0, 1.2));\n        this.$zoomOutButton.on('click', () => this.pzInstance.zoomTo(0, 0, 0.8));\n    }\n\n    saveCurrentTransform() {\n        const newTransform = this.pzInstance.getTransform();\n\n        if (JSON.stringify(newTransform) !== JSON.stringify(this.mapData.transform)) {\n            // clone transform object\n            this.mapData.transform = JSON.parse(JSON.stringify(newTransform));\n\n            this.saveData();\n        }\n    }\n\n    cleanup() {\n        if (this.jsPlumbInstance) {\n            this.clearMap();\n        }\n\n        if (this.pzInstance) {\n            this.pzInstance.dispose();\n            this.pzInstance = null;\n        }\n    }\n\n    initJsPlumbInstance () {\n        if (this.jsPlumbInstance) {\n            this.cleanup();\n\n            return;\n        }\n\n        this.jsPlumbInstance = jsPlumb.getInstance({\n            Endpoint: [\"Dot\", {radius: 2}],\n            Connector: \"StateMachine\",\n            ConnectionOverlays: uniDirectionalOverlays,\n            HoverPaintStyle: { stroke: \"#777\", strokeWidth: 1 },\n            Container: this.$relationMapContainer.attr(\"id\")\n        });\n\n        this.jsPlumbInstance.registerConnectionType(\"uniDirectional\", { anchor:\"Continuous\", connector:\"StateMachine\", overlays: uniDirectionalOverlays });\n\n        this.jsPlumbInstance.registerConnectionType(\"biDirectional\", { anchor:\"Continuous\", connector:\"StateMachine\", overlays: biDirectionalOverlays });\n\n        this.jsPlumbInstance.registerConnectionType(\"inverse\", { anchor:\"Continuous\", connector:\"StateMachine\", overlays: inverseRelationsOverlays });\n\n        this.jsPlumbInstance.registerConnectionType(\"link\", { anchor:\"Continuous\", connector:\"StateMachine\", overlays: linkOverlays });\n\n        this.jsPlumbInstance.bind(\"connection\", (info, originalEvent) => this.connectionCreatedHandler(info, originalEvent));\n    }\n\n    async connectionCreatedHandler(info, originalEvent) {\n        const connection = info.connection;\n\n        connection.bind(\"contextmenu\", (obj, event) => {\n            if (connection.getType().includes(\"link\")) {\n                // don't create context menu if it's a link since there's nothing to do with link from relation map\n                // (don't open browser menu either)\n                event.preventDefault();\n            }\n            else {\n                event.preventDefault();\n                event.stopPropagation();\n\n                contextMenu.show({\n                    x: event.pageX,\n                    y: event.pageY,\n                    items: [ {title: \"Remove relation\", command: \"remove\", uiIcon: \"trash\"} ],\n                    selectMenuItemHandler: async ({command}) => {\n                        if (command === 'remove') {\n                            const confirmDialog = await import('../../dialogs/confirm.js');\n\n                            if (!await confirmDialog.confirm(\"Are you sure you want to remove the relation?\")) {\n                                return;\n                            }\n\n                            const relation = this.relations.find(rel => rel.attributeId === connection.id);\n\n                            await server.remove(`notes/${relation.sourceNoteId}/relations/${relation.name}/to/${relation.targetNoteId}`);\n\n                            this.jsPlumbInstance.deleteConnection(connection);\n\n                            this.relations = this.relations.filter(relation => relation.attributeId !== connection.id);\n                        }\n                    }\n                });\n            }\n        });\n\n        // if there's no event, then this has been triggered programatically\n        if (!originalEvent) {\n            return;\n        }\n\n        const promptDialog = await import(\"../../dialogs/prompt.js\");\n        const name = await promptDialog.ask({\n            message: \"Specify new relation name:\",\n            shown: ({ $answer }) =>\n                attributeAutocompleteService.initAttributeNameAutocomplete({\n                    $el: $answer,\n                    attributeType: \"relation\",\n                    open: true\n                })\n        });\n\n        if (!name || !name.trim()) {\n            this.jsPlumbInstance.deleteConnection(connection);\n\n            return;\n        }\n\n        const targetNoteId = this.idToNoteId(connection.target.id);\n        const sourceNoteId = this.idToNoteId(connection.source.id);\n\n        const relationExists = this.relations.some(rel =>\n            rel.targetNoteId === targetNoteId\n            && rel.sourceNoteId === sourceNoteId\n            && rel.name === name);\n\n        if (relationExists) {\n            const infoDialog = await import('../../dialogs/info.js');\n            await infoDialog.info(\"Connection '\" + name + \"' between these notes already exists.\");\n\n            this.jsPlumbInstance.deleteConnection(connection);\n\n            return;\n        }\n\n        await server.put(`notes/${sourceNoteId}/relations/${name}/to/${targetNoteId}`);\n\n        this.loadNotesAndRelations();\n    }\n\n    saveData() {\n        this.spacedUpdate.scheduleUpdate();\n    }\n\n    async createNoteBox(noteId, title, x, y) {\n        const $link = await linkService.createNoteLink(noteId, {title});\n        $link.mousedown(e => {\n            console.log(e);\n\n            linkService.goToLink(e);\n        });\n\n        const $noteBox = $(\"<div>\")\n            .addClass(\"note-box\")\n            .prop(\"id\", this.noteIdToId(noteId))\n            .append($(\"<span>\").addClass(\"title\").append($link))\n            .append($(\"<div>\").addClass(\"endpoint\").attr(\"title\", \"Start dragging relations from here and drop them on another note.\"))\n            .css(\"left\", x + \"px\")\n            .css(\"top\", y + \"px\");\n\n        this.jsPlumbInstance.getContainer().appendChild($noteBox[0]);\n\n        this.jsPlumbInstance.draggable($noteBox[0], {\n            start: params => {},\n            drag: params => {},\n            stop: params => {\n                const noteId = this.idToNoteId(params.el.id);\n\n                const note = this.mapData.notes.find(note => note.noteId === noteId);\n\n                if (!note) {\n                    console.error(`Note ${noteId} not found!`);\n                    return;\n                }\n\n                [note.x, note.y] = params.finalPos;\n\n                this.saveData();\n            }\n        });\n\n        this.jsPlumbInstance.makeSource($noteBox[0], {\n            filter: \".endpoint\",\n            anchor: \"Continuous\",\n            connectorStyle: { stroke: \"#000\", strokeWidth: 1 },\n            connectionType: \"basic\",\n            extract:{\n                \"action\": \"the-action\"\n            }\n        });\n\n        this.jsPlumbInstance.makeTarget($noteBox[0], {\n            dropOptions: { hoverClass: \"dragHover\" },\n            anchor: \"Continuous\",\n            allowLoopback: true\n        });\n    }\n\n    getZoom() {\n        const matrixRegex = /matrix\\((-?\\d*\\.?\\d+),\\s*0,\\s*0,\\s*-?\\d*\\.?\\d+,\\s*-?\\d*\\.?\\d+,\\s*-?\\d*\\.?\\d+\\)/;\n\n        const transform = this.$relationMapContainer.css('transform');\n\n        if (transform === 'none') {\n            return 1;\n        }\n\n        const matches = transform.match(matrixRegex);\n\n        if (!matches) {\n            throw new Error(\"Cannot match transform: \" + transform);\n        }\n\n        return matches[1];\n    }\n\n    async dropNoteOntoRelationMapHandler(ev) {\n        ev.preventDefault();\n\n        const notes = JSON.parse(ev.originalEvent.dataTransfer.getData(\"text\"));\n\n        let {x, y} = this.getMousePosition(ev);\n\n        for (const note of notes) {\n            const exists = this.mapData.notes.some(n => n.noteId === note.noteId);\n\n            if (exists) {\n                toastService.showError(`Note \"${note.title}\" is already in the diagram.`);\n\n                continue;\n            }\n\n            this.mapData.notes.push({noteId: note.noteId, x, y});\n\n            if (x > 1000) {\n                y += 100;\n                x = 0;\n            }\n            else {\n                x += 200;\n            }\n        }\n\n        this.saveData();\n\n        this.loadNotesAndRelations();\n    }\n\n    getMousePosition(evt) {\n        const rect = this.$relationMapContainer[0].getBoundingClientRect();\n\n        const zoom = this.getZoom();\n\n        return {\n            x: (evt.clientX - rect.left) / zoom,\n            y: (evt.clientY - rect.top) / zoom\n        };\n    }\n\n    getContent() {\n        return JSON.stringify(this.mapData);\n    }\n}","import linkService from \"../../services/link.js\";\nimport treeCache from \"../../services/tree_cache.js\";\nimport noteContentRenderer from \"../../services/note_content_renderer.js\";\nimport TypeWidget from \"./type_widget.js\";\n\nconst MIN_ZOOM_LEVEL = 1;\nconst MAX_ZOOM_LEVEL = 6;\n\nconst ZOOMS = {\n    1: {\n        width: \"100%\",\n        height: \"100%\"\n    },\n    2: {\n        width: \"49%\",\n        height: \"350px\"\n    },\n    3: {\n        width: \"32%\",\n        height: \"250px\"\n    },\n    4: {\n        width: \"24%\",\n        height: \"200px\"\n    },\n    5: {\n        width: \"19%\",\n        height: \"175px\"\n    },\n    6: {\n        width: \"16%\",\n        height: \"150px\"\n    }\n};\n\nconst TPL = `\n<div class=\"note-detail-book note-detail-printable\">\n    <div class=\"btn-group floating-button\" style=\"right: 20px; top: 20px;\">\n        <button type=\"button\"\n                class=\"expand-children-button btn icon-button bx bx-move-vertical\"\n                title=\"Expand all children\"></button>\n\n        <button type=\"button\"\n                class=\"book-zoom-in-button btn icon-button bx bx-zoom-in\"\n                title=\"Zoom In\"></button>\n\n        <button type=\"button\"\n                class=\"book-zoom-out-button btn icon-button bx bx-zoom-out\"\n                title=\"Zoom Out\"></button>\n    </div>\n\n    <div class=\"note-detail-book-help alert alert-warning\" style=\"margin: 50px; padding: 20px;\">\n        This note of type Book doesn't have any child notes so there's nothing to display. See <a href=\"https://github.com/zadam/trilium/wiki/Book-note\">wiki</a> for details.\n    </div>\n\n    <div class=\"note-detail-book-content\"></div>\n</div>`;\n\nexport default class BookTypeWidget extends TypeWidget {\n    static getType() { return \"book\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$content = this.$widget.find('.note-detail-book-content');\n        this.$zoomInButton = this.$widget.find('.book-zoom-in-button');\n        this.$zoomOutButton = this.$widget.find('.book-zoom-out-button');\n        this.$expandChildrenButton = this.$widget.find('.expand-children-button');\n        this.$help = this.$widget.find('.note-detail-book-help');\n\n        this.$zoomInButton.on('click', () => this.setZoom(this.zoomLevel - 1));\n        this.$zoomOutButton.on('click', () => this.setZoom(this.zoomLevel + 1));\n\n        this.$expandChildrenButton.on('click', async () => {\n            for (let i = 1; i < 30; i++) { // protection against infinite cycle\n                const $unexpandedLinks = this.$content.find('.note-book-open-children-button:visible');\n\n                if ($unexpandedLinks.length === 0) {\n                    break;\n                }\n\n                for (const link of $unexpandedLinks) {\n                    const $card = $(link).closest(\".note-book-card\");\n\n                    await this.expandCard($card);\n                }\n            }\n        });\n\n        this.$content.on('click', '.note-book-open-children-button', async ev => {\n            const $card = $(ev.target).closest('.note-book-card');\n\n            await this.expandCard($card);\n        });\n\n        this.$content.on('click', '.note-book-hide-children-button', async ev => {\n            const $card = $(ev.target).closest('.note-book-card');\n\n            $card.find('.note-book-open-children-button').show();\n            $card.find('.note-book-hide-children-button').hide();\n\n            $card.find('.note-book-children-content').empty();\n        });\n        \n        return this.$widget;\n    }\n\n    async expandCard($card) {\n        const noteId = $card.attr('data-note-id');\n        const note = await treeCache.getNote(noteId);\n\n        $card.find('.note-book-open-children-button').hide();\n        $card.find('.note-book-hide-children-button').show();\n\n        await this.renderIntoElement(note, $card.find('.note-book-children-content'));\n    }\n\n    setZoom(zoomLevel) {\n        if (!(zoomLevel in ZOOMS)) {\n            zoomLevel = this.getDefaultZoomLevel();\n        }\n\n        this.zoomLevel = zoomLevel;\n\n        this.$zoomInButton.prop(\"disabled\", zoomLevel === MIN_ZOOM_LEVEL);\n        this.$zoomOutButton.prop(\"disabled\", zoomLevel === MAX_ZOOM_LEVEL);\n\n        this.$content.find('.note-book-card').css(\"flex-basis\", ZOOMS[zoomLevel].width);\n        this.$content.find('.note-book-content').css(\"max-height\", ZOOMS[zoomLevel].height);\n    }\n\n    async doRefresh(note) {\n        this.$content.empty();\n        this.$help.hide();\n\n        if (this.isAutoBook()) {\n            const $addTextLink = $('<a href=\"javascript:\">here</a>').on('click', () => {\n                this.tabContext.autoBookDisabled = true;\n\n                this.triggerEvent('autoBookDisabled', {tabContext: this.tabContext});\n            });\n\n            this.$content.append($('<div class=\"note-book-auto-message\"></div>')\n                .append(`This note doesn't have any content so we display its children. <br> Click `)\n                .append($addTextLink)\n                .append(' if you want to add some text.'));\n        }\n\n        const zoomLevel = parseInt(note.getLabelValue('bookZoomLevel')) || this.getDefaultZoomLevel();\n        this.setZoom(zoomLevel);\n\n        await this.renderIntoElement(note, this.$content);\n    }\n\n    async renderIntoElement(note, $container) {\n        const childNotes = await note.getChildNotes();\n\n        if (childNotes.length === 0) {\n            this.$help.show();\n        }\n\n        const imageLinks = note.getRelations('imageLink');\n\n        for (const childNote of childNotes) {\n            // image is already visible in the parent note so no need to display it separately in the book\n            if (imageLinks.find(rel => rel.value === childNote.noteId)) {\n                continue;\n            }\n\n            const $card = await this.renderNote(childNote);\n\n            $container.append($card);\n        }\n    }\n\n    async renderNote(note) {\n        const notePath = this.notePath + '/' + note.noteId;\n\n        const $content = $('<div class=\"note-book-content\">')\n            .css(\"max-height\", ZOOMS[this.zoomLevel].height);\n\n        const $card = $('<div class=\"note-book-card\">')\n            .attr('data-note-id', note.noteId)\n            .css(\"flex-basis\", ZOOMS[this.zoomLevel].width)\n            .append($('<h5 class=\"note-book-title\">').append(await linkService.createNoteLink(notePath, {showTooltip: false})))\n            .append($content);\n\n        try {\n            const {type, renderedContent} = await noteContentRenderer.getRenderedContent(note);\n\n            $card.addClass(\"type-\" + type);\n            $content.append(renderedContent);\n        } catch (e) {\n            console.log(`Caught error while rendering note ${note.noteId} of type ${note.type}: ${e.message}, stack: ${e.stack}`);\n\n            $content.append(\"rendering error\");\n        }\n\n        const imageLinks = note.getRelations('imageLink');\n\n        const childCount = note.getChildNoteIds()\n            .filter(childNoteId => !imageLinks.find(rel => rel.value === childNoteId))\n            .length;\n\n        if (childCount > 0) {\n            const label = `${childCount} child${childCount > 1 ? 'ren' : ''}`;\n\n            $card.append($('<div class=\"note-book-children\">')\n                .append($(`<a class=\"note-book-open-children-button no-print\" href=\"javascript:\">+ Show ${label}</a>`))\n                .append($(`<a class=\"note-book-hide-children-button no-print\" href=\"javascript:\">- Hide ${label}</a>`).hide())\n                .append($('<div class=\"note-book-children-content\">'))\n            );\n        }\n\n        return $card;\n    }\n\n    /** @return {boolean} true if this is \"auto book\" activated (empty text note) and not explicit book note */\n    isAutoBook() {\n        return this.note.type !== 'book';\n    }\n\n    getDefaultZoomLevel() {\n        if (this.isAutoBook()) {\n            const w = this.$widget.width();\n\n            if (w <= 600) {\n                return 1;\n            } else if (w <= 900) {\n                return 2;\n            } else if (w <= 1300) {\n                return 3;\n            } else {\n                return 4;\n            }\n        }\n        else {\n            return 1;\n        }\n    }\n\n    cleanup() {\n        this.$content.empty();\n    }\n}","import TabAwareWidget from \"./tab_aware_widget.js\";\nimport utils from \"../services/utils.js\";\nimport protectedSessionHolder from \"../services/protected_session_holder.js\";\nimport SpacedUpdate from \"../services/spaced_update.js\";\nimport server from \"../services/server.js\";\nimport libraryLoader from \"../services/library_loader.js\";\nimport EmptyTypeWidget from \"./type_widgets/empty.js\";\nimport EditableTextTypeWidget from \"./type_widgets/editable_text.js\";\nimport EditableCodeTypeWidget from \"./type_widgets/editable_code.js\";\nimport FileTypeWidget from \"./type_widgets/file.js\";\nimport ImageTypeWidget from \"./type_widgets/image.js\";\nimport SearchTypeWidget from \"./type_widgets/search.js\";\nimport RenderTypeWidget from \"./type_widgets/render.js\";\nimport RelationMapTypeWidget from \"./type_widgets/relation_map.js\";\nimport ProtectedSessionTypeWidget from \"./type_widgets/protected_session.js\";\nimport BookTypeWidget from \"./type_widgets/book.js\";\nimport appContext from \"../services/app_context.js\";\nimport keyboardActionsService from \"../services/keyboard_actions.js\";\nimport noteCreateService from \"../services/note_create.js\";\nimport DeletedTypeWidget from \"./type_widgets/deleted.js\";\nimport ReadOnlyTextTypeWidget from \"./type_widgets/read_only_text.js\";\nimport ReadOnlyCodeTypeWidget from \"./type_widgets/read_only_code.js\";\n\nconst TPL = `\n<div class=\"note-detail\">\n    <style>\n    .note-detail {\n        height: 100%;\n        min-height: 0;\n        font-family: var(--detail-font-family);\n        font-size: var(--detail-font-size);\n    }\n    </style>\n</div>\n`;\n\nconst typeWidgetClasses = {\n    'empty': EmptyTypeWidget,\n    'deleted': DeletedTypeWidget,\n    'editable-text': EditableTextTypeWidget,\n    'read-only-text': ReadOnlyTextTypeWidget,\n    'editable-code': EditableCodeTypeWidget,\n    'read-only-code': ReadOnlyCodeTypeWidget,\n    'file': FileTypeWidget,\n    'image': ImageTypeWidget,\n    'search': SearchTypeWidget,\n    'render': RenderTypeWidget,\n    'relation-map': RelationMapTypeWidget,\n    'protected-session': ProtectedSessionTypeWidget,\n    'book': BookTypeWidget\n};\n\nexport default class NoteDetailWidget extends TabAwareWidget {\n    constructor() {\n        super();\n\n        this.typeWidgets = {};\n\n        this.spacedUpdate = new SpacedUpdate(async () => {\n            const {note} = this.tabContext;\n            const {noteId} = note;\n\n            const dto = note.dto;\n            dto.content = this.getTypeWidget().getContent();\n\n            protectedSessionHolder.touchProtectedSessionIfNecessary(note);\n\n            await server.put('notes/' + noteId, dto, this.componentId);\n        });\n    }\n\n    isEnabled() {\n        return true;\n    }\n\n    doRender() {\n        this.$widget = $(TPL);\n\n        this.$widget.on(\"dragover\", e => e.preventDefault());\n\n        this.$widget.on(\"dragleave\", e => e.preventDefault());\n\n        this.$widget.on(\"drop\", async e => {\n            const activeNote = appContext.tabManager.getActiveTabNote();\n\n            if (!activeNote) {\n                return;\n            }\n\n            const files = [...e.originalEvent.dataTransfer.files]; // chrome has issue that dataTransfer.files empties after async operation\n\n            const importService = await import(\"../services/import.js\");\n\n            importService.uploadFiles(activeNote.noteId, files, {\n                safeImport: true,\n                shrinkImages: true,\n                textImportedAsText: true,\n                codeImportedAsCode: true,\n                explodeArchives: true\n            });\n        });\n\n        return this.$widget;\n    }\n\n    async refresh() {\n        this.type = await this.getWidgetType();\n        this.mime = this.note ? this.note.mime : null;\n\n        if (!(this.type in this.typeWidgets)) {\n            const clazz = typeWidgetClasses[this.type];\n\n            const typeWidget = this.typeWidgets[this.type] = new clazz();\n            typeWidget.spacedUpdate = this.spacedUpdate;\n            typeWidget.setParent(this);\n\n            const $renderedWidget = typeWidget.render();\n            keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n            this.$widget.append($renderedWidget);\n\n            await typeWidget.handleEvent('setTabContext', {tabContext: this.tabContext});\n\n            // this is happening in update() so note has been already set and we need to reflect this\n            await typeWidget.handleEvent('tabNoteSwitched', {\n                tabContext: this.tabContext,\n                notePath: this.tabContext.notePath\n            });\n\n            this.child(typeWidget);\n        }\n\n        this.setupClasses();\n    }\n\n    setupClasses() {\n        for (const clazz of Array.from(this.$widget[0].classList)) { // create copy to safely iterate over while removing classes\n            if (clazz !== 'note-detail' && !clazz.startsWith('hidden-')) {\n                this.$widget.removeClass(clazz);\n            }\n        }\n\n        const note = this.note;\n\n        if (note) {\n            this.$widget.addClass(note.getCssClass());\n\n            this.$widget.addClass(utils.getNoteTypeClass(note.type));\n            this.$widget.addClass(utils.getMimeTypeClass(note.mime));\n\n            this.$widget.toggleClass(\"protected\", note.isProtected);\n        }\n    }\n\n    getTypeWidget() {\n        if (!this.typeWidgets[this.type]) {\n            throw new Error(\"Could not find typeWidget for type: \" + this.type);\n        }\n\n        return this.typeWidgets[this.type];\n    }\n\n    async getWidgetType() {\n        const note = this.note;\n\n        if (!note) {\n            return \"empty\";\n        } else if (note.isDeleted) {\n            return \"deleted\";\n        }\n\n        let type = note.type;\n\n        if (type === 'text' && !this.tabContext.autoBookDisabled\n            && note.hasChildren()\n            && utils.isDesktop()) {\n\n            const noteComplement = await this.tabContext.getNoteComplement();\n\n            if (utils.isHtmlEmpty(noteComplement.content)) {\n                type = 'book';\n            }\n        }\n\n        if (type === 'text' && !this.tabContext.textPreviewDisabled) {\n            const noteComplement = await this.tabContext.getNoteComplement();\n\n            if (note.hasLabel('readOnly') ||\n                (noteComplement.content\n                    && noteComplement.content.length > 10000)\n                    && !note.hasLabel('autoReadOnlyDisabled')) {\n                type = 'read-only-text';\n            }\n        }\n\n        if (type === 'code' && !this.tabContext.codePreviewDisabled) {\n            const noteComplement = await this.tabContext.getNoteComplement();\n\n            if (note.hasLabel('readOnly') ||\n                (noteComplement.content\n                    && noteComplement.content.length > 30000)\n                    && !note.hasLabel('autoReadOnlyDisabled')) {\n                type = 'read-only-code';\n            }\n        }\n\n        if (type === 'text') {\n            type = 'editable-text';\n        }\n\n        if (type === 'code') {\n            type = 'editable-code';\n        }\n\n        if (note.isProtected && !protectedSessionHolder.isProtectedSessionAvailable()) {\n            type = 'protected-session';\n        }\n\n        return type;\n    }\n\n    async focusOnDetailEvent({tabId}) {\n        if (this.tabContext.tabId === tabId) {\n            await this.refresh();\n\n            const widget = this.getTypeWidget();\n            widget.focus();\n        }\n    }\n\n    async beforeNoteSwitchEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            await this.spacedUpdate.updateNowIfNecessary();\n        }\n    }\n\n    async beforeTabRemoveEvent({tabId}) {\n        if (this.isTab(tabId)) {\n            await this.spacedUpdate.updateNowIfNecessary();\n        }\n    }\n\n    async printActiveNoteEvent() {\n        if (!this.tabContext.isActive()) {\n            return;\n        }\n\n        await libraryLoader.requireLibrary(libraryLoader.PRINT_THIS);\n\n        this.$widget.find('.note-detail-printable:visible').printThis({\n            header: $(\"<h2>\").text(this.note && this.note.title).prop('outerHTML'),\n            footer: \"<script>document.body.className += ' ck-content';</script>\",\n            importCSS: false,\n            loadCSS: [\n                \"libraries/codemirror/codemirror.css\",\n                \"libraries/ckeditor/ckeditor-content.css\",\n                \"libraries/ckeditor/ckeditor-content.css\",\n                \"libraries/bootstrap/css/bootstrap.min.css\",\n                \"stylesheets/print.css\",\n                \"stylesheets/relation_map.css\",\n                \"stylesheets/themes.css\",\n                \"stylesheets/detail.css\"\n            ],\n            debug: true\n        });\n    }\n\n    hoistedNoteChangedEvent() {\n        this.refresh();\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        if (loadResults.isNoteContentReloaded(this.noteId, this.componentId)\n            || (loadResults.isNoteReloaded(this.noteId, this.componentId) && (this.type !== await this.getWidgetType() || this.mime !== this.note.mime))) {\n\n            this.handleEvent('noteTypeMimeChanged', {noteId: this.noteId});\n        }\n        else {\n            const attrs = loadResults.getAttributes();\n\n            const label = attrs.find(attr =>\n                attr.type === 'label'\n                && ['readOnly', 'autoReadOnlyDisabled', 'cssClass', 'bookZoomLevel'].includes(attr.name)\n                && attr.isAffecting(this.note));\n\n            const relation = attrs.find(attr =>\n                attr.type === 'relation'\n                && ['template', 'renderNote'].includes(attr.name)\n                && attr.isAffecting(this.note));\n\n            if (label || relation) {\n                // probably incorrect event\n                // calling this.refresh() is not enough since the event needs to be propagated to children as well\n                this.handleEvent('noteTypeMimeChanged', {noteId: this.noteId});\n            }\n        }\n    }\n\n    beforeUnloadEvent() {\n        this.spacedUpdate.updateNowIfNecessary();\n    }\n\n    autoBookDisabledEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            this.refresh();\n        }\n    }\n\n    textPreviewDisabledEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            this.refresh();\n        }\n    }\n\n    codePreviewDisabledEvent({tabContext}) {\n        if (this.isTab(tabContext.tabId)) {\n            this.refresh();\n        }\n    }\n\n    async cutIntoNoteCommand() {\n        const note = appContext.tabManager.getActiveTabNote();\n\n        if (!note) {\n            return;\n        }\n\n        // without await as this otherwise causes deadlock through component mutex\n        noteCreateService.createNote(note.noteId, {\n            isProtected: note.isProtected,\n            saveSelection: true\n        });\n    }\n}\n","import noteAutocompleteService from '../../services/note_autocomplete.js';\nimport TypeWidget from \"./type_widget.js\";\nimport appContext from \"../../services/app_context.js\";\n\nconst TPL = `\n<div class=\"note-detail-empty note-detail-printable\">\n    <div class=\"form-group\">\n        <label>Open note by typing note's title into input below or choose a note in the tree.</label>\n        <div class=\"input-group\">\n            <input class=\"form-control note-autocomplete\" placeholder=\"search for note by its name\">\n        </div>\n    </div>\n</div>`;\n\nexport default class EmptyTypeWidget extends TypeWidget {\n    static getType() { return \"empty\"; }\n\n    doRender() {\n        // FIXME: this might be optimized - cleaned up after use since it's always used only for new tab\n\n        this.$widget = $(TPL);\n        this.$autoComplete = this.$widget.find(\".note-autocomplete\");\n\n        noteAutocompleteService.initNoteAutocomplete(this.$autoComplete, { hideGoToSelectedNoteButton: true })\n            .on('autocomplete:selected', function(event, suggestion, dataset) {\n                if (!suggestion.path) {\n                    return false;\n                }\n\n                appContext.tabManager.getActiveTabContext().setNote(suggestion.path);\n            });\n\n        noteAutocompleteService.showRecentNotes(this.$autoComplete);\n\n        return this.$widget;\n    }\n\n    doRefresh(note) {\n        this.$autoComplete.trigger('focus');\n    }\n}","import TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"note-detail-deleted note-detail-printable\">\n    <div style=\"padding: 100px;\">\n        <div class=\"alert alert-warning\" style=\"padding: 20px;\">\n            This note has been deleted.\n        </div>\n    </div>\n</div>`;\n\nexport default class DeletedTypeWidget extends TypeWidget {\n    static getType() { return \"deleted\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n\n        return this.$widget;\n    }\n}","import treeCache from \"../../services/tree_cache.js\";\nimport AbstractTextTypeWidget from \"./abstract_text_type_widget.js\";\nimport treeService from \"../../services/tree.js\";\n\nconst TPL = `\n<div class=\"note-detail-readonly-text note-detail-printable\">\n    <style>\n    .note-detail-readonly-text h1 { font-size: 2.0em; }\n    .note-detail-readonly-text h2 { font-size: 1.8em; }\n    .note-detail-readonly-text h3 { font-size: 1.6em; }\n    .note-detail-readonly-text h4 { font-size: 1.4em; }\n    .note-detail-readonly-text h5 { font-size: 1.2em; }\n    .note-detail-readonly-text h6 { font-size: 1.1em; }\n    \n    .note-detail-readonly-text {\n        overflow: auto;\n        height: 100%;\n        padding: 10px;\n        font-family: var(--detail-text-font-family);\n    }\n        \n    .note-detail-readonly-text p:first-child, .note-detail-text::before {\n        margin-top: 0;\n    }\n    \n    .note-detail-readonly-text img {\n        max-width: 100%;\n    }\n    </style>\n\n    <div class=\"alert alert-warning no-print\">\n        Read only text view is shown. <a href=\"#\" class=\"edit-note\">Click here</a> to edit the note.\n    </div>\n\n    <div class=\"note-detail-readonly-text-content ck-content\"></div>\n</div>\n`;\n\nexport default class ReadOnlyTextTypeWidget extends AbstractTextTypeWidget {\n    static getType() { return \"read-only-text\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n\n        this.$content = this.$widget.find('.note-detail-readonly-text-content');\n\n        this.$widget.find('a.edit-note').on('click', () => {\n            this.tabContext.textPreviewDisabled = true;\n\n            this.triggerEvent('textPreviewDisabled', {tabContext: this.tabContext});\n        });\n\n        super.doRender();\n\n        return this.$widget;\n    }\n\n    cleanup() {\n        this.$content.html('');\n    }\n\n    scrollToTop() {\n        this.$content.scrollTop(0);\n    }\n\n    async doRefresh(note) {\n        const noteComplement = await treeCache.getNoteComplement(note.noteId);\n\n        this.$content.html(noteComplement.content);\n\n        this.$content.find(\"a.reference-link\").each(async (_, el) => {\n            const notePath = $(el).attr('href');\n            const noteId = treeService.getNoteIdFromNotePath(notePath);\n\n            this.loadReferenceLinkTitle(noteId, $(el));\n        });\n\n        this.$content.find(\"section\").each(async (_, el) => {\n            const noteId = $(el).attr('data-note-id');\n\n            this.loadIncludedNote(noteId, $(el));\n        });\n    }\n\n    async refreshIncludedNoteEvent({noteId}) {\n        this.refreshIncludedNote(this.$content, noteId);\n    }\n}\n","import libraryLoader from \"../../services/library_loader.js\";\nimport TypeWidget from \"./type_widget.js\";\nimport keyboardActionService from \"../../services/keyboard_actions.js\";\n\nconst TPL = `\n<div class=\"note-detail-code note-detail-printable\">\n    <style>\n    .note-detail-code {\n        overflow: auto;\n        height: 100%;\n    }\n    \n    .note-detail-code-editor {\n        min-height: 500px;\n    }\n    </style>\n\n    <div class=\"note-detail-code-editor\"></div>\n</div>`;\n\nexport default class EditableCodeTypeWidget extends TypeWidget {\n    static getType() { return \"editable-code\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$editor = this.$widget.find('.note-detail-code-editor');\n\n        keyboardActionService.setupActionsForElement('code-detail', this.$widget, this);\n\n        this.initialized = this.initEditor();\n\n        return this.$widget;\n    }\n\n    async initEditor() {\n        await libraryLoader.requireLibrary(libraryLoader.CODE_MIRROR);\n        \n        CodeMirror.keyMap.default[\"Shift-Tab\"] = \"indentLess\";\n        CodeMirror.keyMap.default[\"Tab\"] = \"indentMore\";\n\n        // these conflict with backward/forward navigation shortcuts\n        delete CodeMirror.keyMap.default[\"Alt-Left\"];\n        delete CodeMirror.keyMap.default[\"Alt-Right\"];\n\n        CodeMirror.modeURL = 'libraries/codemirror/mode/%N/%N.js';\n\n        this.codeEditor = CodeMirror(this.$editor[0], {\n            value: \"\",\n            viewportMargin: Infinity,\n            indentUnit: 4,\n            matchBrackets: true,\n            matchTags: {bothTags: true},\n            highlightSelectionMatches: {showToken: /\\w/, annotateScrollbar: false},\n            lint: true,\n            gutters: [\"CodeMirror-lint-markers\"],\n            lineNumbers: true,\n            tabindex: 100,\n            // we linewrap partly also because without it horizontal scrollbar displays only when you scroll\n            // all the way to the bottom of the note. With line wrap there's no horizontal scrollbar so no problem\n            lineWrapping: true,\n            dragDrop: false // with true the editor inlines dropped files which is not what we expect\n        });\n\n        this.codeEditor.on('change', () => this.spacedUpdate.scheduleUpdate());\n    }\n    \n    async doRefresh(note) {\n        const noteComplement = await this.tabContext.getNoteComplement();\n\n        this.spacedUpdate.allowUpdateWithoutChange(() => {\n            // CodeMirror breaks pretty badly on null so even though it shouldn't happen (guarded by consistency check)\n            // we provide fallback\n            this.codeEditor.setValue(noteComplement.content || \"\");\n            this.codeEditor.clearHistory();\n\n            const info = CodeMirror.findModeByMIME(note.mime);\n\n            if (info) {\n                this.codeEditor.setOption(\"mode\", info.mime);\n                CodeMirror.autoLoadMode(this.codeEditor, info.mode);\n            }\n        });\n\n        this.show();\n    }\n\n    show() {\n        this.$widget.show();\n\n        if (this.codeEditor) { // show can be called before render\n            this.codeEditor.refresh();\n        }\n    }\n\n    getContent() {\n        return this.codeEditor.getValue();\n    }\n\n    focus() {\n        this.codeEditor.focus();\n    }\n\n    cleanup() {\n        if (this.codeEditor) {\n            this.spacedUpdate.allowUpdateWithoutChange(() => {\n                this.codeEditor.setValue('');\n            });\n        }\n    }\n}","import TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"note-detail-read-only-code note-detail-printable\">\n    <style>\n    .note-detail-read-only-code {\n        overflow: auto;\n        height: 100%;\n    }\n    \n    .note-detail-read-only-code-content {\n        padding: 10px;\n    }\n    </style>\n\n    <div class=\"alert alert-warning no-print\" style=\"margin-bottom: 0;\">\n        Read only code view is shown. <a href=\"#\" class=\"edit-note\">Click here</a> to edit the note.\n    </div>\n\n    <pre class=\"note-detail-read-only-code-content\"></pre>\n</div>`;\n\nexport default class ReadOnlyCodeTypeWidget extends TypeWidget {\n    static getType() { return \"read-only-code\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$content = this.$widget.find('.note-detail-read-only-code-content');\n\n        this.$widget.find('a.edit-note').on('click', () => {\n            this.tabContext.codePreviewDisabled = true;\n\n            this.triggerEvent('codePreviewDisabled', {tabContext: this.tabContext});\n        });\n\n        return this.$widget;\n    }\n\n    async doRefresh(note) {\n        const noteComplement = await this.tabContext.getNoteComplement();\n\n        this.$content.text(noteComplement.content);\n    }\n}","import utils from \"../../services/utils.js\";\nimport server from \"../../services/server.js\";\nimport toastService from \"../../services/toast.js\";\nimport TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"note-detail-file note-detail-printable\">\n    <style>\n        .file-table td {\n            overflow-wrap: anywhere;\n        }\n    </style>\n\n    <table class=\"file-table\">\n        <tr>\n            <th>Note ID:</th>\n            <td class=\"file-note-id\"></td>\n            <th>Original file name:</th>\n            <td class=\"file-filename\"></td>\n        </tr>\n        <tr>\n            <th>File type:</th>\n            <td class=\"file-filetype\"></td>\n            <th>File size:</th>\n            <td class=\"file-filesize\"></td>\n        </tr>\n    </table>\n    \n    <pre class=\"file-preview-content\"></pre>\n    \n    <iframe class=\"pdf-preview\" style=\"width: 100%; height: 100%; flex-grow: 100;\"></iframe>\n\n    <div style=\"padding: 10px; display: flex; justify-content: space-evenly;\">\n        <button class=\"file-download btn btn-sm btn-primary\" type=\"button\">Download</button>\n        &nbsp;\n        <button class=\"file-open btn btn-sm btn-primary\" type=\"button\">Open</button>\n        &nbsp;\n        <button class=\"file-upload-new-revision btn btn-sm btn-primary\">Upload new revision</button>\n    \n        <input type=\"file\" class=\"file-upload-new-revision-input\" style=\"display: none\">\n    </div>\n</div>`;\n\nexport default class FileTypeWidget extends TypeWidget {\n    static getType() { return \"file\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$fileNoteId = this.$widget.find(\".file-note-id\");\n        this.$fileName = this.$widget.find(\".file-filename\");\n        this.$fileType = this.$widget.find(\".file-filetype\");\n        this.$fileSize = this.$widget.find(\".file-filesize\");\n        this.$previewContent = this.$widget.find(\".file-preview-content\");\n        this.$pdfPreview = this.$widget.find(\".pdf-preview\");\n        this.$downloadButton = this.$widget.find(\".file-download\");\n        this.$openButton = this.$widget.find(\".file-open\");\n        this.$uploadNewRevisionButton = this.$widget.find(\".file-upload-new-revision\");\n        this.$uploadNewRevisionInput = this.$widget.find(\".file-upload-new-revision-input\");\n\n        this.$downloadButton.on('click', () => utils.download(this.getFileUrl()));\n\n        this.$openButton.on('click', () => {\n            if (utils.isElectron()) {\n                const open = utils.dynamicRequire(\"open\");\n\n                open(this.getFileUrl(), {url: true});\n            }\n            else {\n                window.location.href = this.getFileUrl();\n            }\n        });\n\n        this.$uploadNewRevisionButton.on(\"click\", () => {\n            this.$uploadNewRevisionInput.trigger(\"click\");\n        });\n\n        this.$uploadNewRevisionInput.on('change', async () => {\n            const fileToUpload = this.$uploadNewRevisionInput[0].files[0]; // copy to allow reset below\n            this.$uploadNewRevisionInput.val('');\n\n            const formData = new FormData();\n            formData.append('upload', fileToUpload);\n\n            const result = await $.ajax({\n                url: baseApiUrl + 'notes/' + this.noteId + '/file',\n                headers: server.getHeaders(),\n                data: formData,\n                type: 'PUT',\n                timeout: 60 * 60 * 1000,\n                contentType: false, // NEEDED, DON'T REMOVE THIS\n                processData: false, // NEEDED, DON'T REMOVE THIS\n            });\n\n            if (result.uploaded) {\n                toastService.showMessage(\"New file revision has been uploaded.\");\n\n                this.refresh();\n            }\n            else {\n                toastService.showError(\"Upload of a new file revision failed.\");\n            }\n        });\n\n        return this.$widget;\n    }\n\n    async doRefresh(note) {\n        const attributes = note.getAttributes();\n        const attributeMap = utils.toObject(attributes, l => [l.name, l.value]);\n\n        this.$widget.show();\n\n        this.$fileNoteId.text(note.noteId);\n        this.$fileName.text(attributeMap.originalFileName || \"?\");\n        this.$fileSize.text(note.contentLength + \" bytes\");\n        this.$fileType.text(note.mime);\n\n        const noteComplement = await this.tabContext.getNoteComplement();\n\n        this.$previewContent.empty().hide();\n        this.$pdfPreview.attr('src', '').empty().hide();\n\n        if (noteComplement.content) {\n            this.$previewContent.show();\n            this.$previewContent.text(noteComplement.content);\n        }\n        else if (note.mime === 'application/pdf' && utils.isElectron()) {\n            this.$pdfPreview.show();\n            this.$pdfPreview.attr(\"src\", utils.getUrlForDownload(\"api/notes/\" + this.noteId + \"/open\"));\n        }\n\n        // open doesn't work for protected notes since it works through browser which isn't in protected session\n        this.$openButton.toggle(!note.isProtected);\n    }\n\n    getFileUrl() {\n        return utils.getUrlForDownload(\"api/notes/\" + this.noteId + \"/download\");\n    }\n}\n","import TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"note-detail-search note-detail-printable\">\n    <div style=\"display: flex; align-items: center; margin-right: 20px; margin-top: 15px;\">\n        <strong>Search string: &nbsp; &nbsp;</strong>\n        <textarea rows=\"4\" style=\"width: auto !important; flex-grow: 4\" class=\"search-string form-control\"></textarea>\n    </div>\n\n    <br />\n\n    <div class=\"note-detail-search-help\"></div>\n</div>`;\n\nexport default class SearchTypeWidget extends TypeWidget {\n    static getType() { return \"search\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$searchString = this.$widget.find(\".search-string\");\n        this.$component = this.$widget.find('.note-detail-search');\n        this.$help = this.$widget.find(\".note-detail-search-help\");\n\n        return this.$widget;\n    }\n\n    async doRefresh(note) {\n        this.$help.html(window.glob.SEARCH_HELP_TEXT);\n\n        this.$component.show();\n\n        try {\n            const noteComplement = await this.tabContext.getNoteComplement();\n            const json = JSON.parse(noteComplement.content);\n\n            this.$searchString.val(json.searchString);\n        }\n        catch (e) {\n            console.log(e);\n            this.$searchString.val('');\n        }\n\n        this.$searchString.on('input', () => this.spacedUpdate.scheduleUpdate());\n    }\n\n    getContent() {\n        return JSON.stringify({\n            searchString: this.$searchString.val()\n        });\n    }\n}","import renderService from \"../../services/render.js\";\nimport TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"note-detail-render note-detail-printable\">\n    <style>\n        .note-detail-render {\n            height: 100%;\n        }\n    </style>\n\n    <div class=\"note-detail-render-help alert alert-warning\" style=\"margin: 50px; padding: 20px;\">\n        <p><strong>This help note is shown because this note of type Render HTML doesn't have required relation to function properly.</strong></p>\n\n        <p>Render HTML note type is used for <a href=\"https://github.com/zadam/trilium/wiki/Scripts\">scripting</a>. In short, you have a HTML code note (optionally with some JavaScript) and this note will render it. To make it work, you need to define a relation (in <a class=\"show-attributes-button\">Attributes dialog</a>) called \"renderNote\" pointing to the HTML note to render. Once that's defined you can click on the \"play\" button to render.</p>\n    </div>\n\n    <div class=\"note-detail-render-content\" style=\"height: 100%; overflow: auto;\"></div>\n</div>`;\n\nexport default class RenderTypeWidget extends TypeWidget {\n    static getType() { return \"render\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$noteDetailRenderHelp = this.$widget.find('.note-detail-render-help');\n        this.$noteDetailRenderContent = this.$widget.find('.note-detail-render-content');\n\n        return this.$widget;\n    }\n\n    async doRefresh(note) {\n        this.$widget.show();\n        this.$noteDetailRenderHelp.hide();\n\n        const renderNotesFound = await renderService.render(note, this.$noteDetailRenderContent);\n\n        if (!renderNotesFound) {\n            this.$noteDetailRenderHelp.show();\n        }\n    }\n\n    cleanup() {\n        this.$noteDetailRenderContent.empty();\n    }\n\n    renderActiveNoteEvent() {\n        if (this.tabContext.isActive()) {\n            this.refresh();\n        }\n    }\n}","import protectedSessionService from '../../services/protected_session.js';\nimport TypeWidget from \"./type_widget.js\";\n\nconst TPL = `\n<div class=\"protected-session-password-component note-detail-printable\">\n    <style>\n    .protected-session-password-component {\n        width: 300px;\n        margin: 30px auto auto;\n    }\n    </style>\n\n    <form class=\"protected-session-password-form\">\n        <div class=\"form-group\">\n            <label for=\"protected-session-password-in-detail\">Showing protected note requires entering your password:</label>\n            <input class=\"protected-session-password-in-detail form-control protected-session-password\" type=\"password\">\n        </div>\n\n        <button class=\"btn btn-primary\">Start protected session <kbd>enter</kbd></button>\n    </form>\n</div>`;\n\nexport default class ProtectedSessionTypeWidget extends TypeWidget {\n    static getType() { return \"protected-session\"; }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$passwordForm = this.$widget.find(\".protected-session-password-form\");\n        this.$passwordInput = this.$widget.find(\".protected-session-password\");\n\n        this.$passwordForm.on('submit', () => {\n            const password = this.$passwordInput.val();\n            this.$passwordInput.val(\"\");\n\n            protectedSessionService.setupProtectedSession(password);\n\n            return false;\n        });\n        \n        return this.$widget;\n    }\n}","import server from './server.js';\nimport toastService from \"./toast.js\";\n\nasync function syncNow() {\n    const result = await server.post('sync/now');\n\n    if (result.success) {\n        toastService.showMessage(\"Sync finished successfully.\");\n    }\n    else {\n        if (result.message.length > 100) {\n            result.message = result.message.substr(0, 100);\n        }\n\n        toastService.showError(\"Sync failed: \" + result.message);\n    }\n}\n\nasync function forceNoteSync(noteId) {\n    await server.post('sync/force-note-sync/' + noteId);\n\n    toastService.showMessage(\"Note added to sync queue.\");\n}\n\nexport default {\n    syncNow,\n    forceNoteSync\n};\n","import hoistedNoteService from \"../services/hoisted_note.js\";\nimport treeService from \"../services/tree.js\";\nimport utils from \"../services/utils.js\";\nimport contextMenu from \"../services/context_menu.js\";\nimport treeCache from \"../services/tree_cache.js\";\nimport branchService from \"../services/branches.js\";\nimport ws from \"../services/ws.js\";\nimport TabAwareWidget from \"./tab_aware_widget.js\";\nimport server from \"../services/server.js\";\nimport noteCreateService from \"../services/note_create.js\";\nimport toastService from \"../services/toast.js\";\nimport appContext from \"../services/app_context.js\";\nimport keyboardActionsService from \"../services/keyboard_actions.js\";\nimport clipboard from \"../services/clipboard.js\";\nimport protectedSessionService from \"../services/protected_session.js\";\nimport syncService from \"../services/sync.js\";\nimport options from \"../services/options.js\";\n\nconst TPL = `\n<div class=\"tree-wrapper\">\n    <style>\n    .tree-wrapper {\n        flex-grow: 1;\n        flex-shrink: 1;\n        flex-basis: 60%;\n        font-family: var(--tree-font-family);\n        font-size: var(--tree-font-size);\n        position: relative;\n        min-height: 0;\n    }\n    \n    .tree {\n        height: 100%;\n        overflow: auto;\n    }\n    \n    .refresh-search-button {\n        cursor: pointer;\n        position: relative;\n        top: -1px;\n        border: 1px solid transparent;\n        padding: 2px;\n        border-radius: 2px;\n    }\n    \n    .refresh-search-button:hover {\n        border-color: var(--button-border-color);\n    }\n    \n    .tree-settings-button {\n        position: absolute;\n        top: 10px;\n        right: 20px;\n        z-index: 100;\n    }\n    \n    .tree-settings-popup {\n        display: none; \n        position: absolute; \n        background-color: var(--accented-background-color); \n        border: 1px solid var(--main-border-color); \n        padding: 20px; \n        z-index: 1000;\n        width: 320px; \n        border-radius: 10px 0 10px 10px;\n    }\n    \n    ul.fancytree-container {\n        outline: none !important;\n        background-color: inherit !important;\n    }\n    \n    .fancytree-custom-icon {\n        font-size: 1.3em;\n    }\n    \n    span.fancytree-title {\n        color: inherit !important;\n        background: inherit !important;\n        outline: none !important;\n    }\n    \n    span.fancytree-node.protected > span.fancytree-custom-icon {\n        filter: drop-shadow(2px 2px 2px var(--main-text-color));\n    }\n    \n    span.fancytree-node.multiple-parents .fancytree-title::after {\n        content: \" *\"\n    }\n    \n    span.fancytree-node.fancytree-active-clone:not(.fancytree-active) .fancytree-title {\n        font-weight: bold;\n    }\n    \n    /* first nesting level has lower left padding to avoid extra left padding. Other levels are not affected */\n    .ui-fancytree > li > ul {\n        padding-left: 5px;\n    }\n    \n    span.fancytree-active .fancytree-title {\n        font-weight: bold;\n        border-color: var(--main-border-color) !important;\n        border-radius: 5px;\n    }\n    \n    span.fancytree-active:not(.fancytree-focused) .fancytree-title {\n        border-style: dashed !important;\n    }\n    \n    span.fancytree-focused .fancytree-title, span.fancytree-focused.fancytree-selected .fancytree-title {\n        color: var(--active-item-text-color) !important;\n        background-color: var(--active-item-background-color) !important;\n        border-color: var(--main-background-color) !important; /* invisible border */\n        border-radius: 5px;\n    }\n    \n    span.fancytree-selected .fancytree-title {\n        color: var(--hover-item-text-color) !important;\n        background-color: var(--hover-item-background-color) !important;\n        border-color: var(--main-background-color) !important; /* invisible border */\n        border-radius: 5px;\n        font-style: italic;\n    }\n    \n    span.fancytree-node:hover span.fancytree-title {\n        border-color: var(--main-border-color) !important;\n        border-radius: 5px;\n    }\n    \n    span.fancytree-node.archived {\n        opacity: 0.6;\n    }\n    </style>\n    \n    <button class=\"btn btn-sm icon-button bx bx-cog tree-settings-button\" title=\"Tree settings\"></button>\n    \n    <div class=\"tree-settings-popup\">\n        <div class=\"form-check\">\n            <label class=\"form-check-label\">\n                <input class=\"form-check-input hide-archived-notes\" type=\"checkbox\" value=\"\">\n            \n                Hide archived notes\n            </label>\n        </div>\n        <div class=\"form-check\">\n            <label class=\"form-check-label\">\n                <input class=\"form-check-input hide-included-images\" type=\"checkbox\" value=\"\">\n                \n                Hide images included in a note\n                <span class=\"bx bx-info-circle\" \n                      title=\"Images which are shown in the parent text note will not be displayed in the tree\"></span>\n            </label>\n        </div>\n    \n        <br/>\n    \n        <button class=\"btn btn-sm btn-primary save-tree-settings-button\" type=\"submit\">Save & apply changes</button>\n    </div>\n    \n    <div class=\"tree\"></div>\n</div>\n`;\n\nconst NOTE_TYPE_ICONS = {\n    \"file\": \"bx bx-file\",\n    \"image\": \"bx bx-image\",\n    \"code\": \"bx bx-code\",\n    \"render\": \"bx bx-extension\",\n    \"search\": \"bx bx-file-find\",\n    \"relation-map\": \"bx bx-map-alt\",\n    \"book\": \"bx bx-book\"\n};\n\nexport default class NoteTreeWidget extends TabAwareWidget {\n    constructor(treeName) {\n        super();\n\n        this.treeName = treeName;\n    }\n\n    doRender() {\n        this.$widget = $(TPL);\n        this.$tree = this.$widget.find('.tree');\n\n        this.$tree.on(\"click\", \".unhoist-button\", hoistedNoteService.unhoist);\n        this.$tree.on(\"click\", \".refresh-search-button\", () => this.refreshSearch());\n\n        // fancytree doesn't support middle click so this is a way to support it\n        this.$tree.on('mousedown', '.fancytree-title', e => {\n            if (e.which === 2) {\n                const node = $.ui.fancytree.getNode(e);\n\n                const notePath = treeService.getNotePath(node);\n\n                if (notePath) {\n                    appContext.tabManager.openTabWithNote(notePath);\n                }\n\n                e.stopPropagation();\n                e.preventDefault();\n            }\n        });\n\n        this.$treeSettingsPopup = this.$widget.find('.tree-settings-popup');\n        this.$hideArchivedNotesCheckbox = this.$treeSettingsPopup.find('.hide-archived-notes');\n        this.$hideIncludedImages = this.$treeSettingsPopup.find('.hide-included-images');\n\n        this.$treeSettingsButton = this.$widget.find('.tree-settings-button');\n        this.$treeSettingsButton.on(\"click\", e => {\n            if (this.$treeSettingsPopup.is(\":visible\")) {\n                this.$treeSettingsPopup.hide();\n                return;\n            }\n\n            this.$hideArchivedNotesCheckbox.prop(\"checked\", this.hideArchivedNotes);\n            this.$hideIncludedImages.prop(\"checked\", this.hideIncludedImages);\n\n            let top = this.$treeSettingsButton[0].offsetTop;\n            let left = this.$treeSettingsButton[0].offsetLeft;\n            top += this.$treeSettingsButton.outerHeight();\n            left += this.$treeSettingsButton.outerWidth() - this.$treeSettingsPopup.outerWidth();\n\n            if (left < 0) {\n                left = 0;\n            }\n\n            this.$treeSettingsPopup.css({\n                display: \"block\",\n                top: top,\n                left: left\n            }).addClass(\"show\");\n\n            return false;\n        });\n\n        this.$treeSettingsPopup.on(\"click\", e => { e.stopPropagation(); });\n\n        $(document).on('click', () => this.$treeSettingsPopup.hide());\n\n        this.$saveTreeSettingsButton = this.$treeSettingsPopup.find('.save-tree-settings-button');\n        this.$saveTreeSettingsButton.on('click', async () => {\n            await this.setHideArchivedNotes(this.$hideArchivedNotesCheckbox.prop(\"checked\"));\n            await this.setHideIncludedImages(this.$hideIncludedImages.prop(\"checked\"));\n\n            this.$treeSettingsPopup.hide();\n\n            this.reloadTreeFromCache();\n        });\n\n        this.initialized = this.initFancyTree();\n\n        this.setupNoteTitleTooltip();\n\n        return this.$widget;\n    }\n\n    setupNoteTitleTooltip() {\n        // the following will dynamically set tree item's tooltip if the whole item's text is not currently visible\n        // if the whole text is visible then no tooltip is show since that's unnecessarily distracting\n        // see https://github.com/zadam/trilium/pull/1120 for discussion\n\n        // code inspired by https://gist.github.com/jtsternberg/c272d7de5b967cec2d3d\n        const isEnclosing = ($container, $sub) => {\n            const conOffset           = $container.offset();\n            const conDistanceFromTop  = conOffset.top + $container.outerHeight(true);\n            const conDistanceFromLeft = conOffset.left + $container.outerWidth(true);\n\n            const subOffset           = $sub.offset();\n            const subDistanceFromTop  = subOffset.top + $sub.outerHeight(true);\n            const subDistanceFromLeft = subOffset.left + $sub.outerWidth(true);\n\n            return conDistanceFromTop > subDistanceFromTop\n                && conOffset.top < subOffset.top\n                && conDistanceFromLeft > subDistanceFromLeft\n                && conOffset.left < subOffset.left;\n        };\n\n        this.$tree.on(\"mouseenter\", \"span.fancytree-title\", e => {\n            e.currentTarget.title = isEnclosing(this.$tree, $(e.currentTarget))\n                ? \"\"\n                : e.currentTarget.innerText;\n        });\n    }\n\n    get hideArchivedNotes() {\n        return options.is(\"hideArchivedNotes_\" + this.treeName);\n    }\n\n    async setHideArchivedNotes(val) {\n        await options.save(\"hideArchivedNotes_\" + this.treeName, val.toString());\n    }\n\n    get hideIncludedImages() {\n        return options.is(\"hideIncludedImages_\" + this.treeName);\n    }\n\n    async setHideIncludedImages(val) {\n        await options.save(\"hideIncludedImages_\" + this.treeName, val.toString());\n    }\n\n    async initFancyTree() {\n        const treeData = [await this.prepareRootNode()];\n\n        this.$tree.fancytree({\n            titlesTabbable: true,\n            autoScroll: true,\n            keyboard: false, // we takover keyboard handling in the hotkeys plugin\n            extensions: utils.isMobile() ? [\"dnd5\", \"clones\"] : [\"hotkeys\", \"dnd5\", \"clones\"],\n            source: treeData,\n            scrollParent: this.$tree,\n            minExpandLevel: 2, // root can't be collapsed\n            click: (event, data) => {\n                const targetType = data.targetType;\n                const node = data.node;\n\n                if (targetType === 'title' || targetType === 'icon') {\n                    if (event.shiftKey) {\n                        node.setSelected(!node.isSelected());\n                        node.setFocus(true);\n                    }\n                    else if (event.ctrlKey) {\n                        const notePath = treeService.getNotePath(node);\n                        appContext.tabManager.openTabWithNote(notePath);\n                    }\n                    else if (data.node.isActive()) {\n                        // this is important for single column mobile view, otherwise it's not possible to see again previously displayed note\n                        this.tree.reactivate(true);\n                    }\n                    else {\n                        node.setActive();\n\n                        this.clearSelectedNodes();\n                    }\n\n                    return false;\n                }\n            },\n            activate: async (event, data) => {\n                // click event won't propagate so let's close context menu manually\n                contextMenu.hide();\n\n                const notePath = treeService.getNotePath(data.node);\n\n                const activeTabContext = appContext.tabManager.getActiveTabContext();\n                await activeTabContext.setNote(notePath);\n\n                if (utils.isMobile()) {\n                    this.triggerCommand('setActiveScreen', {screen:'detail'});\n                }\n            },\n            expand: (event, data) => this.setExpanded(data.node.data.branchId, true),\n            collapse: (event, data) => this.setExpanded(data.node.data.branchId, false),\n            hotkeys: utils.isMobile() ? undefined : { keydown: await this.getHotKeys() },\n            dnd5: {\n                autoExpandMS: 600,\n                dragStart: (node, data) => {\n                    // don't allow dragging root node\n                    if (node.data.noteId === hoistedNoteService.getHoistedNoteId()\n                        || node.getParent().data.noteType === 'search') {\n                        return false;\n                    }\n\n                    const notes = this.getSelectedOrActiveNodes(node).map(node => ({\n                        noteId: node.data.noteId,\n                        branchId: node.data.branchId,\n                        title: node.title\n                    }));\n\n                    data.dataTransfer.setData(\"text\", JSON.stringify(notes));\n\n                    // This function MUST be defined to enable dragging for the tree.\n                    // Return false to cancel dragging of node.\n                    return true;\n                },\n                dragEnter: (node, data) => true, // allow drop on any node\n                dragOver: (node, data) => true,\n                dragDrop: async (node, data) => {\n                    if ((data.hitMode === 'over' && node.data.noteType === 'search') ||\n                        (['after', 'before'].includes(data.hitMode)\n                            && (node.data.noteId === hoistedNoteService.getHoistedNoteId() || node.getParent().data.noteType === 'search'))) {\n\n                        const infoDialog = await import('../dialogs/info.js');\n\n                        await infoDialog.info(\"Dropping notes into this location is not allowed.\");\n\n                        return;\n                    }\n\n                    const dataTransfer = data.dataTransfer;\n\n                    if (dataTransfer && dataTransfer.files && dataTransfer.files.length > 0) {\n                        const files = [...dataTransfer.files]; // chrome has issue that dataTransfer.files empties after async operation\n\n                        const importService = await import('../services/import.js');\n\n                        importService.uploadFiles(node.data.noteId, files, {\n                            safeImport: true,\n                            shrinkImages: true,\n                            textImportedAsText: true,\n                            codeImportedAsCode: true,\n                            explodeArchives: true\n                        });\n                    }\n                    else {\n                        const jsonStr = dataTransfer.getData(\"text\");\n                        let notes = null;\n\n                        try {\n                            notes = JSON.parse(jsonStr);\n                        }\n                        catch (e) {\n                            console.error(`Cannot parse ${jsonStr} into notes for drop`);\n                            return;\n                        }\n\n                        // This function MUST be defined to enable dropping of items on the tree.\n                        // data.hitMode is 'before', 'after', or 'over'.\n\n                        const selectedBranchIds = notes.map(note => note.branchId);\n\n                        if (data.hitMode === \"before\") {\n                            branchService.moveBeforeBranch(selectedBranchIds, node.data.branchId);\n                        } else if (data.hitMode === \"after\") {\n                            branchService.moveAfterBranch(selectedBranchIds, node.data.branchId);\n                        } else if (data.hitMode === \"over\") {\n                            branchService.moveToParentNote(selectedBranchIds, node.data.branchId);\n                        } else {\n                            throw new Error(\"Unknown hitMode=\" + data.hitMode);\n                        }\n                    }\n                }\n            },\n            lazyLoad: (event, data) => {\n                const {noteId, noteType} = data.node.data;\n\n                if (noteType === 'search') {\n                    const notePath = treeService.getNotePath(data.node.getParent());\n\n                    // this is a search cycle (search note is a descendant of its own search result)\n                    if (notePath.includes(noteId)) {\n                        data.result = [];\n                        return;\n                    }\n                }\n\n                data.result = treeCache.getNote(noteId).then(note => this.prepareChildren(note));\n            },\n            clones: {\n                highlightActiveClones: true\n            },\n            enhanceTitle: async function (event, data) {\n                const node = data.node;\n                const $span = $(node.span);\n\n                if (node.data.noteId !== 'root'\n                    && node.data.noteId === hoistedNoteService.getHoistedNoteId()\n                    && $span.find('.unhoist-button').length === 0) {\n\n                    const unhoistButton = $('<span>&nbsp; (<a class=\"unhoist-button\">unhoist</a>)</span>');\n\n                    $span.append(unhoistButton);\n                }\n\n                const note = await treeCache.getNote(node.data.noteId);\n\n                if (note.type === 'search' && $span.find('.refresh-search-button').length === 0) {\n                    const refreshSearchButton = $('<span>&nbsp; <span class=\"refresh-search-button bx bx-refresh\" title=\"Refresh saved search results\"></span></span>');\n\n                    $span.append(refreshSearchButton);\n                }\n            },\n            // this is done to automatically lazy load all expanded notes after tree load\n            loadChildren: (event, data) => {\n                data.node.visit((subNode) => {\n                    // Load all lazy/unloaded child nodes\n                    // (which will trigger `loadChildren` recursively)\n                    if (subNode.isUndefined() && subNode.isExpanded()) {\n                        subNode.load();\n                    }\n                });\n            }\n        });\n\n        this.$tree.on('contextmenu', '.fancytree-node', e => {\n            const node = $.ui.fancytree.getNode(e);\n\n            import(\"../services/tree_context_menu.js\").then(({default: TreeContextMenu}) => {\n                const treeContextMenu = new TreeContextMenu(this, node);\n                treeContextMenu.show(e);\n            });\n\n            return false; // blocks default browser right click menu\n        });\n\n        this.tree = $.ui.fancytree.getTree(this.$tree);\n    }\n\n    async prepareRootNode() {\n        await treeCache.initializedPromise;\n\n        const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n        let hoistedBranch;\n\n        if (hoistedNoteId === 'root') {\n            hoistedBranch = treeCache.getBranch('root');\n        }\n        else {\n            const hoistedNote = await treeCache.getNote(hoistedNoteId);\n            hoistedBranch = (await hoistedNote.getBranches())[0];\n        }\n\n        return await this.prepareNode(hoistedBranch);\n    }\n\n    async prepareChildren(note) {\n        if (note.type === 'search') {\n            return await this.prepareSearchNoteChildren(note);\n        }\n        else {\n            return await this.prepareNormalNoteChildren(note);\n        }\n    }\n\n    getIconClass(note) {\n        const labels = note.getLabels('iconClass');\n\n        return labels.map(l => l.value).join(' ');\n    }\n\n    getIcon(note, isFolder) {\n        const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n        const iconClass = this.getIconClass(note);\n\n        if (iconClass) {\n            return iconClass;\n        }\n        else if (note.noteId === 'root') {\n            return \"bx bx-chevrons-right\";\n        }\n        else if (note.noteId === hoistedNoteId) {\n            return \"bx bxs-arrow-from-bottom\";\n        }\n        else if (note.type === 'text') {\n            if (isFolder) {\n                return \"bx bx-folder\";\n            }\n            else {\n                return \"bx bx-note\";\n            }\n        }\n        else {\n            return NOTE_TYPE_ICONS[note.type];\n        }\n    }\n\n    async prepareNode(branch) {\n        const note = await branch.getNote();\n\n        if (!note) {\n            throw new Error(`Branch has no note ` + branch.noteId);\n        }\n\n        const title = (branch.prefix ? (branch.prefix + \" - \") : \"\") + note.title;\n        const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n        const isFolder = this.isFolder(note);\n\n        const node = {\n            noteId: note.noteId,\n            parentNoteId: branch.parentNoteId,\n            branchId: branch.branchId,\n            isProtected: note.isProtected,\n            noteType: note.type,\n            title: utils.escapeHtml(title),\n            extraClasses: this.getExtraClasses(note),\n            icon: this.getIcon(note, isFolder),\n            refKey: note.noteId,\n            lazy: true,\n            folder: isFolder,\n            expanded: branch.isExpanded || hoistedNoteId === note.noteId,\n            key: utils.randomString(12) // this should prevent some \"duplicate key\" errors\n        };\n\n        if (node.folder && node.expanded) {\n            node.children = await this.prepareChildren(note);\n        }\n\n        return node;\n    }\n\n    isFolder(note) {\n        if (note.type === 'search') {\n            return true;\n        }\n        else {\n            const childBranches = this.getChildBranches(note);\n\n            return childBranches.length > 0;\n        }\n    }\n\n    async prepareNormalNoteChildren(parentNote) {\n        utils.assertArguments(parentNote);\n\n        const noteList = [];\n\n        const hideArchivedNotes = this.hideArchivedNotes;\n\n        for (const branch of this.getChildBranches(parentNote)) {\n            if (hideArchivedNotes) {\n                const note = await branch.getNote();\n\n                if (note.hasLabel('archived')) {\n                    continue;\n                }\n            }\n\n            const node = await this.prepareNode(branch);\n\n            noteList.push(node);\n        }\n\n        return noteList;\n    }\n\n    getChildBranches(parentNote) {\n        let childBranches = parentNote.getChildBranches();\n\n        if (!childBranches) {\n            ws.logError(`No children for ${parentNote}. This shouldn't happen.`);\n            return;\n        }\n\n        if (this.hideIncludedImages) {\n            const imageLinks = parentNote.getRelations('imageLink');\n\n            // image is already visible in the parent note so no need to display it separately in the book\n            childBranches = childBranches.filter(branch => !imageLinks.find(rel => rel.value === branch.noteId));\n        }\n\n        // we're not checking hideArchivedNotes since that would mean we need to lazy load the child notes\n        // which would seriously slow down everything.\n        // we check this flag only once user chooses to expand the parent. This has the negative consequence that\n        // note may appear as folder but not contain any children when all of them are archived\n\n        return childBranches;\n    }\n\n    async prepareSearchNoteChildren(note) {\n        await treeCache.reloadNotes([note.noteId]);\n\n        const newNote = await treeCache.getNote(note.noteId);\n\n        return await this.prepareNormalNoteChildren(newNote);\n    }\n\n    getExtraClasses(note) {\n        utils.assertArguments(note);\n\n        const extraClasses = [];\n\n        if (note.isProtected) {\n            extraClasses.push(\"protected\");\n        }\n\n        if (note.getParentNoteIds().length > 1) {\n            extraClasses.push(\"multiple-parents\");\n        }\n\n        const cssClass = note.getCssClass();\n\n        if (cssClass) {\n            extraClasses.push(cssClass);\n        }\n\n        extraClasses.push(utils.getNoteTypeClass(note.type));\n\n        if (note.mime) { // some notes should not have mime type (e.g. render)\n            extraClasses.push(utils.getMimeTypeClass(note.mime));\n        }\n\n        if (note.hasLabel('archived')) {\n            extraClasses.push(\"archived\");\n        }\n\n        return extraClasses.join(\" \");\n    }\n\n    /** @return {FancytreeNode[]} */\n    getSelectedNodes(stopOnParents = false) {\n        return this.tree.getSelectedNodes(stopOnParents);\n    }\n\n    /** @return {FancytreeNode[]} */\n    getSelectedOrActiveNodes(node = null) {\n        const nodes = this.getSelectedNodes(true);\n\n        // the node you start dragging should be included even if not selected\n        if (node && !nodes.find(n => n.key === node.key)) {\n            nodes.push(node);\n        }\n\n        if (nodes.length === 0) {\n            nodes.push(this.getActiveNode());\n        }\n\n        return nodes;\n    }\n\n    async setExpandedStatusForSubtree(node, isExpanded) {\n        if (!node) {\n            const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n            node = this.getNodesByNoteId(hoistedNoteId)[0];\n        }\n\n        const {branchIds} = await server.put(`branches/${node.data.branchId}/expanded-subtree/${isExpanded ? 1 : 0}`);\n\n        treeCache.getBranches(branchIds, true).forEach(branch => branch.isExpanded = isExpanded);\n\n        await this.batchUpdate(async () => {\n            await node.load(true);\n\n            if (node.data.noteId !== 'root') { // root is always expanded\n                await node.setExpanded(isExpanded, {noEvents: true});\n            }\n        });\n    }\n\n    async expandTree(node = null) {\n        await this.setExpandedStatusForSubtree(node, true);\n    }\n\n    async collapseTree(node = null) {\n        await this.setExpandedStatusForSubtree(node, false);\n    }\n\n    /**\n     * @return {FancytreeNode|null}\n     */\n    getActiveNode() {\n        return this.tree.getActiveNode();\n    }\n\n    /**\n     * focused & not active node can happen during multiselection where the node is selected\n     * but not activated (its content is not displayed in the detail)\n     * @return {FancytreeNode|null}\n     */\n    getFocusedNode() {\n        return this.tree.getFocusNode();\n    }\n\n    clearSelectedNodes() {\n        for (const selectedNode of this.getSelectedNodes()) {\n            selectedNode.setSelected(false);\n        }\n    }\n\n    async scrollToActiveNoteEvent() {\n        const activeContext = appContext.tabManager.getActiveTabContext();\n\n        if (activeContext && activeContext.notePath) {\n            this.tree.setFocus(true);\n\n            const node = await this.expandToNote(activeContext.notePath);\n\n            await node.makeVisible({scrollIntoView: true});\n            node.setFocus(true);\n        }\n    }\n\n    /** @return {FancytreeNode} */\n    async getNodeFromPath(notePath, expand = false, logErrors = true) {\n        utils.assertArguments(notePath);\n\n        const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n        /** @const {FancytreeNode} */\n        let parentNode = null;\n\n        const runPath = await treeService.getRunPath(notePath, logErrors);\n\n        if (!runPath) {\n            if (logErrors) {\n                console.error(\"Could not find run path for notePath:\", notePath);\n            }\n\n            return;\n        }\n\n        for (const childNoteId of runPath) {\n            if (childNoteId === hoistedNoteId) {\n                // there must be exactly one node with given hoistedNoteId\n                parentNode = this.getNodesByNoteId(childNoteId)[0];\n\n                continue;\n            }\n\n            // we expand only after hoisted note since before then nodes are not actually present in the tree\n            if (parentNode) {\n                if (!parentNode.isLoaded()) {\n                    await parentNode.load();\n                }\n\n                if (expand) {\n                    await parentNode.setExpanded(true);\n\n                    // although previous line should set the expanded status, it seems to happen asynchronously\n                    // so we need to make sure it is set properly before calling updateNode which uses this flag\n                    const branch = treeCache.getBranch(parentNode.data.branchId);\n                    branch.isExpanded = true;\n                }\n\n                this.updateNode(parentNode);\n\n                let foundChildNode = this.findChildNode(parentNode, childNoteId);\n\n                if (!foundChildNode) { // note might be recently created so we'll force reload and try again\n                    await parentNode.load(true);\n\n                    foundChildNode = this.findChildNode(parentNode, childNoteId);\n\n                    if (!foundChildNode) {\n                        if (logErrors) {\n                            ws.logError(`Can't find node for child node of noteId=${childNoteId} for parent of noteId=${parentNode.data.noteId} and hoistedNoteId=${hoistedNoteId}, requested path is ${notePath}`);\n                        }\n\n                        return;\n                    }\n                }\n\n                parentNode = foundChildNode;\n            }\n        }\n\n        return parentNode;\n    }\n\n    /** @return {FancytreeNode} */\n    findChildNode(parentNode, childNoteId) {\n        let foundChildNode = null;\n\n        for (const childNode of parentNode.getChildren()) {\n            if (childNode.data.noteId === childNoteId) {\n                foundChildNode = childNode;\n                break;\n            }\n        }\n\n        return foundChildNode;\n    }\n\n    /** @return {FancytreeNode} */\n    async expandToNote(notePath, logErrors = true) {\n        return this.getNodeFromPath(notePath, true, logErrors);\n    }\n\n    updateNode(node) {\n        const note = treeCache.getNoteFromCache(node.data.noteId);\n        const branch = treeCache.getBranch(node.data.branchId);\n\n        const isFolder = this.isFolder(note);\n        const title = (branch.prefix ? (branch.prefix + \" - \") : \"\") + note.title;\n\n        node.data.isProtected = note.isProtected;\n        node.data.noteType = note.type;\n        node.folder = isFolder;\n        node.icon = this.getIcon(note, isFolder);\n        node.extraClasses = this.getExtraClasses(note);\n        node.title = utils.escapeHtml(title);\n\n        if (node.isExpanded() !== branch.isExpanded) {\n            node.setExpanded(branch.isExpanded, {noEvents: true});\n        }\n\n        node.renderTitle();\n    }\n\n    /** @return {FancytreeNode[]} */\n    getNodesByBranchId(branchId) {\n        utils.assertArguments(branchId);\n\n        const branch = treeCache.getBranch(branchId);\n\n        return this.getNodesByNoteId(branch.noteId).filter(node => node.data.branchId === branchId);\n    }\n\n    /** @return {FancytreeNode[]} */\n    getNodesByNoteId(noteId) {\n        utils.assertArguments(noteId);\n\n        const list = this.tree.getNodesByRef(noteId);\n        return list ? list : []; // if no nodes with this refKey are found, fancy tree returns null\n    }\n\n    // must be event since it's triggered from outside the tree\n    collapseTreeEvent() { this.collapseTree(); }\n\n    isEnabled() {\n        return !!this.tabContext;\n    }\n\n    async refresh() {\n        this.toggleInt(this.isEnabled());\n\n        const oldActiveNode = this.getActiveNode();\n        let oldActiveNodeFocused = false;\n\n        if (oldActiveNode) {\n            oldActiveNodeFocused = oldActiveNode.hasFocus();\n\n            oldActiveNode.setActive(false);\n            oldActiveNode.setFocus(false);\n        }\n\n        if (this.tabContext && this.tabContext.notePath && !this.tabContext.note.isDeleted) {\n            const newActiveNode = await this.getNodeFromPath(this.tabContext.notePath);\n\n            if (newActiveNode) {\n                if (!newActiveNode.isVisible()) {\n                    await this.expandToNote(this.tabContext.notePath);\n                }\n\n                newActiveNode.setActive(true, {noEvents: true, noFocus: !oldActiveNodeFocused});\n                newActiveNode.makeVisible({scrollIntoView: true});\n            }\n        }\n    }\n\n    async refreshSearch() {\n        const activeNode = this.getActiveNode();\n\n        activeNode.load(true);\n        activeNode.setExpanded(true);\n\n        toastService.showMessage(\"Saved search note refreshed.\");\n    }\n\n    async batchUpdate(cb) {\n        try {\n            // disable rendering during update for increased performance\n            this.tree.enableUpdate(false);\n\n            await cb();\n        }\n        finally {\n            this.tree.enableUpdate(true);\n        }\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        const activeNode = this.getActiveNode();\n        const activeNodeFocused = activeNode && activeNode.hasFocus();\n        const nextNode = activeNode ? (activeNode.getNextSibling() || activeNode.getPrevSibling() || activeNode.getParent()) : null;\n        const activeNotePath = activeNode ? treeService.getNotePath(activeNode) : null;\n        const nextNotePath = nextNode ? treeService.getNotePath(nextNode) : null;\n        const activeNoteId = activeNode ? activeNode.data.noteId : null;\n\n        const noteIdsToUpdate = new Set();\n        const noteIdsToReload = new Set();\n\n        for (const attr of loadResults.getAttributes()) {\n            if (attr.type === 'label' && ['iconClass', 'cssClass'].includes(attr.name)) {\n                if (attr.isInheritable) {\n                    noteIdsToReload.add(attr.noteId);\n                }\n                else {\n                    noteIdsToUpdate.add(attr.noteId);\n                }\n            }\n            else if (attr.type === 'relation' && attr.name === 'template') {\n                // missing handling of things inherited from template\n                noteIdsToReload.add(attr.noteId);\n            }\n            else if (attr.type === 'relation' && attr.name === 'imageLink') {\n                const note = treeCache.getNoteFromCache(attr.noteId);\n\n                if (note && note.getChildNoteIds().includes(attr.value)) {\n                    // there's new/deleted imageLink betwen note and its image child - which can show/hide\n                    // the image (if there is a imageLink relation between parent and child then it is assumed to be \"contained\" in the note and thus does not have to be displayed in the tree)\n                    noteIdsToReload.add(attr.noteId);\n                }\n            }\n        }\n\n        for (const branch of loadResults.getBranches()) {\n            for (const node of this.getNodesByBranchId(branch.branchId)) {\n                if (branch.isDeleted) {\n                    if (node.isActive()) {\n                        const newActiveNode = node.getNextSibling()\n                            || node.getPrevSibling()\n                            || node.getParent();\n\n                        if (newActiveNode) {\n                            newActiveNode.setActive(true, {noEvents: true, noFocus: true});\n                        }\n                    }\n\n                    if (node.getParent()) {\n                        node.remove();\n                    }\n\n                    noteIdsToUpdate.add(branch.parentNoteId);\n                }\n                else {\n                    noteIdsToUpdate.add(branch.noteId);\n                }\n            }\n\n            if (!branch.isDeleted) {\n                for (const parentNode of this.getNodesByNoteId(branch.parentNoteId)) {\n                    if (parentNode.isFolder() && !parentNode.isLoaded()) {\n                        continue;\n                    }\n\n                    const found = (parentNode.getChildren() || []).find(child => child.data.noteId === branch.noteId);\n\n                    if (!found) {\n                        noteIdsToReload.add(branch.parentNoteId);\n                    }\n                }\n            }\n        }\n\n        for (const noteId of loadResults.getNoteIds()) {\n            noteIdsToUpdate.add(noteId);\n        }\n\n        await this.batchUpdate(async () => {\n            for (const noteId of noteIdsToReload) {\n                for (const node of this.getNodesByNoteId(noteId)) {\n                    await node.load(true);\n\n                    noteIdsToUpdate.add(noteId);\n                }\n            }\n\n            for (const parentNoteId of loadResults.getNoteReorderings()) {\n                for (const node of this.getNodesByNoteId(parentNoteId)) {\n                    if (node.isLoaded()) {\n                        node.sortChildren((nodeA, nodeB) => {\n                            const branchA = treeCache.branches[nodeA.data.branchId];\n                            const branchB = treeCache.branches[nodeB.data.branchId];\n\n                            if (!branchA || !branchB) {\n                                return 0;\n                            }\n\n                            return branchA.notePosition - branchB.notePosition;\n                        });\n                    }\n                }\n            }\n        });\n\n        // for some reason node update cannot be in the batchUpdate() block (node is not re-rendered)\n        for (const noteId of noteIdsToUpdate) {\n            for (const node of this.getNodesByNoteId(noteId)) {\n                this.updateNode(node);\n            }\n        }\n\n        if (activeNotePath) {\n            let node = await this.expandToNote(activeNotePath, false);\n\n            if (node && node.data.noteId !== activeNoteId) {\n                // if the active note has been moved elsewhere then it won't be found by the path\n                // so we switch to the alternative of trying to find it by noteId\n                const notesById = this.getNodesByNoteId(activeNoteId);\n\n                // if there are multiple clones then we'd rather not activate any one\n                node = notesById.length === 1 ? notesById[0] : null;\n            }\n\n            if (node) {\n                node.setActive(true, {noEvents: true, noFocus: true});\n            }\n            else {\n                // this is used when original note has been deleted and we want to move the focus to the note above/below\n                node = await this.expandToNote(nextNotePath, false);\n\n                if (node) {\n                    await appContext.tabManager.getActiveTabContext().setNote(nextNotePath);\n                }\n            }\n\n            const newActiveNode = this.getActiveNode();\n\n            // return focus if the previously active node was also focused\n            if (newActiveNode && activeNodeFocused) {\n                await newActiveNode.setFocus(true);\n            }\n        }\n    }\n\n    async setExpanded(branchId, isExpanded) {\n        utils.assertArguments(branchId);\n\n        const branch = treeCache.getBranch(branchId);\n        branch.isExpanded = isExpanded;\n\n        await server.put(`branches/${branchId}/expanded/${isExpanded ? 1 : 0}`);\n    }\n\n    async reloadTreeFromCache() {\n        const activeNode = this.getActiveNode();\n\n        const activeNotePath = activeNode !== null ? treeService.getNotePath(activeNode) : null;\n\n        const rootNode = await this.prepareRootNode();\n\n        await this.batchUpdate(async () => {\n            await this.tree.reload([rootNode]);\n        });\n\n        if (activeNotePath) {\n            const node = await this.getNodeFromPath(activeNotePath, true);\n\n            await node.setActive(true, {noEvents: true, noFocus: true});\n        }\n    }\n\n    hoistedNoteChangedEvent() {\n        this.reloadTreeFromCache();\n    }\n\n    treeCacheReloadedEvent() {\n        this.reloadTreeFromCache();\n    }\n\n    async getHotKeys() {\n        const actions = await keyboardActionsService.getActionsForScope('note-tree');\n        const hotKeyMap = {\n            // code below shouldn't be necessary normally, however there's some problem with interaction with context menu plugin\n            // after opening context menu, standard shortcuts don't work, but they are detected here\n            // so we essentially takeover the standard handling with our implementation.\n            \"left\": node => {\n                node.navigate($.ui.keyCode.LEFT, true);\n                this.clearSelectedNodes();\n\n                return false;\n            },\n            \"right\": node => {\n                node.navigate($.ui.keyCode.RIGHT, true);\n                this.clearSelectedNodes();\n\n                return false;\n            },\n            \"up\": node => {\n                node.navigate($.ui.keyCode.UP, true);\n                this.clearSelectedNodes();\n\n                return false;\n            },\n            \"down\": node => {\n                node.navigate($.ui.keyCode.DOWN, true);\n                this.clearSelectedNodes();\n\n                return false;\n            }\n        };\n\n        for (const action of actions) {\n            for (const shortcut of action.effectiveShortcuts) {\n                hotKeyMap[utils.normalizeShortcut(shortcut)] = node => {\n                    this.triggerCommand(action.actionName, {node});\n\n                    return false;\n                }\n            }\n        }\n\n        return hotKeyMap;\n    }\n\n    /**\n     * @param {FancytreeNode} node\n     */\n    getSelectedOrActiveBranchIds(node) {\n        const nodes = this.getSelectedOrActiveNodes(node);\n\n        return nodes.map(node => node.data.branchId);\n    }\n\n    async deleteNotesCommand({node}) {\n        const branchIds = this.getSelectedOrActiveBranchIds(node);\n\n        await branchService.deleteNotes(branchIds);\n\n        this.clearSelectedNodes();\n    }\n\n    moveNoteUpCommand({node}) {\n        const beforeNode = node.getPrevSibling();\n\n        if (beforeNode !== null) {\n            branchService.moveBeforeBranch([node.data.branchId], beforeNode.data.branchId);\n        }\n    }\n\n    moveNoteDownCommand({node}) {\n        const afterNode = node.getNextSibling();\n        if (afterNode !== null) {\n            branchService.moveAfterBranch([node.data.branchId], afterNode.data.branchId);\n        }\n    }\n\n    moveNoteUpInHierarchyCommand({node}) {\n        branchService.moveNodeUpInHierarchy(node);\n    }\n\n    moveNoteDownInHierarchyCommand({node}) {\n        const toNode = node.getPrevSibling();\n\n        if (toNode !== null) {\n            branchService.moveToParentNote([node.data.branchId], toNode.data.branchId);\n        }\n    }\n\n    addNoteAboveToSelectionCommand() {\n        const node = this.getFocusedNode();\n\n        if (!node) {\n            return;\n        }\n\n        if (node.isActive()) {\n            node.setSelected(true);\n        }\n\n        const prevSibling = node.getPrevSibling();\n\n        if (prevSibling) {\n            prevSibling.setActive(true, {noEvents: true});\n\n            if (prevSibling.isSelected()) {\n                node.setSelected(false);\n            }\n\n            prevSibling.setSelected(true);\n        }\n    }\n\n    addNoteBelowToSelectionCommand() {\n        const node = this.getFocusedNode();\n\n        if (!node) {\n            return;\n        }\n\n        if (node.isActive()) {\n            node.setSelected(true);\n        }\n\n        const nextSibling = node.getNextSibling();\n\n        if (nextSibling) {\n            nextSibling.setActive(true, {noEvents: true});\n\n            if (nextSibling.isSelected()) {\n                node.setSelected(false);\n            }\n\n            nextSibling.setSelected(true);\n        }\n    }\n\n    expandSubtreeCommand({node}) {\n        this.expandTree(node);\n    }\n\n    collapseSubtreeCommand({node}) {\n        this.collapseTree(node);\n    }\n\n    sortChildNotesCommand({node}) {\n        treeService.sortAlphabetically(node.data.noteId);\n    }\n\n    async recentChangesInSubtreeCommand({node}) {\n        const recentChangesDialog = await import('../dialogs/recent_changes.js');\n\n        recentChangesDialog.showDialog(node.data.noteId);\n    }\n\n    selectAllNotesInParentCommand({node}) {\n        for (const child of node.getParent().getChildren()) {\n            child.setSelected(true);\n        }\n    }\n\n    copyNotesToClipboardCommand({node}) {\n        clipboard.copy(this.getSelectedOrActiveBranchIds(node));\n    }\n\n    cutNotesToClipboardCommand({node}) {\n        clipboard.cut(this.getSelectedOrActiveBranchIds(node));\n    }\n\n    pasteNotesFromClipboardCommand({node}) {\n        clipboard.pasteInto(node.data.branchId);\n    }\n\n    pasteNotesAfterFromClipboard({node}) {\n        clipboard.pasteAfter(node.data.branchId);\n    }\n\n    async exportNoteCommand({node}) {\n        const exportDialog = await import('../dialogs/export.js');\n        const notePath = treeService.getNotePath(node);\n\n        exportDialog.showDialog(notePath,\"subtree\");\n    }\n\n    async importIntoNoteCommand({node}) {\n        const importDialog = await import('../dialogs/import.js');\n        importDialog.showDialog(node.data.noteId);\n    }\n\n    forceNoteSyncCommand({node}) {\n        syncService.forceNoteSync(node.data.noteId);\n    }\n\n    editNoteTitleCommand({node}) {\n        appContext.triggerCommand('focusOnTitle');\n    }\n\n    activateParentNoteCommand({node}) {\n        if (!hoistedNoteService.isRootNode(node)) {\n            node.getParent().setActive().then(this.clearSelectedNodes);\n        }\n    }\n\n    protectSubtreeCommand({node}) {\n        protectedSessionService.protectNote(node.data.noteId, true, true);\n    }\n\n    unprotectSubtreeCommand({node}) {\n        protectedSessionService.protectNote(node.data.noteId, false, true);\n    }\n\n    duplicateNoteCommand({node}) {\n        const branch = treeCache.getBranch(node.data.branchId);\n\n        noteCreateService.duplicateNote(node.data.noteId, branch.parentNoteId);\n    }\n}\n","import BasicWidget from \"../basic_widget.js\";\n\nconst WIDGET_TPL = `\n<div id=\"global-buttons\">\n    <style>\n    #global-buttons {\n        display: flex;\n        flex-shrink: 0;\n        justify-content: space-around;\n        padding: 3px 0 3px 0;\n        margin: 0 10px 0 16px;\n        font-size: larger;\n    }\n    </style>\n\n    <a data-trigger-command=\"createTopLevelNote\" title=\"Create new top level note\" class=\"icon-action bx bx-folder-plus\"></a>\n\n    <a data-trigger-command=\"collapseTree\" title=\"Collapse note tree\" class=\"icon-action bx bx-layer-minus\"></a>\n\n    <a data-trigger-command=\"scrollToActiveNote\" title=\"Scroll to active note\" class=\"icon-action bx bx-crosshair\"></a>\n\n    <div class=\"dropdown\">\n        <a title=\"Global actions\" class=\"icon-action bx bx-cog dropdown-toggle\" data-toggle=\"dropdown\"></a>\n\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item\" data-trigger-command=\"switchToDesktopVersion\"><span class=\"bx bx-laptop\"></span> Switch to desktop version</a>\n            <a class=\"dropdown-item\" data-trigger-command=\"logout\"><span class=\"bx bx-log-out\"></span> Logout</a>\n        </div>\n    </div>\n</div>\n`;\n\nclass MobileGlobalButtonsWidget extends BasicWidget {\n    doRender() {\n        return this.$widget = $(WIDGET_TPL);\n    }\n}\n\nexport default MobileGlobalButtonsWidget;","import BasicWidget from \"../basic_widget.js\";\n\nconst TPL = `\n<button type=\"button\" class=\"action-button d-sm-none d-md-none d-lg-none d-xl-none\" aria-label=\"Close\">\n    <span aria-hidden=\"true\">&times;</span>\n</button>`;\n\nclass CloseDetailButtonWidget extends BasicWidget {\n    doRender() {\n        this.$widget = $(TPL);\n\n        this.$widget.on('click', () => this.triggerCommand('setActiveScreen', {screen:'tree'}));\n\n        return this.$widget;\n    }\n}\n\nexport default CloseDetailButtonWidget;","import BasicWidget from \"../basic_widget.js\";\nimport appContext from \"../../services/app_context.js\";\nimport contextMenu from \"../../services/context_menu.js\";\nimport noteCreateService from \"../../services/note_create.js\";\nimport branchService from \"../../services/branches.js\";\n\nconst TPL = `<button type=\"button\" class=\"action-button bx bx-menu\"></button>`;\n\nclass MobileDetailMenuWidget extends BasicWidget {\n    doRender() {\n        this.$widget = $(TPL);\n\n        this.$widget.on(\"click\", async e => {\n            const note = appContext.tabManager.getActiveTabNote();\n\n            contextMenu.show({\n                x: e.pageX,\n                y: e.pageY,\n                items: [\n                    { title: \"Insert child note\", command: \"insertChildNote\", uiIcon: \"plus\",\n                        enabled: note.type !== 'search' },\n                    { title: \"Delete this note\", command: \"delete\", uiIcon: \"trash\",\n                        enabled: note.noteId !== 'root' }\n                ],\n                selectMenuItemHandler: async ({command}) => {\n                    if (command === \"insertChildNote\") {\n                        noteCreateService.createNote(note.noteId);\n                    }\n                    else if (command === \"delete\") {\n                        if (await branchService.deleteNotes(note.getBranchIds()[0])) {\n                            // move to the tree\n                            togglePanes();\n                        }\n                    }\n                    else {\n                        throw new Error(\"Unrecognized command \" + command);\n                    }\n                }\n            });\n        });\n\n        return this.$widget;\n    }\n}\n\nexport default MobileDetailMenuWidget;","import FlexContainer from \"../flex_container.js\";\n\nexport default class ScreenContainer extends FlexContainer {\n    constructor(screenName, direction) {\n        super(direction);\n\n        this.screenName = screenName;\n    }\n\n    activeScreenChangedEvent({activeScreen}) {\n        if (activeScreen === this.screenName) {\n            this.$widget.removeClass('d-none');\n        }\n        else {\n            this.$widget.addClass('d-none');\n        }\n    }\n}","import utils from \"./utils.js\";\nimport appContext from \"./app_context.js\";\nimport server from \"./server.js\";\nimport libraryLoader from \"./library_loader.js\";\nimport ws from \"./ws.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport treeCache from \"./tree_cache.js\";\n\nfunction setupGlobs() {\n    window.glob.PROFILING_LOG = false;\n\n    window.glob.isDesktop = utils.isDesktop;\n    window.glob.isMobile = utils.isMobile;\n\n    window.glob.getComponentByEl = el => appContext.getComponentByEl(el);\n    window.glob.getHeaders = server.getHeaders;\n\n    // required for ESLint plugin and CKEditor\n    window.glob.getActiveTabNote = () => appContext.tabManager.getActiveTabNote();\n    window.glob.requireLibrary = libraryLoader.requireLibrary;\n    window.glob.ESLINT = libraryLoader.ESLINT;\n    window.glob.appContext = appContext; // for debugging\n    window.glob.treeCache = treeCache;\n\n    // for CKEditor integration (button on block toolbar)\n    window.glob.importMarkdownInline = async () => {\n        const dialog = await import(\"../dialogs/markdown_import.js\");\n\n        dialog.importMarkdownInline();\n    };\n\n    window.glob.SEARCH_HELP_TEXT = `\n    <strong>Search tips</strong> - also see <button class=\"btn btn-sm\" type=\"button\" data-help-page=\"Search\">complete help on search</button>\n    <p>\n    <ul>\n        <li>Just enter any text for full text search</li>\n        <li><code>@abc</code> - returns notes with label abc</li>\n        <li><code>@year=2019</code> - matches notes with label <code>year</code> having value <code>2019</code></li>\n        <li><code>@rock @pop</code> - matches notes which have both <code>rock</code> and <code>pop</code> labels</li>\n        <li><code>@rock or @pop</code> - only one of the labels must be present</li>\n        <li><code>@year&lt;=2000</code> - numerical comparison (also &gt;, &gt;=, &lt;).</li>\n        <li><code>@dateCreated>=MONTH-1</code> - notes created in the last month</li>\n        <li><code>=handler</code> - will execute script defined in <code>handler</code> relation to get results</li>\n    </ul>\n    </p>`;\n\n    window.onerror = function (msg, url, lineNo, columnNo, error) {\n        const string = msg.toLowerCase();\n\n        let message = \"Uncaught error: \";\n\n        if (string.includes(\"script error\")) {\n            message += 'No details available';\n        } else {\n            message += [\n                'Message: ' + msg,\n                'URL: ' + url,\n                'Line: ' + lineNo,\n                'Column: ' + columnNo,\n                'Error object: ' + JSON.stringify(error),\n                'Stack: ' + error && error.stack\n            ].join(', ');\n        }\n\n        ws.logError(message);\n\n        return false;\n    };\n\n    protectedSessionHolder.setProtectedSessionId(null);\n\n    for (const appCssNoteId of glob.appCssNoteIds || []) {\n        libraryLoader.requireCss(`api/notes/download/${appCssNoteId}`);\n    }\n\n    const wikiBaseUrl = \"https://github.com/zadam/trilium/wiki/\";\n\n    $(document).on(\"click\", \"button[data-help-page]\", e => {\n        const $button = $(e.target);\n\n        window.open(wikiBaseUrl + $button.attr(\"data-help-page\"), '_blank');\n    });\n\n    $(\"body\").on(\"click\", \"a.external\", function () {\n        window.open($(this).attr(\"href\"), '_blank');\n    });\n}\n\nexport default {\n    setupGlobs\n}\n","import appContext from \"./services/app_context.js\";\nimport MobileLayout from \"./layouts/mobile_layout.js\";\nimport glob from \"./services/glob.js\";\n\nglob.setupGlobs();\n\nappContext.setLayout(new MobileLayout());\nappContext.start();","import FlexContainer from \"../widgets/flex_container.js\";\nimport NoteTitleWidget from \"../widgets/note_title.js\";\nimport NoteDetailWidget from \"../widgets/note_detail.js\";\nimport NoteTreeWidget from \"../widgets/note_tree.js\";\nimport MobileGlobalButtonsWidget from \"../widgets/mobile_widgets/mobile_global_buttons.js\";\nimport CloseDetailButtonWidget from \"../widgets/mobile_widgets/close_detail_button.js\";\nimport MobileDetailMenuWidget from \"../widgets/mobile_widgets/mobile_detail_menu.js\";\nimport ScreenContainer from \"../widgets/mobile_widgets/screen_container.js\";\n\nconst MOBILE_CSS = `\n<style>\nkbd {\n    display: none;\n}\n\n.dropdown-menu {\n    font-size: larger;\n}\n\n.action-button {\n    background: none;\n    border: none;\n    cursor: pointer;\n    font-size: 1.5em;\n    padding-left: 0.5em;\n    padding-right: 0.5em;\n}\n</style>`;\n\nconst FANCYTREE_CSS = `\n<style>\n.fancytree-custom-icon {\n    font-size: 2em;\n}\n\n.fancytree-title {\n    font-size: 1.5em;\n    margin-left: 0.6em !important;\n}\n\n.fancytree-node {\n    padding: 5px;\n}\n\n.fancytree-node .fancytree-expander:before {\n    font-size: 2em !important;\n}\n\nspan.fancytree-expander {\n    width: 24px !important;\n}\n\n.fancytree-loading span.fancytree-expander {\n    width: 24px;\n    height: 32px;\n}\n\n.fancytree-loading  span.fancytree-expander:after {\n    width: 20px;\n    height: 20px;\n    margin-top: 4px;\n    border-width: 2px;\n    border-style: solid;\n}\n</style>`;\n\nexport default class MobileLayout {\n    getRootWidget(appContext) {\n        return new FlexContainer('row').cssBlock(MOBILE_CSS)\n            .setParent(appContext)\n            .id('root-widget')\n            .css('height', '100vh')\n            .child(new ScreenContainer(\"tree\", 'column')\n                .class(\"d-sm-flex d-md-flex d-lg-flex d-xl-flex col-12 col-sm-5 col-md-4 col-lg-4 col-xl-4\")\n                .child(new MobileGlobalButtonsWidget())\n                .child(new NoteTreeWidget(\"main\").cssBlock(FANCYTREE_CSS)))\n            .child(new ScreenContainer(\"detail\", \"column\")\n                .class(\"d-sm-flex d-md-flex d-lg-flex d-xl-flex col-12 col-sm-7 col-md-8 col-lg-8\")\n                .child(new FlexContainer('row')\n                    .child(new MobileDetailMenuWidget())\n                    .child(new NoteTitleWidget()\n                        .css('padding', '10px')\n                        .css('font-size', 'larger'))\n                    .child(new CloseDetailButtonWidget()))\n                .child(new NoteDetailWidget()\n                    .css('padding', '5px 20px 10px 0')));\n    }\n}"],"sourceRoot":""}