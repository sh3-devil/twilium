{"version":3,"sources":["webpack://trilium/./src/public/app/dialogs/move_to.js","webpack://trilium/./src/public/app/services/branches.js","webpack://trilium/./src/public/app/services/note_autocomplete.js"],"names":["$dialog","$","$form","$noteAutoComplete","$noteList","movedBranchIds","async","showDialog","branchIds","val","trigger","empty","branchId","branch","note","noteId","append","text","title","on","notePath","getSelectedPath","modal","parentNoteId","then","parentBranchId","parentBranch","parentNote","getNote","moveNotesTo","console","error","filterRootNote","hoistedNoteId","filter","makeToast","id","message","icon","taskType","type","taskId","progressCount","toast","closeAfter","moveBeforeBranch","branchIdsToMove","beforeBranchId","branchIdToMove","resp","success","alert","moveAfterBranch","afterBranchId","afterNote","reverse","moveToParentNote","newParentBranchId","branchToMove","getParentNote","deleteNotes","branchIdsToDelete","length","$deleteClonesCheckbox","attr","$nodeTitles","$confirmText","confirmDialog","confirm","deleteClones","find","is","counter","branchIdToDelete","query","moveNodeUpInHierarchy","node","getParent","data","noteType","getChildren","folder","renderTitle","cloneNoteAfter","cloneNoteTo","childNoteId","prefix","autocompleteSource","term","cb","result","encodeURIComponent","push","pathTitle","path","clearText","$el","setSelectedPath","autocomplete","showRecentNotes","initNoteAutocomplete","options","hasClass","addClass","$clearTextButton","prop","$showRecentNotesButton","$goToSelectedNoteButton","$sideButtons","hideGoToSelectedNoteButton","after","e","appendTo","document","querySelector","hint","autoselect","openOnFocus","minLength","tabAutocomplete","source","displayKey","templates","suggestion","highlightedTitle","cache","event","trim","init","fn","this","closest","toggleClass"],"mappings":"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","file":"704.setup.js","sourcesContent":["import noteAutocompleteService from \"../services/note_autocomplete.js\";\nimport utils from \"../services/utils.js\";\nimport toastService from \"../services/toast.js\";\nimport treeCache from \"../services/tree_cache.js\";\nimport branchService from \"../services/branches.js\";\nimport treeService from \"../services/tree.js\";\n\nconst $dialog = $(\"#move-to-dialog\");\nconst $form = $(\"#move-to-form\");\nconst $noteAutoComplete = $(\"#move-to-note-autocomplete\");\nconst $noteList = $(\"#move-to-note-list\");\n\nlet movedBranchIds;\n\nexport async function showDialog(branchIds) {\n    movedBranchIds = branchIds;\n\n    utils.openDialog($dialog);\n\n    $noteAutoComplete.val('').trigger('focus');\n\n    $noteList.empty();\n\n    for (const branchId of movedBranchIds) {\n        const branch = treeCache.getBranch(branchId);\n        const note = await treeCache.getNote(branch.noteId);\n\n        $noteList.append($(\"<li>\").text(note.title));\n    }\n\n    noteAutocompleteService.initNoteAutocomplete($noteAutoComplete);\n    noteAutocompleteService.showRecentNotes($noteAutoComplete);\n}\n\nasync function moveNotesTo(parentBranchId) {\n    await branchService.moveToParentNote(movedBranchIds, parentBranchId);\n\n    const parentBranch = treeCache.getBranch(parentBranchId);\n    const parentNote = await parentBranch.getNote();\n\n    toastService.showMessage(`Selected notes have been moved into ${parentNote.title}`);\n}\n\n$form.on('submit', () => {\n    const notePath = $noteAutoComplete.getSelectedPath();\n\n    if (notePath) {\n        $dialog.modal('hide');\n\n        const {noteId, parentNoteId} = treeService.getNoteIdAndParentIdFromNotePath(notePath);\n        treeCache.getBranchId(parentNoteId, noteId).then(branchId => moveNotesTo(branchId));\n    }\n    else {\n        console.error(\"No path to move to.\");\n    }\n\n    return false;\n});\n","import utils from './utils.js';\nimport server from './server.js';\nimport toastService from \"./toast.js\";\nimport treeCache from \"./tree_cache.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport ws from \"./ws.js\";\n\nasync function moveBeforeBranch(branchIdsToMove, beforeBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    if (beforeBranchId === 'root') {\n        alert('Cannot move notes before root note.');\n        return;\n    }\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const resp = await server.put(`branches/${branchIdToMove}/move-before/${beforeBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function moveAfterBranch(branchIdsToMove, afterBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    const afterNote = await treeCache.getBranch(afterBranchId).getNote();\n\n    if (afterNote.noteId === 'root' || afterNote.noteId === hoistedNoteService.getHoistedNoteId()) {\n        alert('Cannot move notes after root note.');\n        return;\n    }\n\n    branchIdsToMove.reverse(); // need to reverse to keep the note order\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const resp = await server.put(`branches/${branchIdToMove}/move-after/${afterBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function moveToParentNote(branchIdsToMove, newParentBranchId) {\n    branchIdsToMove = filterRootNote(branchIdsToMove);\n\n    for (const branchIdToMove of branchIdsToMove) {\n        const branchToMove = treeCache.getBranch(branchIdToMove);\n\n        if (branchToMove.noteId === hoistedNoteService.getHoistedNoteId()\n            || (await branchToMove.getParentNote()).type === 'search') {\n            continue;\n        }\n\n        const resp = await server.put(`branches/${branchIdToMove}/move-to/${newParentBranchId}`);\n\n        if (!resp.success) {\n            alert(resp.message);\n            return;\n        }\n    }\n}\n\nasync function deleteNotes(branchIdsToDelete) {\n    branchIdsToDelete = filterRootNote(branchIdsToDelete);\n\n    if (branchIdsToDelete.length === 0) {\n        return false;\n    }\n\n    const $deleteClonesCheckbox = $('<div class=\"form-check\">')\n        .append($('<input type=\"checkbox\" class=\"form-check-input\" id=\"delete-clones-checkbox\">'))\n        .append($('<label for=\"delete-clones-checkbox\">')\n                    .text(\"delete also all note clones\")\n                    .attr(\"title\", \"all clones of selected notes will be deleted and as such the whole note will be deleted.\"));\n\n    const $nodeTitles = $(\"<ul>\");\n\n    for (const branchId of branchIdsToDelete) {\n        const note = await treeCache.getBranch(branchId).getNote();\n\n        $nodeTitles.append($(\"<li>\").text(note.title));\n    }\n\n    const $confirmText = $(\"<div>\")\n        .append($(\"<p>\").text('This will delete the following notes and their sub-notes: '))\n        .append($nodeTitles)\n        .append($deleteClonesCheckbox);\n\n    const confirmDialog = await import('../dialogs/confirm.js');\n\n    if (!await confirmDialog.confirm($confirmText)) {\n        return false;\n    }\n\n    const deleteClones = $deleteClonesCheckbox.find(\"input\").is(\":checked\");\n\n    const taskId = utils.randomString(10);\n\n    let counter = 0;\n\n    for (const branchIdToDelete of branchIdsToDelete) {\n        counter++;\n\n        const last = counter === branchIdsToDelete.length;\n        const query = `?taskId=${taskId}&last=${last ? 'true' : 'false'}`;\n\n        const branch = treeCache.getBranch(branchIdToDelete);\n\n        if (deleteClones) {\n            await server.remove(`notes/${branch.noteId}` + query);\n        }\n        else {\n            await server.remove(`branches/${branchIdToDelete}` + query);\n        }\n    }\n\n    return true;\n}\n\nasync function moveNodeUpInHierarchy(node) {\n    if (hoistedNoteService.isRootNode(node)\n        || hoistedNoteService.isTopLevelNode(node)\n        || node.getParent().data.noteType === 'search') {\n        return;\n    }\n\n    const resp = await server.put('branches/' + node.data.branchId + '/move-after/' + node.getParent().data.branchId);\n\n    if (!resp.success) {\n        alert(resp.message);\n        return;\n    }\n\n    if (!hoistedNoteService.isTopLevelNode(node) && node.getParent().getChildren().length <= 1) {\n        node.getParent().folder = false;\n        node.getParent().renderTitle();\n    }\n}\n\nfunction filterRootNote(branchIds) {\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    return branchIds.filter(branchId => {\n       const branch = treeCache.getBranch(branchId);\n\n        return branch.noteId !== 'root'\n            && branch.noteId !== hoistedNoteId;\n    });\n}\n\nfunction makeToast(id, message) {\n    return {\n        id: id,\n        title: \"Delete status\",\n        message: message,\n        icon: \"trash\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'delete-notes') {\n        return;\n    }\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message.taskId, \"Delete notes in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message.taskId, \"Delete finished successfully.\");\n        toast.closeAfter = 5000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'undelete-notes') {\n        return;\n    }\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message.taskId, \"Undeleting notes in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message.taskId, \"Undeleting notes finished successfully.\");\n        toast.closeAfter = 5000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nasync function cloneNoteTo(childNoteId, parentBranchId, prefix) {\n    const resp = await server.put(`notes/${childNoteId}/clone-to/${parentBranchId}`, {\n        prefix: prefix\n    });\n\n    if (!resp.success) {\n        alert(resp.message);\n    }\n}\n\n// beware that first arg is noteId and second is branchId!\nasync function cloneNoteAfter(noteId, afterBranchId) {\n    const resp = await server.put('notes/' + noteId + '/clone-after/' + afterBranchId);\n\n    if (!resp.success) {\n        alert(resp.message);\n    }\n}\n\nexport default {\n    moveBeforeBranch,\n    moveAfterBranch,\n    moveToParentNote,\n    deleteNotes,\n    moveNodeUpInHierarchy,\n    cloneNoteAfter,\n    cloneNoteTo\n};\n","import server from \"./server.js\";\nimport appContext from \"./app_context.js\";\nimport utils from './utils.js';\n\n// this key needs to have this value so it's hit by the tooltip\nconst SELECTED_PATH_KEY = \"data-note-path\";\n\nasync function autocompleteSource(term, cb) {\n    const result = await server.get('autocomplete'\n        + '?query=' + encodeURIComponent(term)\n        + '&activeNoteId=' + appContext.tabManager.getActiveTabNoteId());\n\n    if (result.length === 0) {\n        result.push({\n            pathTitle: \"No results\",\n            path: \"\"\n        });\n    }\n\n    cb(result);\n}\n\nfunction clearText($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\").trigger('change');\n}\n\nfunction showRecentNotes($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\");\n    $el.trigger('focus');\n}\n\nfunction initNoteAutocomplete($el, options) {\n    if ($el.hasClass(\"note-autocomplete-input\") || utils.isMobile()) {\n        return $el;\n    }\n\n    options = options || {};\n\n    $el.addClass(\"note-autocomplete-input\");\n\n    const $clearTextButton = $(\"<a>\")\n            .addClass(\"input-group-text input-clearer-button bx bx-x\")\n            .prop(\"title\", \"Clear text field\");\n\n    const $showRecentNotesButton = $(\"<a>\")\n            .addClass(\"input-group-text show-recent-notes-button bx bx-time\")\n            .prop(\"title\", \"Show recent notes\");\n\n    const $goToSelectedNoteButton = $(\"<a>\")\n        .addClass(\"input-group-text go-to-selected-note-button bx bx-arrow-to-right\")\n        .attr(\"data-action\", \"note\");\n\n    const $sideButtons = $(\"<div>\")\n        .addClass(\"input-group-append\")\n        .append($clearTextButton)\n        .append($showRecentNotesButton);\n\n    if (!options.hideGoToSelectedNoteButton) {\n        $sideButtons.append($goToSelectedNoteButton);\n    }\n\n    $el.after($sideButtons);\n\n    $clearTextButton.on('click', () => clearText($el));\n\n    $showRecentNotesButton.on('click', e => {\n        showRecentNotes($el);\n\n        // this will cause the click not give focus to the \"show recent notes\" button\n        // this is important because otherwise input will lose focus immediatelly and not show the results\n        return false;\n    });\n\n    $el.autocomplete({\n        appendTo: document.querySelector('body'),\n        hint: false,\n        autoselect: true,\n        openOnFocus: true,\n        minLength: 0,\n        tabAutocomplete: false\n    }, [\n        {\n            source: autocompleteSource,\n            displayKey: 'pathTitle',\n            templates: {\n                suggestion: function(suggestion) {\n                    return suggestion.highlightedTitle;\n                }\n            },\n            // we can't cache identical searches because notes can be created / renamed, new recent notes can be added\n            cache: false\n        }\n    ]);\n\n    $el.on('autocomplete:selected', (event, suggestion) => $el.setSelectedPath(suggestion.path));\n    $el.on('autocomplete:closed', () => {\n        if (!$el.val().trim()) {\n            clearText($el);\n        }\n    });\n\n    return $el;\n}\n\nfunction init() {\n    $.fn.getSelectedPath = function () {\n        if (!$(this).val().trim()) {\n            return \"\";\n        } else {\n            return $(this).attr(SELECTED_PATH_KEY);\n        }\n    };\n\n    $.fn.setSelectedPath = function (path) {\n        path = path || \"\";\n\n        $(this).attr(SELECTED_PATH_KEY, path);\n\n        $(this)\n            .closest(\".input-group\")\n            .find(\".go-to-selected-note-button\")\n            .toggleClass(\"disabled\", !path.trim())\n            .attr(SELECTED_PATH_KEY, path); // we also set attr here so tooltip can be displayed\n    };\n}\n\nexport default {\n    autocompleteSource,\n    initNoteAutocomplete,\n    showRecentNotes,\n    init\n}"],"sourceRoot":""}