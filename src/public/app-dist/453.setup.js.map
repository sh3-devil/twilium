{"version":3,"sources":["webpack://trilium/./src/public/app/services/attribute_autocomplete.js","webpack://trilium/./src/public/app/dialogs/attributes.js","webpack://trilium/./src/public/app/services/library_loader.js","webpack://trilium/./src/public/app/services/note_autocomplete.js"],"names":["initAttributeNameAutocomplete","$el","attributeType","open","hasClass","autocomplete","appendTo","document","querySelector","hint","openOnFocus","minLength","tabAutocomplete","displayKey","cache","source","async","term","cb","type","server","encodeURIComponent","map","name","initLabelValueAutocomplete","attributeName","parent","find","val","trim","attributeValues","attribute","value","length","toLowerCase","filter","attr","includes","$dialog","$","$saveAttributesButton","$ownedAttributesBody","AttributesModel","self","this","showAttributes","noteId","attributes","ownedAttributes","labelValue","relationValue","tree","selectedPath","labelDefinition","labelType","multiplicityType","isPromoted","numberPrecision","relationDefinition","inverseRelation","ko","observable","addLastEmptyRow","inheritedAttributes","isDeleted","last","push","attributeId","isInheritable","position","observableArray","availableTypes","text","availableLabelTypes","multiplicityTypes","typeChanged","data","event","getTargetAttribute","target","valueHasMutated","labelTypeChanged","updateAttributePositions","each","loadAttributes","setTimeout","trigger","deleteAttribute","attributeData","save","i","isEmptyName","isEmptyRelationTarget","isValid","alert","attributesToSave","JSON","stringify","toast","attributeChanged","index","cur","contextFor","$index","attributesModel","showDialog","bindingHandlers","noteLink","init","element","valueAccessor","allBindings","viewModel","bindingContext","unwrap","link","append","noteAutocomplete","setSelectedPath","$data","on","suggestion","dataset","path","applyBindings","utils","e","loadedScriptPromises","requireScript","url","ajax","dataType","requireCss","Array","from","querySelectorAll","el","href","some","l","endsWith","requireLibrary","library","css","cssUrl","js","scriptUrl","CKEDITOR","CODE_MIRROR","ESLINT","COMMONMARK","RELATION_MAP","LINK_MAP","PRINT_THIS","KNOCKOUT","CALENDAR_WIDGET","autocompleteSource","result","pathTitle","clearText","showRecentNotes","initNoteAutocomplete","options","addClass","$clearTextButton","prop","$showRecentNotesButton","$goToSelectedNoteButton","$sideButtons","hideGoToSelectedNoteButton","after","autoselect","templates","highlightedTitle","fn","getSelectedPath","closest","toggleClass"],"mappings":"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","file":"453.setup.js","sourcesContent":["import server from \"./server.js\";\n\n/**\n * @param $el - element on which to init autocomplete\n * @param attributeType - \"relation\" or \"label\" or callback providing one of those values as a type of autocompleted attributes\n * @param open - should the autocomplete be opened after init?\n */\nfunction initAttributeNameAutocomplete({ $el, attributeType, open }) {\n    if (!$el.hasClass(\"aa-input\")) {\n        $el.autocomplete({\n            appendTo: document.querySelector('body'),\n            hint: false,\n            openOnFocus: true,\n            minLength: 0,\n            tabAutocomplete: false\n        }, [{\n            displayKey: 'name',\n            // disabling cache is important here because otherwise cache can stay intact when switching between attribute type which will lead to autocomplete displaying attribute names for incorrect attribute type\n            cache: false,\n            source: async (term, cb) => {\n                const type = typeof attributeType === \"function\" ? attributeType() : attributeType;\n\n                const names = await server.get(`attributes/names/?type=${type}&query=${encodeURIComponent(term)}`);\n                const result = names.map(name => ({name}));\n\n                cb(result);\n            }\n        }]);\n    }\n\n    if (open) {\n        $el.autocomplete(\"open\");\n    }\n}\n\nasync function initLabelValueAutocomplete({ $el, open }) {\n    if (!$el.hasClass(\"aa-input\")) {\n        const attributeName = $el.parent().parent().find('.attribute-name').val();\n\n        if (attributeName.trim() === \"\") {\n            return;\n        }\n\n        const attributeValues = (await server.get('attributes/values/' + encodeURIComponent(attributeName)))\n            .map(attribute => ({ value: attribute }));\n\n        if (attributeValues.length === 0) {\n            return;\n        }\n\n        $el.autocomplete({\n            appendTo: document.querySelector('body'),\n            hint: false,\n            openOnFocus: true,\n            minLength: 0,\n            tabAutocomplete: false\n        }, [{\n            displayKey: 'value',\n            source: function (term, cb) {\n                term = term.toLowerCase();\n\n                const filtered = attributeValues.filter(attr => attr.value.toLowerCase().includes(term));\n\n                cb(filtered);\n            }\n        }]);\n    }\n\n    if (open) {\n        $el.autocomplete(\"open\");\n    }\n}\n\nexport default {\n    initAttributeNameAutocomplete,\n    initLabelValueAutocomplete\n}","import server from '../services/server.js';\nimport toastService from \"../services/toast.js\";\nimport treeService from \"../services/tree.js\";\nimport attributeAutocompleteService from \"../services/attribute_autocomplete.js\";\nimport utils from \"../services/utils.js\";\nimport linkService from \"../services/link.js\";\nimport libraryLoader from \"../services/library_loader.js\";\nimport noteAutocompleteService from \"../services/note_autocomplete.js\";\nimport appContext from \"../services/app_context.js\";\n\nconst $dialog = $(\"#attributes-dialog\");\nconst $saveAttributesButton = $(\"#save-attributes-button\");\nconst $ownedAttributesBody = $('#owned-attributes-table tbody');\n\nfunction AttributesModel() {\n    const self = this;\n\n    this.ownedAttributes = ko.observableArray();\n    this.inheritedAttributes = ko.observableArray();\n\n    this.availableTypes = [\n        { text: \"Label\", value: \"label\" },\n        { text: \"Label definition\", value: \"label-definition\" },\n        { text: \"Relation\", value: \"relation\" },\n        { text: \"Relation definition\", value: \"relation-definition\" }\n    ];\n\n    this.availableLabelTypes = [\n        { text: \"Text\", value: \"text\" },\n        { text: \"Number\", value: \"number\" },\n        { text: \"Boolean\", value: \"boolean\" },\n        { text: \"Date\", value: \"date\" },\n        { text: \"URL\", value: \"url\"}\n    ];\n\n    this.multiplicityTypes = [\n        { text: \"Single value\", value: \"singlevalue\" },\n        { text: \"Multi value\", value: \"multivalue\" }\n    ];\n\n    this.typeChanged = function(data, event) {\n        self.getTargetAttribute(event.target).valueHasMutated();\n    };\n\n    this.labelTypeChanged = function(data, event) {\n        self.getTargetAttribute(event.target).valueHasMutated();\n    };\n\n    this.updateAttributePositions = function() {\n        let position = 10;\n\n        // we need to update positions by searching in the DOM, because order of the\n        // attributes in the viewmodel (self.ownedAttributes()) stays the same\n        $ownedAttributesBody.find('input[name=\"position\"]').each(function() {\n            const attribute = self.getTargetAttribute(this);\n\n            attribute().position = position;\n            position += 10;\n        });\n    };\n\n    async function showAttributes(noteId, attributes) {\n        const ownedAttributes = attributes.filter(attr => attr.noteId === noteId);\n\n        for (const attr of ownedAttributes) {\n            attr.labelValue = attr.type === 'label' ? attr.value : '';\n            attr.relationValue = attr.type === 'relation' ? (await treeService.getNoteTitle(attr.value)) : '';\n            attr.selectedPath = attr.type === 'relation' ? attr.value : '';\n            attr.labelDefinition = (attr.type === 'label-definition' && attr.value) ? attr.value : {\n                labelType: \"text\",\n                multiplicityType: \"singlevalue\",\n                isPromoted: true,\n                numberPrecision: 0\n            };\n\n            attr.relationDefinition = (attr.type === 'relation-definition' && attr.value) ? attr.value : {\n                multiplicityType: \"singlevalue\",\n                inverseRelation: \"\",\n                isPromoted: true\n            };\n\n            delete attr.value;\n        }\n\n        self.ownedAttributes(ownedAttributes.map(ko.observable));\n\n        addLastEmptyRow();\n\n        const inheritedAttributes = attributes.filter(attr => attr.noteId !== noteId);\n\n        self.inheritedAttributes(inheritedAttributes);\n    }\n\n    this.loadAttributes = async function() {\n        const noteId = appContext.tabManager.getActiveTabNoteId();\n\n        const attributes = await server.get('notes/' + noteId + '/attributes');\n\n        await showAttributes(noteId, attributes);\n\n        // attribute might not be rendered immediatelly so could not focus\n        setTimeout(() => $(\".attribute-type-select:last\").trigger('focus'), 1000);\n    };\n\n    this.deleteAttribute = function(data, event) {\n        const attribute = self.getTargetAttribute(event.target);\n        const attributeData = attribute();\n\n        if (attributeData) {\n            attributeData.isDeleted = true;\n\n            attribute(attributeData);\n\n            addLastEmptyRow();\n        }\n    };\n\n    function isValid() {\n        for (let attributes = self.ownedAttributes(), i = 0; i < attributes.length; i++) {\n            if (self.isEmptyName(i) || self.isEmptyRelationTarget(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    this.save = async function() {\n        // we need to defocus from input (in case of enter-triggered save) because value is updated\n        // on blur event (because of conflict with jQuery UI Autocomplete). Without this, input would\n        // stay in focus, blur wouldn't be triggered and change wouldn't be updated in the viewmodel.\n        $saveAttributesButton.trigger('focus');\n\n        if (!isValid()) {\n            alert(\"Please fix all validation errors and try saving again.\");\n            return;\n        }\n\n        self.updateAttributePositions();\n\n        const noteId = appContext.tabManager.getActiveTabNoteId();\n\n        const attributesToSave = self.ownedAttributes()\n            .map(attribute => attribute())\n            .filter(attribute => attribute.attributeId !== \"\" || attribute.name !== \"\");\n\n        for (const attr of attributesToSave) {\n            if (attr.type === 'label') {\n                attr.value = attr.labelValue;\n            }\n            else if (attr.type === 'relation') {\n                attr.value = treeService.getNoteIdFromNotePath(attr.selectedPath);\n            }\n            else if (attr.type === 'label-definition') {\n                attr.value = JSON.stringify(attr.labelDefinition);\n            }\n            else if (attr.type === 'relation-definition') {\n                attr.value = JSON.stringify(attr.relationDefinition);\n            }\n\n            delete attr.labelValue;\n            delete attr.relationValue;\n            delete attr.labelDefinition;\n            delete attr.relationDefinition;\n        }\n\n        const attributes = await server.put('notes/' + noteId + '/attributes', attributesToSave);\n\n        await showAttributes(noteId, attributes);\n\n        toastService.showMessage(\"Attributes have been saved.\");\n    };\n\n    function addLastEmptyRow() {\n        const attributes = self.ownedAttributes().filter(attr => !attr().isDeleted);\n        const last = attributes.length === 0 ? null : attributes[attributes.length - 1]();\n\n        if (!last || last.name.trim() !== \"\") {\n            self.ownedAttributes.push(ko.observable({\n                attributeId: '',\n                type: 'label',\n                name: '',\n                labelValue: '',\n                relationValue: '',\n                isInheritable: false,\n                isDeleted: false,\n                position: 0,\n                labelDefinition: {\n                    labelType: \"text\",\n                    multiplicityType: \"singlevalue\",\n                    isPromoted: true,\n                    numberPrecision: 0\n                },\n                relationDefinition: {\n                    multiplicityType: \"singlevalue\",\n                    inverseRelation: \"\",\n                    isPromoted: true\n                }\n            }));\n        }\n    }\n\n    this.attributeChanged = function (data, event) {\n        addLastEmptyRow();\n\n        const attribute = self.getTargetAttribute(event.target);\n\n        attribute.valueHasMutated();\n    };\n\n    this.isEmptyName = function(index) {\n        const cur = self.ownedAttributes()[index]();\n\n        if (cur.name.trim() || cur.isDeleted) {\n            return false;\n        }\n\n        if (cur.attributeId) {\n            // name is empty and attribute already exists so this is NO-GO\n            return true;\n        }\n\n        if (cur.type === 'relation-definition' || cur.type === 'label-definition') {\n            // for definitions there's no possible empty value so we always require name\n            return true;\n        }\n\n        if (cur.type === 'label' && cur.labelValue) {\n            return true;\n        }\n\n        if (cur.type === 'relation' && cur.relationValue) {\n            return true;\n        }\n\n        return false;\n    };\n\n    this.isEmptyRelationTarget = function(index) {\n        const cur = self.ownedAttributes()[index]();\n\n        return cur.type === \"relation\" && !cur.isDeleted && cur.name && !cur.relationValue;\n    };\n\n    this.getTargetAttribute = function(target) {\n        const context = ko.contextFor(target);\n        const index = context.$index();\n\n        return self.ownedAttributes()[index];\n    }\n}\n\nlet attributesModel;\n\nfunction initKoPlugins() {\n    ko.bindingHandlers.noteLink = {\n        init: async function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            const noteId = ko.unwrap(valueAccessor());\n\n            if (noteId) {\n                const link = await linkService.createNoteLink(noteId);\n\n                $(element).append(link);\n            }\n        }\n    };\n\n    ko.bindingHandlers.noteAutocomplete = {\n        init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            noteAutocompleteService.initNoteAutocomplete($(element));\n\n            $(element).setSelectedPath(bindingContext.$data.selectedPath);\n\n            $(element).on('autocomplete:selected', function (event, suggestion, dataset) {\n                bindingContext.$data.selectedPath = $(element).val().trim() ? suggestion.path : '';\n            });\n        }\n    };\n}\n\nexport async function showDialog() {\n    await libraryLoader.requireLibrary(libraryLoader.KNOCKOUT);\n\n    // lazily apply bindings on first use\n    if (!attributesModel) {\n        attributesModel = new AttributesModel();\n\n        initKoPlugins();\n\n        ko.applyBindings(attributesModel, $dialog[0]);\n    }\n\n    await attributesModel.loadAttributes();\n\n    utils.openDialog($dialog);\n}\n\n$dialog.on('focus', '.attribute-name', function (e) {\n    attributeAutocompleteService.initAttributeNameAutocomplete({\n        $el: $(this),\n        attributeType: () => {\n            const attribute = attributesModel.getTargetAttribute(this);\n            return (attribute().type === 'relation' || attribute().type === 'relation-definition') ? 'relation' : 'label';\n        },\n        open: true\n    });\n});\n\n$dialog.on('focus', '.label-value', function (e) {\n    attributeAutocompleteService.initLabelValueAutocomplete({\n        $el: $(this),\n        open: true\n    })\n});\n","const CKEDITOR = {\"js\": [\"libraries/ckeditor/ckeditor.js\"]};\n\nconst CODE_MIRROR = {\n    js: [\n        \"libraries/codemirror/codemirror.js\",\n        \"libraries/codemirror/addon/mode/loadmode.js\",\n        \"libraries/codemirror/addon/fold/xml-fold.js\",\n        \"libraries/codemirror/addon/edit/matchbrackets.js\",\n        \"libraries/codemirror/addon/edit/matchtags.js\",\n        \"libraries/codemirror/addon/search/match-highlighter.js\",\n        \"libraries/codemirror/mode/meta.js\",\n        \"libraries/codemirror/addon/lint/lint.js\",\n        \"libraries/codemirror/addon/lint/eslint.js\"\n    ],\n    css: [\n        \"libraries/codemirror/codemirror.css\",\n        \"libraries/codemirror/addon/lint/lint.css\"\n    ]\n};\n\nconst ESLINT = {js: [\"libraries/eslint.js\"]};\n\nconst COMMONMARK = {js: [\"libraries/commonmark.min.js\"]};\n\nconst RELATION_MAP = {\n    js: [\n        \"libraries/jsplumb.js\",\n        \"libraries/panzoom.js\"\n    ],\n    css: [\n        \"stylesheets/relation_map.css\"\n    ]\n};\n\nconst LINK_MAP = {\n    js: [\n        \"libraries/jsplumb.js\",\n        \"libraries/panzoom.js\",\n        \"libraries/springy.js\"\n    ],\n    css: [\n        \"stylesheets/link_map.css\"\n    ]\n};\n\nconst PRINT_THIS = {js: [\"libraries/printThis.js\"]};\n\nconst KNOCKOUT = {js: [\"libraries/knockout.min.js\"]};\n\nconst CALENDAR_WIDGET = {css: [\"stylesheets/calendar.css\"]};\n\nasync function requireLibrary(library) {\n    if (library.css) {\n        library.css.map(cssUrl => requireCss(cssUrl));\n    }\n\n    if (library.js) {\n        for (const scriptUrl of library.js) {\n            await requireScript(scriptUrl);\n        }\n    }\n}\n\n// we save the promises in case of the same script being required concurrently multiple times\nconst loadedScriptPromises = {};\n\nasync function requireScript(url) {\n    if (!loadedScriptPromises[url]) {\n        loadedScriptPromises[url] = $.ajax({\n            url: url,\n            dataType: \"script\",\n            cache: true\n        });\n    }\n\n    await loadedScriptPromises[url];\n}\n\nasync function requireCss(url) {\n    const cssLinks = Array\n        .from(document.querySelectorAll('link'))\n        .map(el => el.href);\n\n    if (!cssLinks.some(l => l.endsWith(url))) {\n        $('head').append($('<link rel=\"stylesheet\" type=\"text/css\" />').attr('href', url));\n    }\n}\n\nexport default {\n    requireCss,\n    requireLibrary,\n    CKEDITOR,\n    CODE_MIRROR,\n    ESLINT,\n    COMMONMARK,\n    RELATION_MAP,\n    LINK_MAP,\n    PRINT_THIS,\n    KNOCKOUT,\n    CALENDAR_WIDGET\n}","import server from \"./server.js\";\nimport appContext from \"./app_context.js\";\nimport utils from './utils.js';\n\n// this key needs to have this value so it's hit by the tooltip\nconst SELECTED_PATH_KEY = \"data-note-path\";\n\nasync function autocompleteSource(term, cb) {\n    const result = await server.get('autocomplete'\n        + '?query=' + encodeURIComponent(term)\n        + '&activeNoteId=' + appContext.tabManager.getActiveTabNoteId());\n\n    if (result.length === 0) {\n        result.push({\n            pathTitle: \"No results\",\n            path: \"\"\n        });\n    }\n\n    cb(result);\n}\n\nfunction clearText($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\").trigger('change');\n}\n\nfunction showRecentNotes($el) {\n    if (utils.isMobile()) {\n        return;\n    }\n\n    $el.setSelectedPath(\"\");\n    $el.autocomplete(\"val\", \"\");\n    $el.trigger('focus');\n}\n\nfunction initNoteAutocomplete($el, options) {\n    if ($el.hasClass(\"note-autocomplete-input\") || utils.isMobile()) {\n        return $el;\n    }\n\n    options = options || {};\n\n    $el.addClass(\"note-autocomplete-input\");\n\n    const $clearTextButton = $(\"<a>\")\n            .addClass(\"input-group-text input-clearer-button bx bx-x\")\n            .prop(\"title\", \"Clear text field\");\n\n    const $showRecentNotesButton = $(\"<a>\")\n            .addClass(\"input-group-text show-recent-notes-button bx bx-time\")\n            .prop(\"title\", \"Show recent notes\");\n\n    const $goToSelectedNoteButton = $(\"<a>\")\n        .addClass(\"input-group-text go-to-selected-note-button bx bx-arrow-to-right\")\n        .attr(\"data-action\", \"note\");\n\n    const $sideButtons = $(\"<div>\")\n        .addClass(\"input-group-append\")\n        .append($clearTextButton)\n        .append($showRecentNotesButton);\n\n    if (!options.hideGoToSelectedNoteButton) {\n        $sideButtons.append($goToSelectedNoteButton);\n    }\n\n    $el.after($sideButtons);\n\n    $clearTextButton.on('click', () => clearText($el));\n\n    $showRecentNotesButton.on('click', e => {\n        showRecentNotes($el);\n\n        // this will cause the click not give focus to the \"show recent notes\" button\n        // this is important because otherwise input will lose focus immediatelly and not show the results\n        return false;\n    });\n\n    $el.autocomplete({\n        appendTo: document.querySelector('body'),\n        hint: false,\n        autoselect: true,\n        openOnFocus: true,\n        minLength: 0,\n        tabAutocomplete: false\n    }, [\n        {\n            source: autocompleteSource,\n            displayKey: 'pathTitle',\n            templates: {\n                suggestion: function(suggestion) {\n                    return suggestion.highlightedTitle;\n                }\n            },\n            // we can't cache identical searches because notes can be created / renamed, new recent notes can be added\n            cache: false\n        }\n    ]);\n\n    $el.on('autocomplete:selected', (event, suggestion) => $el.setSelectedPath(suggestion.path));\n    $el.on('autocomplete:closed', () => {\n        if (!$el.val().trim()) {\n            clearText($el);\n        }\n    });\n\n    return $el;\n}\n\nfunction init() {\n    $.fn.getSelectedPath = function () {\n        if (!$(this).val().trim()) {\n            return \"\";\n        } else {\n            return $(this).attr(SELECTED_PATH_KEY);\n        }\n    };\n\n    $.fn.setSelectedPath = function (path) {\n        path = path || \"\";\n\n        $(this).attr(SELECTED_PATH_KEY, path);\n\n        $(this)\n            .closest(\".input-group\")\n            .find(\".go-to-selected-note-button\")\n            .toggleClass(\"disabled\", !path.trim())\n            .attr(SELECTED_PATH_KEY, path); // we also set attr here so tooltip can be displayed\n    };\n}\n\nexport default {\n    autocompleteSource,\n    initNoteAutocomplete,\n    showRecentNotes,\n    init\n}"],"sourceRoot":""}