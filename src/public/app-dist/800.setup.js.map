{"version":3,"sources":["webpack://trilium/./src/public/app/entities/attribute.js","webpack://trilium/./src/public/app/entities/branch.js","webpack://trilium/./src/public/app/services/dialog_command_executor.js","webpack://trilium/./src/public/app/services/note_create.js","webpack://trilium/./src/public/app/services/entrypoints.js","webpack://trilium/./src/public/app/services/zoom.js","webpack://trilium/./src/public/app/services/spaced_update.js","webpack://trilium/./src/public/app/services/tab_context.js","webpack://trilium/./src/public/app/services/tab_manager.js","webpack://trilium/./src/public/app/widgets/mobile_widgets/mobile_screen_switcher.js","webpack://trilium/./src/public/app/services/main_tree_executors.js","webpack://trilium/./src/public/app/services/app_context.js","webpack://trilium/./src/public/app/services/bundle.js","webpack://trilium/./src/public/app/services/date_notes.js","webpack://trilium/./src/public/app/services/hoisted_note.js","webpack://trilium/./src/public/app/services/keyboard_actions.js","webpack://trilium/./src/public/app/services/context_menu.js","webpack://trilium/./src/public/app/services/link.js","webpack://trilium/./src/public/app/services/note_attribute_cache.js","webpack://trilium/./src/public/app/services/options.js","webpack://trilium/./src/public/app/services/protected_session.js","webpack://trilium/./src/public/app/services/protected_session_holder.js","webpack://trilium/./src/public/app/services/note_tooltip.js","webpack://trilium/./src/public/app/widgets/basic_widget.js","webpack://trilium/./src/public/app/widgets/tab_aware_widget.js","webpack://trilium/./src/public/app/widgets/collapsible_widget.js","webpack://trilium/./src/public/app/widgets/tab_caching_widget.js","webpack://trilium/./src/public/app/services/frontend_script_api.js","webpack://trilium/./src/public/app/services/script_context.js","webpack://trilium/./src/public/app/services/server.js","webpack://trilium/./src/public/app/services/toast.js","webpack://trilium/./src/public/app/services/tree.js","webpack://trilium/./src/public/app/entities/note_short.js","webpack://trilium/./src/public/app/entities/note_complement.js","webpack://trilium/./src/public/app/services/tree_cache.js","webpack://trilium/./src/public/app/services/load_results.js","webpack://trilium/./src/public/app/services/ws.js","webpack://trilium/./src/public/app/widgets/component.js"],"names":["treeCache","row","this","update","attributeId","noteId","type","name","value","position","isInheritable","notes","undefined","JSON","parse","e","affectedNote","attrNote","getNote","owningNotes","getTemplateNotes","owningNote","hasAncestor","branchId","parentNoteId","notePosition","prefix","isExpanded","isDeleted","DialogCommandExecutor","then","d","showDialog","showCurrentNoteRevisions","importMarkdownInline","notePath","noteIds","branchIds","async","createNote","options","Object","assign","activate","target","isProtected","saveSelection","utils","title","content","selectedHtml","dom","$","parseHTML","length","tagName","match","text","replace","outerHTML","parseSelectedHtml","window","cutToNote","getSelectedHtml","newNoteName","note","branch","server","targetBranchId","removeSelection","ws","activeTabContext","setNote","createNewTopLevelNote","hoistedNoteId","duplicateNote","origNote","toast","Entrypoints","super","jQuery","hotkeys","filterInputAcceptingElements","filterContentEditable","filterTextInputs","document","on","linkEl","event","attr","noteRevisionId","showNoteRevisionsDialog","remote","getCurrentWindow","toggleDevTools","FindInPage","getCurrentWebContents","offsetTop","offsetRight","boxBgColor","boxShadowColor","inputColor","inputBgColor","inputFocusColor","textColor","textHoverBgColor","caseSelectedColor","openFindWindow","todayNote","win","isFullScreenable","setFullScreen","isFullScreen","$widget","find","hide","zenModeActive","removeClass","addClass","$logoutForm","append","glob","csrfToken","trigger","webContents","activeIndex","parseInt","getActiveIndex","goToIndex","history","back","forward","searchText","response","encodeURIComponent","success","triggerEvent","results","ipcRenderer","send","url","location","protocol","host","pathname","open","openInWindowCommand","mime","endsWith","bundle","ZoomService","setZoomFactor","zoomFactor","parseFloat","webFrame","console","log","getZoomFactor","setZoomFactorAndSave","getCurrentZoom","SpacedUpdate","updater","updateInterval","lastUpdated","Date","now","changed","changeForbidden","setTimeout","triggerUpdate","scheduleUpdate","callback","TabContext","tabId","tabContext","inputNotePath","triggerSwitchEvent","tree","error","autoBookDisabled","textPreviewDisabled","codePreviewDisabled","active","isActive","loadResults","isNoteReloaded","TabManager","activeTabId","tabsUpdate","openTabs","tabContexts","map","tc","getTabState","filter","t","stringify","children","tabsToOpen","hash","substr","tab","foundTab","push","filteredTabs","openTab","isMainWindow","allowUpdateWithoutChange","openTabWithNote","setCurrentNotePathToHash","getActiveTabContext","pushState","getTabContextById","activeContext","activeNote","getActiveTabNote","openEmptyTab","activateTab","setEmpty","child","getTabContexts","tabContextToRemove","autocomplete","openAndActivateEmptyTab","findIndex","activatePreviousTabCommand","activateNextTabCommand","tabIdsInOrder","order","i","sort","a","b","oldIdx","newActiveTabId","removeTab","updateNowIfNecessary","tabIdToRemove","triggerCommand","splice","split","includes","MobileScreenSwitcherExecutor","screen","activeScreen","setActiveScreenCommand","MainTreeExecutors","selectedOrActiveNoteIds","getSelectedOrActiveNodes","node","data","selectedOrActiveBranchIds","getActiveNode","AppContext","executors","layout","Promise","all","showWidgets","tabManager","loadTabs","rootWidget","getRootWidget","$renderedWidget","render","commandName","closest","prop","$el","executor","zoom","handleEvent","fun","callMethod","debug","el","appContext","startsWith","isNotePathInAddress","switchToTab","getAndExecuteBundle","originEntity","executeBundle","$container","apiContext","allNoteIds","eval","script","call","message","executeStartupBundles","scriptBundles","WidgetsByParent","byParent","widget","parentWidget","parentName","getWidgetBundlesByParent","widgetsByParent","add","getDateNote","date","getTodayNote","dayjs","format","getMonthNote","month","getYearNote","year","getHoistedNoteId","setHoistedNoteId","unhoist","isRootNode","isTopLevelNode","getParent","checkNoteAccess","runNotePath","confirmDialog","confirm","keyboardActionRepo","keyboardActionsLoaded","actions","actionName","action","effectiveShortcuts","shortcut","getActionsForScope","scope","getAction","silent","Error","shortcutForNotes","setElementActionHandler","handler","updateDisplayedShortcuts","each","join","shortcuts","newTitle","trim","setupActionsForElement","component","dateContextMenuOpenedMs","empty","addItems","items","positionMenu","clientHeight","documentElement","contextMenuHeight","outerHeight","top","y","css","display","left","x","$parent","item","$icon","uiIcon","$link","$item","stopPropagation","selectMenuItemHandler","enabled","$subMenu","getNotePathFromUrl","notePathMatch","exec","getNotePathFromLink","notePathAttr","goToLink","preventDefault","which","ctrlKey","address","linkContextMenu","pageX","pageY","command","createNoteLink","noteTitle","showTooltip","showNotePath","$noteLink","href","pop","parentNotePath","attributes","initializedPromise","load","arr","key","keys","set","payload","protectedSessionDeferred","enterProtectedSession","dfd","Deferred","resolve","dialog","show","promise","makeToast","protectingLabel","id","taskId","icon","protect","taskType","progressCount","closeAfter","protectNote","includingSubtree","leaveProtectedSession","setupProtectedSession","password","enterProtectedSessionOnServer","protectedSessionId","reloadData","close","lastProtectedSessionOperationDate","setProtectedSessionId","resetProtectedSession","isProtectedSessionAvailable","touchProtectedSession","setInterval","protectedSessionTimeout","touchProtectedSessionIfNecessary","mouseEnterHandler","hasClass","noteComplement","html","getAttributes","promoted","json","jsonValue","isPromoted","$table","definitionAttr","definitionType","valueType","valueAttrs","valueAttr","$value","$row","renderTooltip","is","tooltip","delay","container","placement","boundary","template","sanitize","mouseLeaveHandler","BasicWidget","attrs","style","classes","className","class","block","cssEl","doRender","toggleInt","isEnabled","toggleClass","remove","TabAwareWidget","start","refreshWithNote","end","PROFILING_LOG","componentId","noteSwitched","refresh","activeTabChanged","isNote","CollapsibleWidget","$bodyWrapper","widgetName","widgetTitle","collapse","saveCollapsed","$body","$title","$help","help","$headerActions","headerActions","initialized","doRenderBody","decorateWidget","toString","TabCachingWidget","widgetFactory","widgets","toggleExt","after","ch","isTab","hasBeenAlreadyShown","handleEventInChildren","startNote","currentNote","$pluginButtons","prepareParams","params","p","activateNote","activateNewNote","addButtonToToolbar","opts","buttonId","button","replaceWith","runOnBackend","ret","startNoteId","currentNoteId","originEntityName","originEntityId","maxSyncId","executionResult","runOnServer","searchForNotes","api","searchString","searchForNote","getNotes","silentNotFoundError","reloadNotes","getInstanceName","instanceName","formatDateISO","parseDate","showMessage","showError","refreshTree","addTextToActiveTabEditor","getActiveTabTextEditor","getActiveTabNotePath","setupElementTooltip","protectActiveNote","protectSubTree","bindGlobalShortcut","waitUntilSynced","refreshIncludedNote","includedNoteId","modules","allNotes","apis","require","moduleNoteIds","moduleName","c","exports","getHeaders","headers","allHeaders","sourceId","headerName","cookie","reqResolves","maxKnownSyncId","method","resp","ipc","requestId","reject","baseApiUrl","ajax","maxSyncIdStr","Math","max","body","res","rej","timeout","textStatus","jqXhr","respHeaders","getAllResponseHeaders","forEach","line","parts","header","shift","toastService","default","throwError","contentType","arg","get","post","put","getMaxKnownSyncId","$toast","autohide","showAndLogError","showPersistent","closePersistent","getRunPath","logErrors","path","reverse","effectivePath","childNoteId","parents","getParentNotes","some","someNotePath","getSomeNotePath","pathToRoot","cur","getNoteTitle","parentToBranch","sortAlphabetically","resolveNotePath","runPath","getParentProtectedStatus","getNotePath","getNoteIdFromNotePath","getNoteIdAndParentIdFromNotePath","getNotePathTitle","titlePath","getHashValueFromAddress","parseNotePath","concat","LABEL","targetRelations","childToBranch","contentLength","branchIdPos","values","getBranch","getContent","getBranches","getNotesFromCache","Boolean","__filterAttrs","__getCachedAttributes","ownedAttributes","getOwnedAttributes","attrArrs","newPath","templateAttr","oa","templateNote","parentNote","__getInheritableAttributes","flat","getAttribute","getOwnedAttribute","hasOwnedAttribute","hasAttribute","getOwnedAttributeValue","getAttributeValue","targets","getRelationTargets","relations","getRelations","relation","rel","ancestorNote","__attributeCache","getNoteComplement","dto","getLabels","l","dateCreated","dateModified","utcDateCreated","utcDateModified","loadInitialTree","loadParents","branches","noteComplementPromises","addResp","additiveLoad","Set","missingNoteIds","existingNotes","has","newResp","noteRows","branchRows","attributeRows","noteRow","oldNote","childNote","branchRow","addParent","addChild","attributeRow","targetNote","Array","from","searchResults","result","index","trace","LoadResults","noteIdToSourceId","sourceIdToNoteIds","noteReorderings","noteRevisions","contentNoteIdToSourceId","nr","sourceIds","sId","$outstandingSyncsCount","messageHandlers","lastPingTs","lastAcceptedSyncId","maxSyncIdAtLoad","lastProcessedSyncId","syncDataQueue","logError","readyState","stack","subscribeToMessages","messageHandler","consumeQueuePromise","processedSyncIds","handleMessage","syncRows","outstandingSyncs","filteredRows","entityName","entityId","logRows","sendPing","allSyncRows","nonProcessedSyncRows","sync","entity","addNote","addBranch","positions","addNoteReordering","attribute","sourceNote","addAttribute","addNoteContent","addNoteRevision","addOption","isEmpty","hasAttributeRelatedChanges","processSyncRows","syncRow","syncIdReachedListeners","desiredSyncId","resolvePromise","floor","consumeSyncData","waitForSyncId","connectWebSocket","loc","webSocketUri","WebSocket","onopen","onmessage","OPEN","lastSyncId","CLOSED","CLOSING","waitForMaxKnownSyncId","Component","parent","components","setParent","promises"],"mappings":"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","file":"800.setup.js","sourcesContent":["class Attribute {\n    constructor(treeCache, row) {\n        this.treeCache = treeCache;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @param {string} attributeId */\n        this.attributeId = row.attributeId;\n        /** @param {string} noteId */\n        this.noteId = row.noteId;\n        /** @param {string} type */\n        this.type = row.type;\n        /** @param {string} name */\n        this.name = row.name;\n        /** @param {string} value */\n        this.value = row.value;\n        /** @param {int} position */\n        this.position = row.position;\n        /** @param {boolean} isInheritable */\n        this.isInheritable = row.isInheritable;\n    }\n\n    /** @returns {NoteShort} */\n    getNote() {\n        return this.treeCache.notes[this.noteId];\n    }\n\n    get targetNoteId() { // alias\n        return this.type === 'relation' ? this.value : undefined;\n    }\n\n    get jsonValue() {\n        try {\n            return JSON.parse(this.value);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n\n    get toString() {\n        return `Attribute(attributeId=${this.attributeId}, type=${this.type}, name=${this.name}, value=${this.value})`;\n    }\n\n    /**\n     * @return {boolean} - returns true if this attribute has the potential to influence the note in the argument.\n     *         That can happen in multiple ways:\n     *         1. attribute is owned by the note\n     *         2. attribute is owned by the template of the note\n     *         3. attribute is owned by some note's ancestor and is inheritable\n     */\n    isAffecting(affectedNote) {\n        if (!affectedNote) {\n            return false;\n        }\n\n        const attrNote = this.getNote();\n\n        if (!attrNote) {\n            // the note (owner of the attribute) is not even loaded into the cache so it should not affect anything else\n            return false;\n        }\n\n        const owningNotes = [affectedNote, ...affectedNote.getTemplateNotes()];\n\n        for (const owningNote of owningNotes) {\n            if (owningNote.noteId === attrNote.noteId) {\n                return true;\n            }\n        }\n\n        if (this.isInheritable) {\n            for (const owningNote of owningNotes) {\n                if (owningNote.hasAncestor(attrNote)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\nexport default Attribute;\n","/** Represents mapping between note and parent note */\nclass Branch {\n    constructor(treeCache, row) {\n        this.treeCache = treeCache;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @param {string} primary key */\n        this.branchId = row.branchId;\n        /** @param {string} */\n        this.noteId = row.noteId;\n        /** @param {string} */\n        this.parentNoteId = row.parentNoteId;\n        /** @param {int} */\n        this.notePosition = row.notePosition;\n        /** @param {string} */\n        this.prefix = row.prefix;\n        /** @param {boolean} */\n        this.isExpanded = !!row.isExpanded;\n        /** @param {boolean} */\n        this.isDeleted = !!row.isDeleted;\n    }\n\n    /** @returns {NoteShort} */\n    async getNote() {\n        return this.treeCache.getNote(this.noteId);\n    }\n\n    /** @returns {NoteShort} */\n    async getParentNote() {\n        return this.treeCache.getNote(this.parentNoteId);\n    }\n\n    /** @returns {boolean} true if it's top level, meaning its parent is root note */\n    isTopLevel() {\n        return this.parentNoteId === 'root';\n    }\n\n    get toString() {\n        return `Branch(branchId=${this.branchId})`;\n    }\n}\n\nexport default Branch;","import Component from \"../widgets/component.js\";\nimport appContext from \"./app_context.js\";\n\nexport default class DialogCommandExecutor extends Component {\n    jumpToNoteCommand() {\n        import(\"../dialogs/jump_to_note.js\").then(d => d.showDialog());\n    }\n\n    showRecentChangesCommand() {\n        import(\"../dialogs/recent_changes.js\").then(d => d.showDialog());\n    }\n\n    showAttributesCommand() {\n        import(\"../dialogs/attributes.js\").then(d => d.showDialog());\n    }\n\n    showNoteInfoCommand() {\n        import(\"../dialogs/note_info.js\").then(d => d.showDialog());\n    }\n\n    showNoteRevisionsCommand() {\n        import(\"../dialogs/note_revisions.js\").then(d => d.showCurrentNoteRevisions());\n    }\n\n    showNoteSourceCommand() {\n        import(\"../dialogs/note_source.js\").then(d => d.showDialog());\n    }\n\n    showLinkMapCommand() {\n        import(\"../dialogs/link_map.js\").then(d => d.showDialog());\n    }\n\n    pasteMarkdownIntoTextCommand() {\n        import(\"../dialogs/markdown_import.js\").then(d => d.importMarkdownInline());\n    }\n\n    async editBranchPrefixCommand() {\n        const notePath = appContext.tabManager.getActiveTabNotePath();\n\n        if (notePath) {\n            const editBranchPrefixDialog = await import(\"../dialogs/branch_prefix.js\");\n            editBranchPrefixDialog.showDialog(notePath);\n        }\n    }\n\n    async cloneNoteIdsToCommand({noteIds}) {\n        const d = await import(\"../dialogs/clone_to.js\");\n        d.showDialog(noteIds);\n    }\n\n    async moveBranchIdsToCommand({branchIds}) {\n        const d = await import(\"../dialogs/move_to.js\");\n        d.showDialog(branchIds);\n    }\n\n    showOptionsCommand() {\n        import(\"../dialogs/options.js\").then(d => d.showDialog())\n    }\n\n    showHelpCommand() {\n        import(\"../dialogs/help.js\").then(d => d.showDialog())\n    }\n\n    showSQLConsoleCommand() {\n        import(\"../dialogs/sql_console.js\").then(d => d.showDialog())\n    }\n\n    showBackendLogCommand() {\n        import(\"../dialogs/backend_log.js\").then(d => d.showDialog())\n    }\n}","import hoistedNoteService from \"./hoisted_note.js\";\nimport appContext from \"./app_context.js\";\nimport utils from \"./utils.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport server from \"./server.js\";\nimport ws from \"./ws.js\";\nimport treeCache from \"./tree_cache.js\";\nimport toastService from \"./toast.js\";\n\nasync function createNewTopLevelNote() {\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    await createNote(hoistedNoteId);\n}\n\nasync function createNote(parentNoteId, options = {}) {\n    options = Object.assign({\n        activate: true,\n        target: 'into'\n    }, options);\n\n    // if isProtected isn't available (user didn't enter password yet), then note is created as unencrypted\n    // but this is quite weird since user doesn't see WHERE the note is being created so it shouldn't occur often\n    if (!options.isProtected || !protectedSessionHolder.isProtectedSessionAvailable()) {\n        options.isProtected = false;\n    }\n\n    if (appContext.tabManager.getActiveTabNoteType() !== 'text') {\n        options.saveSelection = false;\n    }\n\n    if (options.saveSelection && utils.isCKEditorInitialized()) {\n        [options.title, options.content] = parseSelectedHtml(window.cutToNote.getSelectedHtml());\n    }\n\n    const newNoteName = options.title || \"new note\";\n\n    const {note, branch} = await server.post(`notes/${parentNoteId}/children?target=${options.target}&targetBranchId=${options.targetBranchId}`, {\n        title: newNoteName,\n        content: options.content || \"\",\n        isProtected: options.isProtected,\n        type: options.type\n    });\n\n    if (options.saveSelection && utils.isCKEditorInitialized()) {\n        // we remove the selection only after it was saved to server to make sure we don't lose anything\n        window.cutToNote.removeSelection();\n    }\n\n    if (options.activate) {\n        await ws.waitForMaxKnownSyncId();\n\n        const activeTabContext = appContext.tabManager.getActiveTabContext();\n        await activeTabContext.setNote(note.noteId);\n\n        appContext.triggerCommand('focusAndSelectTitle');\n    }\n\n    return {note, branch};\n}\n\n/* If first element is heading, parse it out and use it as a new heading. */\nfunction parseSelectedHtml(selectedHtml) {\n    const dom = $.parseHTML(selectedHtml);\n\n    if (dom.length > 0 && dom[0].tagName && dom[0].tagName.match(/h[1-6]/i)) {\n        const title = $(dom[0]).text();\n        // remove the title from content (only first occurence)\n        const content = selectedHtml.replace(dom[0].outerHTML, \"\");\n\n        return [title, content];\n    }\n    else {\n        return [null, selectedHtml];\n    }\n}\n\nasync function duplicateNote(noteId, parentNoteId) {\n    const {note} = await server.post(`notes/${noteId}/duplicate/${parentNoteId}`);\n\n    await ws.waitForMaxKnownSyncId();\n\n    await appContext.tabManager.activateOrOpenNote(note.noteId);\n\n    const origNote = await treeCache.getNote(noteId);\n    toastService.showMessage(`Note \"${origNote.title}\" has been duplicated`);\n}\n\nexport default {\n    createNote,\n    createNewTopLevelNote,\n    duplicateNote\n};","import utils from \"./utils.js\";\nimport dateNoteService from \"./date_notes.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport server from \"./server.js\";\nimport appContext from \"./app_context.js\";\nimport Component from \"../widgets/component.js\";\nimport toastService from \"./toast.js\";\nimport noteCreateService from \"./note_create.js\";\nimport ws from \"./ws.js\";\nimport bundleService from \"./bundle.js\";\n\nexport default class Entrypoints extends Component {\n    constructor() {\n        super();\n\n        if (jQuery.hotkeys) {\n            // hot keys are active also inside inputs and content editables\n            jQuery.hotkeys.options.filterInputAcceptingElements = false;\n            jQuery.hotkeys.options.filterContentEditable = false;\n            jQuery.hotkeys.options.filterTextInputs = false;\n        }\n\n        $(document).on('click', \"a[data-action='note-revision']\", async event => {\n            const linkEl = $(event.target);\n            const noteId = linkEl.attr('data-note-path');\n            const noteRevisionId = linkEl.attr('data-note-revision-id');\n\n            const attributesDialog = await import(\"../dialogs/note_revisions.js\");\n\n            attributesDialog.showNoteRevisionsDialog(noteId, noteRevisionId);\n\n            return false;\n        });\n    }\n\n    openDevToolsCommand() {\n        if (utils.isElectron()) {\n            utils.dynamicRequire('electron').remote.getCurrentWindow().toggleDevTools();\n        }\n    }\n\n    findInTextCommand() {\n        if (!utils.isElectron()) {\n            return;\n        }\n\n        const {remote} = utils.dynamicRequire('electron');\n        const {FindInPage} = utils.dynamicRequire('electron-find');\n        const findInPage = new FindInPage(remote.getCurrentWebContents(), {\n            offsetTop: 10,\n            offsetRight: 10,\n            boxBgColor: 'var(--main-background-color)',\n            boxShadowColor: '#000',\n            inputColor: 'var(--input-text-color)',\n            inputBgColor: 'var(--input-background-color)',\n            inputFocusColor: '#555',\n            textColor: 'var(--main-text-color)',\n            textHoverBgColor: '#555',\n            caseSelectedColor: 'var(--main-border-color)'\n        });\n\n        findInPage.openFindWindow();\n    }\n\n    async createNoteIntoDayNoteCommand() {\n        const todayNote = await dateNoteService.getTodayNote();\n\n        const {note} = await server.post(`notes/${todayNote.noteId}/children?target=into`, {\n            title: 'new note',\n            content: '',\n            type: 'text',\n            isProtected: todayNote.isProtected\n        });\n\n        await ws.waitForMaxKnownSyncId();\n\n        await appContext.tabManager.openTabWithNote(note.noteId, true);\n\n        appContext.triggerEvent('focusAndSelectTitle');\n    }\n\n    async toggleNoteHoistingCommand() {\n        const note = appContext.tabManager.getActiveTabNote();\n\n        const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n        if (note.noteId === hoistedNoteId) {\n            hoistedNoteService.unhoist();\n        }\n        else if (note.type !== 'search') {\n            hoistedNoteService.setHoistedNoteId(note.noteId);\n        }\n    }\n\n    copyWithoutFormattingCommand() {\n        utils.copySelectionToClipboard();\n    }\n\n    toggleFullscreenCommand() {\n        if (utils.isElectron()) {\n            const win = utils.dynamicRequire('electron').remote.getCurrentWindow();\n\n            if (win.isFullScreenable()) {\n                win.setFullScreen(!win.isFullScreen());\n            }\n        }\n        else {\n            // outside of electron this is handled by the browser\n            this.$widget.find(\".toggle-fullscreen-button\").hide();\n        }\n    }\n\n    toggleZenModeCommand() {\n        if (!this.zenModeActive) {\n            $(\".hide-in-zen-mode,.gutter\").addClass(\"hidden-by-zen-mode\");\n            $(\"#root-widget\").addClass(\"zen-mode\");\n            this.zenModeActive = true;\n        }\n        else {\n            // not hiding / showing explicitly since element might be hidden also for other reasons\n            $(\".hide-in-zen-mode,.gutter\").removeClass(\"hidden-by-zen-mode\");\n            $(\"#root-widget\").removeClass(\"zen-mode\");\n            this.zenModeActive = false;\n        }\n    }\n\n    reloadFrontendAppCommand() {\n        utils.reloadApp();\n    }\n\n    logoutCommand() {\n        const $logoutForm = $('<form action=\"logout\" method=\"POST\">')\n            .append($(`<input type=\"hidden\" name=\"_csrf\" value=\"${glob.csrfToken}\"/>`));\n\n        $(\"body\").append($logoutForm);\n        $logoutForm.trigger('submit');\n    }\n\n    backInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('electron').remote.getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex - 1);\n        }\n        else {\n            window.history.back();\n        }\n    }\n\n    forwardInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('electron').remote.getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex + 1);\n        }\n        else {\n            window.history.forward();\n        }\n    }\n\n    async searchForResultsCommand({searchText}) {\n        const response = await server.get('search/' + encodeURIComponent(searchText));\n\n        if (!response.success) {\n            toastService.showError(\"Search failed.\", 3000);\n            return;\n        }\n\n        this.triggerEvent('searchResults', {results: response.results});\n\n        // have at least some feedback which is good especially in situations\n        // when the result list does not change with a query\n        toastService.showMessage(\"Search finished successfully.\");\n    }\n\n    async switchToDesktopVersionCommand() {\n        utils.setCookie('trilium-device', 'desktop');\n\n        utils.reloadApp();\n    }\n\n    createTopLevelNoteCommand() { noteCreateService.createNewTopLevelNote(); }\n\n    async openInWindowCommand({notePath}) {\n        if (utils.isElectron()) {\n            const {ipcRenderer} = utils.dynamicRequire('electron');\n\n            ipcRenderer.send('create-extra-window', {notePath});\n        }\n        else {\n            const url = window.location.protocol + '//' + window.location.host + window.location.pathname + '?extra=1#' + notePath;\n\n            window.open(url, '', 'width=1000,height=800');\n        }\n    }\n\n    async openNewWindowCommand() {\n        this.openInWindowCommand({notePath: ''});\n    }\n\n    async runActiveNoteCommand() {\n        const note = appContext.tabManager.getActiveTabNote();\n\n        // ctrl+enter is also used elsewhere so make sure we're running only when appropriate\n        if (!note || note.type !== 'code') {\n            return;\n        }\n\n        if (note.mime.endsWith(\"env=frontend\")) {\n            await bundleService.getAndExecuteBundle(note.noteId);\n        }\n\n        if (note.mime.endsWith(\"env=backend\")) {\n            await server.post('script/run/' + note.noteId);\n        }\n\n        toastService.showMessage(\"Note executed\");\n    }\n}\n","import options from \"./options.js\";\nimport Component from \"../widgets/component.js\";\nimport utils from \"../services/utils.js\";\n\nconst MIN_ZOOM = 0.5;\nconst MAX_ZOOM = 2.0;\n\nclass ZoomService extends Component {\n    constructor() {\n        super();\n\n        if (utils.isElectron()) {\n            options.initializedPromise.then(() => {\n                this.setZoomFactor(options.getFloat('zoomFactor'));\n            });\n        }\n    }\n\n    setZoomFactor(zoomFactor) {\n        zoomFactor = parseFloat(zoomFactor);\n\n        const webFrame = utils.dynamicRequire('electron').webFrame;\n        webFrame.setZoomFactor(zoomFactor);\n    }\n\n    async setZoomFactorAndSave(zoomFactor) {\n        if (zoomFactor >= MIN_ZOOM && zoomFactor <= MAX_ZOOM) {\n            this.setZoomFactor(zoomFactor);\n\n            await options.save('zoomFactor', zoomFactor);\n        }\n        else {\n            console.log(`Zoom factor ${zoomFactor} outside of the range, ignored.`);\n        }\n    }\n\n    getCurrentZoom() {\n        return utils.dynamicRequire('electron').webFrame.getZoomFactor();\n    }\n\n    zoomOutEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() - 0.1);\n    }\n\n    zoomInEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() + 0.1);\n    }\n\n    setZoomFactorAndSaveEvent({zoomFactor}) {\n        this.setZoomFactorAndSave(zoomFactor);\n    }\n}\n\nconst zoomService = new ZoomService();\n\nexport default zoomService;\n","export default class SpacedUpdate {\n    constructor(updater, updateInterval = 1000) {\n        this.updater = updater;\n        this.lastUpdated = Date.now();\n        this.changed = false;\n        this.updateInterval = updateInterval;\n    }\n\n    scheduleUpdate() {\n        if (!this.changeForbidden) {\n            this.changed = true;\n            setTimeout(() => this.triggerUpdate());\n        }\n    }\n\n    async updateNowIfNecessary() {\n        if (this.changed) {\n            this.changed = false;\n            await this.updater();\n        }\n    }\n\n    triggerUpdate() {\n        if (!this.changed) {\n            return;\n        }\n\n        if (Date.now() - this.lastUpdated > this.updateInterval) {\n            this.updater();\n            this.lastUpdated = Date.now();\n            this.changed = false;\n        }\n        else {\n            // update not triggered but changes are still pending so we need to schedule another check\n            this.scheduleUpdate();\n        }\n    }\n\n    async allowUpdateWithoutChange(callback) {\n        this.changeForbidden = true;\n\n        try {\n            await callback();\n        }\n        finally {\n            this.changeForbidden = false;\n        }\n    }\n}\n","import protectedSessionHolder from \"./protected_session_holder.js\";\nimport server from \"./server.js\";\nimport utils from \"./utils.js\";\nimport appContext from \"./app_context.js\";\nimport treeService from \"./tree.js\";\nimport Component from \"../widgets/component.js\";\nimport treeCache from \"./tree_cache.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\n\nclass TabContext extends Component {\n    /**\n     * @param {string|null} tabId\n     */\n    constructor(tabId = null) {\n        super();\n\n        this.tabId = tabId || utils.randomString(4);\n    }\n\n    setEmpty() {\n        this.triggerEvent('tabNoteSwitched', {\n            tabContext: this,\n            notePath: this.notePath\n        });\n    }\n\n    async setNote(inputNotePath, triggerSwitchEvent = true) {\n        const noteId = treeService.getNoteIdFromNotePath(inputNotePath);\n        let notePath;\n\n        if ((await treeCache.getNote(noteId)).isDeleted) {\n            // no point in trying to resolve canonical notePath\n            notePath = inputNotePath;\n        }\n        else {\n            notePath = await treeService.resolveNotePath(inputNotePath);\n\n            if (!notePath) {\n                console.error(`Cannot resolve note path ${inputNotePath}`);\n                return;\n            }\n\n            if (notePath === this.notePath) {\n                return;\n            }\n\n            if (await hoistedNoteService.checkNoteAccess(notePath) === false) {\n                return; // note is outside of hoisted subtree and user chose not to unhoist\n            }\n        }\n\n        await this.triggerEvent('beforeNoteSwitch', {tabContext: this});\n\n        utils.closeActiveDialog();\n\n        this.notePath = notePath;\n        this.noteId = noteId;\n\n        this.autoBookDisabled = false;\n        this.textPreviewDisabled = false;\n        this.codePreviewDisabled = false;\n\n        setTimeout(async () => {\n            // we include the note into recent list only if the user stayed on the note at least 5 seconds\n            if (notePath && notePath === this.notePath) {\n                await server.post('recent-notes', {\n                    noteId: this.note.noteId,\n                    notePath: this.notePath\n                });\n            }\n        }, 5000);\n\n        protectedSessionHolder.touchProtectedSessionIfNecessary(this.note);\n\n        if (triggerSwitchEvent) {\n            await this.triggerEvent('tabNoteSwitched', {\n                tabContext: this,\n                notePath: this.notePath\n            });\n        }\n    }\n\n    /** @property {NoteShort} */\n    get note() {\n        return treeCache.notes[this.noteId];\n    }\n\n    /** @return {NoteComplement} */\n    async getNoteComplement() {\n        if (!this.noteId) {\n            return null;\n        }\n\n        return await treeCache.getNoteComplement(this.noteId);\n    }\n\n    isActive() {\n        return appContext.tabManager.activeTabId === this.tabId;\n    }\n\n    getTabState() {\n        if (!this.notePath) {\n            return null;\n        }\n\n        return {\n            tabId: this.tabId,\n            notePath: this.notePath,\n            active: this.isActive()\n        }\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        if (loadResults.isNoteReloaded(this.noteId)) {\n            const note = await treeCache.getNote(this.noteId);\n\n            if (note.isDeleted) {\n                this.noteId = null;\n                this.notePath = null;\n\n                this.triggerEvent('tabNoteSwitched', {\n                    tabContext: this,\n                    notePath: this.notePath\n                });\n            }\n        }\n    }\n}\n\nexport default TabContext;\n","import Component from \"../widgets/component.js\";\nimport SpacedUpdate from \"./spaced_update.js\";\nimport server from \"./server.js\";\nimport options from \"./options.js\";\nimport treeCache from \"./tree_cache.js\";\nimport treeService from \"./tree.js\";\nimport utils from \"./utils.js\";\nimport TabContext from \"./tab_context.js\";\nimport appContext from \"./app_context.js\";\n\nexport default class TabManager extends Component {\n    constructor() {\n        super();\n\n        this.activeTabId = null;\n\n        this.tabsUpdate = new SpacedUpdate(async () => {\n            if (!appContext.isMainWindow) {\n                return;\n            }\n\n            const openTabs = this.tabContexts\n                .map(tc => tc.getTabState())\n                .filter(t => !!t);\n\n            await server.put('options', {\n                openTabs: JSON.stringify(openTabs)\n            });\n        });\n    }\n\n    /** @type {TabContext[]} */\n    get tabContexts() {\n        return this.children;\n    }\n\n    async loadTabs() {\n        const tabsToOpen = appContext.isMainWindow\n            ? (options.getJson('openTabs') || [])\n            : [];\n\n        // if there's notePath in the URL, make sure it's open and active\n        // (useful, among others, for opening clipped notes from clipper)\n        if (window.location.hash) {\n            const notePath = window.location.hash.substr(1);\n            const noteId = treeService.getNoteIdFromNotePath(notePath);\n\n            if (noteId && await treeCache.noteExists(noteId)) {\n                for (const tab of tabsToOpen) {\n                    tab.active = false;\n                }\n\n                const foundTab = tabsToOpen.find(tab => noteId === treeService.getNoteIdFromNotePath(tab.notePath));\n\n                if (foundTab) {\n                    foundTab.active = true;\n                }\n                else {\n                    tabsToOpen.push({\n                        notePath: notePath,\n                        active: true\n                    });\n                }\n            }\n        }\n\n        let filteredTabs = [];\n\n        for (const openTab of tabsToOpen) {\n            const noteId = treeService.getNoteIdFromNotePath(openTab.notePath);\n\n            if (await treeCache.noteExists(noteId)) {\n                // note doesn't exist so don't try to open tab for it\n                filteredTabs.push(openTab);\n            }\n        }\n\n        if (utils.isMobile()) {\n            // mobile frontend doesn't have tabs so show only the active tab\n            filteredTabs = filteredTabs.filter(tab => tab.active);\n        }\n\n        if (filteredTabs.length === 0) {\n            filteredTabs.push({\n                notePath: this.isMainWindow ? 'root' : '',\n                active: true\n            });\n        }\n\n        if (!filteredTabs.find(tab => tab.active)) {\n            filteredTabs[0].active = true;\n        }\n\n        await this.tabsUpdate.allowUpdateWithoutChange(async () => {\n            for (const tab of filteredTabs) {\n                await this.openTabWithNote(tab.notePath, tab.active, tab.tabId);\n            }\n        });\n    }\n\n    tabNoteSwitchedEvent({tabContext}) {\n        if (tabContext.isActive()) {\n            this.setCurrentNotePathToHash();\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    setCurrentNotePathToHash() {\n        const activeTabContext = this.getActiveTabContext();\n\n        if (window.history.length === 0 // first history entry\n            || (activeTabContext && activeTabContext.notePath !== treeService.getHashValueFromAddress()[0])) {\n            const url = '#' + (activeTabContext.notePath || \"\") + \"-\" + activeTabContext.tabId;\n\n            // using pushState instead of directly modifying document.location because it does not trigger hashchange\n            window.history.pushState(null, \"\", url);\n\n            document.title = \"Trilium Notes\";\n\n            if (activeTabContext.note) {\n                // it helps navigating in history if note title is included in the title\n                document.title += \" - \" + activeTabContext.note.title;\n            }\n        }\n\n        this.triggerEvent('activeNoteChanged'); // trigger this even in on popstate event\n    }\n\n    /** @return {TabContext[]} */\n    getTabContexts() {\n        return this.tabContexts;\n    }\n\n    /** @returns {TabContext} */\n    getTabContextById(tabId) {\n        return this.tabContexts.find(tc => tc.tabId === tabId);\n    }\n\n    /** @returns {TabContext} */\n    getActiveTabContext() {\n        return this.getTabContextById(this.activeTabId);\n    }\n\n    /** @returns {string|null} */\n    getActiveTabNotePath() {\n        const activeContext = this.getActiveTabContext();\n        return activeContext ? activeContext.notePath : null;\n    }\n\n    /** @return {NoteShort} */\n    getActiveTabNote() {\n        const activeContext = this.getActiveTabContext();\n        return activeContext ? activeContext.note : null;\n    }\n\n    /** @return {string|null} */\n    getActiveTabNoteId() {\n        const activeNote = this.getActiveTabNote();\n\n        return activeNote ? activeNote.noteId : null;\n    }\n\n    /** @return {string|null} */\n    getActiveTabNoteType() {\n        const activeNote = this.getActiveTabNote();\n\n        return activeNote ? activeNote.type : null;\n    }\n\n    async switchToTab(tabId, notePath) {\n        const tabContext = this.tabContexts.find(tc => tc.tabId === tabId)\n            || await this.openEmptyTab();\n\n        this.activateTab(tabContext.tabId);\n        await tabContext.setNote(notePath);\n    }\n\n    async openAndActivateEmptyTab() {\n        const tabContext = await this.openEmptyTab();\n\n        await this.activateTab(tabContext.tabId);\n\n        await tabContext.setEmpty();\n    }\n\n    async openEmptyTab(tabId) {\n        const tabContext = new TabContext(tabId);\n        this.child(tabContext);\n\n        await this.triggerEvent('newTabOpened', {tabContext});\n\n        return tabContext;\n    }\n\n    async openTabWithNote(notePath, activate, tabId = null) {\n        const tabContext = await this.openEmptyTab(tabId);\n\n        if (notePath) {\n            await tabContext.setNote(notePath, !activate); // if activate is false then send normal noteSwitched event\n        }\n\n        if (activate) {\n            this.activateTab(tabContext.tabId, false);\n\n            await this.triggerEvent('tabNoteSwitchedAndActivated', {\n                tabContext,\n                notePath: tabContext.notePath // resolved note path\n            });\n        }\n    }\n\n    async activateOrOpenNote(noteId) {\n        for (const tabContext of this.getTabContexts()) {\n            if (tabContext.note && tabContext.note.noteId === noteId) {\n                this.activateTab(tabContext.tabId);\n\n                return;\n            }\n        }\n\n        // if no tab with this note has been found we'll create new tab\n\n        await this.openTabWithNote(noteId, true);\n    }\n\n    activateTab(tabId, triggerEvent = true) {\n        if (tabId === this.activeTabId) {\n            return;\n        }\n\n        this.activeTabId = tabId;\n\n        if (triggerEvent) {\n            this.triggerEvent('activeTabChanged', {\n                tabContext: this.getTabContextById(tabId)\n            });\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n\n        this.setCurrentNotePathToHash();\n    }\n\n    async removeTab(tabId) {\n        const tabContextToRemove = this.getTabContextById(tabId);\n\n        if (!tabContextToRemove) {\n            return;\n        }\n\n        // close dangling autocompletes after closing the tab\n        $(\".aa-input\").autocomplete(\"close\");\n\n        await this.triggerEvent('beforeTabRemove', {tabId});\n\n        if (this.tabContexts.length <= 1) {\n            this.openAndActivateEmptyTab();\n        }\n        else if (tabContextToRemove.isActive()) {\n            const idx = this.tabContexts.findIndex(tc => tc.tabId === tabId);\n\n            if (idx === this.tabContexts.length - 1) {\n                this.activatePreviousTabCommand();\n            }\n            else {\n                this.activateNextTabCommand();\n            }\n        }\n\n        this.children = this.children.filter(tc => tc.tabId !== tabId);\n\n        this.triggerEvent('tabRemoved', {tabId});\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    tabReorderEvent({tabIdsInOrder}) {\n        const order = {};\n\n        for (const i in tabIdsInOrder) {\n            order[tabIdsInOrder[i]] = i;\n        }\n\n        this.children.sort((a, b) => order[a.tabId] < order[b.tabId] ? -1 : 1);\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    activateNextTabCommand() {\n        const oldIdx = this.tabContexts.findIndex(tc => tc.tabId === this.activeTabId);\n        const newActiveTabId = this.tabContexts[oldIdx === this.tabContexts.length - 1 ? 0 : oldIdx + 1].tabId;\n\n        this.activateTab(newActiveTabId);\n    }\n\n    activatePreviousTabCommand() {\n        const oldIdx = this.tabContexts.findIndex(tc => tc.tabId === this.activeTabId);\n        const newActiveTabId = this.tabContexts[oldIdx === 0 ? this.tabContexts.length - 1 : oldIdx - 1].tabId;\n\n        this.activateTab(newActiveTabId);\n    }\n\n    closeActiveTabCommand() {\n        this.removeTab(this.activeTabId);\n    }\n\n    beforeUnloadEvent() {\n        this.tabsUpdate.updateNowIfNecessary();\n    }\n\n    openNewTabCommand() {\n        this.openAndActivateEmptyTab();\n    }\n\n    async removeAllTabsCommand() {\n        for (const tabIdToRemove of this.tabContexts.map(tc => tc.tabId)) {\n            await this.removeTab(tabIdToRemove);\n        }\n    }\n\n    async removeAllTabsExceptForThisCommand({tabId}) {\n        for (const tabIdToRemove of this.tabContexts.map(tc => tc.tabId)) {\n            if (tabIdToRemove !== tabId) {\n                await this.removeTab(tabIdToRemove);\n            }\n        }\n    }\n\n    moveTabToNewWindowCommand({tabId}) {\n        const notePath = this.getTabContextById(tabId).notePath;\n\n        this.removeTab(tabId);\n\n        this.triggerCommand('openInWindow', {notePath});\n    }\n\n    async hoistedNoteChangedEvent({hoistedNoteId}) {\n        if (hoistedNoteId === 'root') {\n            return;\n        }\n\n        for (const tc of this.tabContexts.splice()) {\n            if (tc.notePath && !tc.notePath.split(\"/\").includes(hoistedNoteId)) {\n                await this.removeTab(tc.tabId);\n            }\n        }\n    }\n}\n","import Component from \"../component.js\";\n\nexport default class MobileScreenSwitcherExecutor extends Component {\n    setActiveScreenCommand({screen}) {\n        if (screen !== this.activeScreen) {\n            this.activeScreen = screen;\n\n            this.triggerEvent('activeScreenChanged', {activeScreen: screen});\n        }\n    }\n\n    initialRenderCompleteEvent() {\n        this.setActiveScreenCommand({screen: 'tree'});\n    }\n}","import appContext from \"./app_context.js\";\nimport noteCreateService from \"./note_create.js\";\nimport treeService from \"./tree.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport Component from \"../widgets/component.js\";\nimport ws from \"./ws.js\";\n\n/**\n * This class contains command executors which logically belong to the NoteTree widget, but for better user experience\n * the keyboard shortcuts must be active on the whole screen and not just on the widget itself, so the executors\n * must be at the root of the component tree.\n */\nexport default class MainTreeExecutors extends Component {\n    get tree() {\n        return appContext.mainTreeWidget;\n    }\n\n    async cloneNotesToCommand() {\n        const selectedOrActiveNoteIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.noteId);\n\n        this.triggerCommand('cloneNoteIdsTo', {noteIds: selectedOrActiveNoteIds});\n    }\n\n    async moveNotesToCommand() {\n        const selectedOrActiveBranchIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.branchId);\n\n        this.triggerCommand('moveBranchIdsTo', {branchIds: selectedOrActiveBranchIds});\n    }\n\n    async createNoteIntoCommand() {\n        const activeNote = appContext.tabManager.getActiveTabNote();\n\n        if (!activeNote) {\n            return;\n        }\n\n        await noteCreateService.createNote(activeNote.noteId, {\n            isProtected: activeNote.isProtected,\n            saveSelection: false\n        });\n    }\n\n    async createNoteAfterCommand() {\n        const node = this.tree.getActiveNode();\n        const parentNoteId = node.data.parentNoteId;\n        const isProtected = await treeService.getParentProtectedStatus(node);\n\n        if (node.data.noteId === 'root' || node.data.noteId === hoistedNoteService.getHoistedNoteId()) {\n            return;\n        }\n\n        await noteCreateService.createNote(parentNoteId, {\n            target: 'after',\n            targetBranchId: node.data.branchId,\n            isProtected: isProtected,\n            saveSelection: false\n        });\n    }\n}\n","import treeCache from \"./tree_cache.js\";\nimport bundleService from \"./bundle.js\";\nimport DialogCommandExecutor from \"./dialog_command_executor.js\";\nimport Entrypoints from \"./entrypoints.js\";\nimport options from \"./options.js\";\nimport utils from \"./utils.js\";\nimport zoomService from \"./zoom.js\";\nimport TabManager from \"./tab_manager.js\";\nimport treeService from \"./tree.js\";\nimport Component from \"../widgets/component.js\";\nimport keyboardActionsService from \"./keyboard_actions.js\";\nimport MobileScreenSwitcherExecutor from \"../widgets/mobile_widgets/mobile_screen_switcher.js\";\nimport MainTreeExecutors from \"./main_tree_executors.js\";\n\nclass AppContext extends Component {\n    constructor(isMainWindow) {\n        super();\n\n        this.isMainWindow = isMainWindow;\n        this.executors = [];\n    }\n\n    setLayout(layout) {\n        this.layout = layout;\n    }\n\n    async start() {\n        await Promise.all([treeCache.initializedPromise, options.initializedPromise]);\n\n        $(\"#loading-indicator\").hide();\n\n        this.showWidgets();\n\n        this.tabManager.loadTabs();\n\n        if (utils.isDesktop()) {\n            setTimeout(() => bundleService.executeStartupBundles(), 2000);\n        }\n    }\n\n    showWidgets() {\n        const rootWidget = this.layout.getRootWidget(this);\n        const $renderedWidget = rootWidget.render();\n\n        keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n        $(\"body\").append($renderedWidget);\n\n        $renderedWidget.on('click', \"[data-trigger-command]\", function() {\n            const commandName = $(this).attr('data-trigger-command');\n            const $component = $(this).closest(\".component\");\n            const component = $component.prop(\"component\");\n\n            component.triggerCommand(commandName, {$el: $(this)});\n        });\n\n        this.tabManager = new TabManager();\n\n        this.executors = [\n            this.tabManager,\n            new DialogCommandExecutor(),\n            new Entrypoints(),\n            new MainTreeExecutors()\n        ];\n\n        if (utils.isMobile()) {\n            this.executors.push(new MobileScreenSwitcherExecutor());\n        }\n\n        this.child(rootWidget);\n\n        for (const executor of this.executors) {\n            this.child(executor);\n        }\n\n        if (utils.isElectron()) {\n            this.child(zoomService);\n        }\n\n        this.triggerEvent('initialRenderComplete');\n    }\n\n    /** @return {Promise} */\n    triggerEvent(name, data) {\n        return this.handleEvent(name, data);\n    }\n\n    /** @return {Promise} */\n    triggerCommand(name, data = {}) {\n        for (const executor of this.executors) {\n            const fun = executor[name + \"Command\"];\n\n            if (fun) {\n                return executor.callMethod(fun, data);\n            }\n        }\n\n        // this might hint at error but sometimes this is used by components which are at different places\n        // in the component tree to communicate with each other\n        console.debug(`Unhandled command ${name}, converting to event.`);\n\n        return this.triggerEvent(name, data);\n    }\n\n    getComponentByEl(el) {\n        return $(el).closest(\".component\").prop('component');\n    }\n}\n\nconst appContext = new AppContext(window.glob.isMainWindow);\n\n// we should save all outstanding changes before the page/app is closed\n$(window).on('beforeunload', () => {\n    appContext.triggerEvent('beforeUnload');\n});\n\nfunction isNotePathInAddress() {\n    const [notePath, tabId] = treeService.getHashValueFromAddress();\n\n    return notePath.startsWith(\"root\")\n        // empty string is for empty/uninitialized tab\n        || (notePath === '' && !!tabId);\n}\n\n$(window).on('hashchange', function() {\n    if (isNotePathInAddress()) {\n        const [notePath, tabId] = treeService.getHashValueFromAddress();\n\n        if (!notePath) {\n            console.log(`Invalid hash value \"${document.location.hash}\", ignoring.`);\n            return;\n        }\n\n        appContext.tabManager.switchToTab(tabId, notePath);\n    }\n});\n\nexport default appContext;\n","import ScriptContext from \"./script_context.js\";\nimport server from \"./server.js\";\nimport toastService from \"./toast.js\";\n\nasync function getAndExecuteBundle(noteId, originEntity = null) {\n    const bundle = await server.get('script/bundle/' + noteId);\n\n    return await executeBundle(bundle, originEntity);\n}\n\nasync function executeBundle(bundle, originEntity, $container) {\n    const apiContext = await ScriptContext(bundle.noteId, bundle.allNoteIds, originEntity, $container);\n\n    try {\n        return await (function () {\n            return eval(`const apiContext = this; (async function() { ${bundle.script}\\r\\n})()`);\n        }.call(apiContext));\n    }\n    catch (e) {\n        toastService.showAndLogError(`Execution of ${bundle.noteId} failed with error: ${e.message}`);\n    }\n}\n\nasync function executeStartupBundles() {\n    const scriptBundles = await server.get(\"script/startup\");\n\n    for (const bundle of scriptBundles) {\n        await executeBundle(bundle);\n    }\n}\n\nclass WidgetsByParent {\n    constructor() {\n        this.byParent = {};\n    }\n\n    add(widget) {\n        if (!widget.parentWidget) {\n            console.log(`Custom widget does not have mandatory 'getParent()' method defined`);\n            return;\n        }\n\n        this.byParent[widget.parentWidget] = this.byParent[widget.parentWidget] || [];\n        this.byParent[widget.parentWidget].push(widget);\n    }\n\n    get(parentName) {\n        return this.byParent[parentName] || [];\n    }\n}\n\nasync function getWidgetBundlesByParent() {\n    const scriptBundles = await server.get(\"script/widgets\");\n\n    const widgetsByParent = new WidgetsByParent();\n\n    for (const bundle of scriptBundles) {\n        let widget;\n\n        try {\n            widget = await executeBundle(bundle);\n        }\n        catch (e) {\n            console.error(\"Widget initialization failed: \", e);\n            continue;\n        }\n\n        widgetsByParent.add(widget);\n    }\n\n    return widgetsByParent;\n}\n\nexport default {\n    executeBundle,\n    getAndExecuteBundle,\n    executeStartupBundles,\n    getWidgetBundlesByParent\n}\n","import treeCache from \"./tree_cache.js\";\nimport server from \"./server.js\";\n\n/** @return {NoteShort} */\nasync function getTodayNote() {\n    return await getDateNote(dayjs().format(\"YYYY-MM-DD\"));\n}\n\n/** @return {NoteShort} */\nasync function getDateNote(date) {\n    const note = await server.get('date-notes/date/' + date, \"date-note\");\n\n    return await treeCache.getNote(note.noteId);\n}\n\n/** @return {NoteShort} */\nasync function getMonthNote(month) {\n    const note = await server.get('date-notes/month/' + month, \"date-note\");\n\n    return await treeCache.getNote(note.noteId);\n}\n\n/** @return {NoteShort} */\nasync function getYearNote(year) {\n    const note = await server.get('date-notes/year/' + year, \"date-note\");\n\n    return await treeCache.getNote(note.noteId);\n}\n\nexport default {\n    getTodayNote,\n    getDateNote,\n    getMonthNote,\n    getYearNote\n}","import options from './options.js';\nimport appContext from \"./app_context.js\";\nimport treeService from \"./tree.js\";\n\nfunction getHoistedNoteId() {\n    return options.get('hoistedNoteId');\n}\n\nasync function setHoistedNoteId(noteId) {\n    await options.save('hoistedNoteId', noteId);\n\n    // FIXME - just use option load event\n    appContext.triggerEvent('hoistedNoteChanged', {noteId});\n}\n\nasync function unhoist() {\n    await setHoistedNoteId('root');\n}\n\nfunction isTopLevelNode(node) {\n    return isRootNode(node.getParent());\n}\n\nfunction isRootNode(node) {\n    // even though check for 'root' should not be necessary, we keep it just in case\n    return node.data.noteId === \"root\"\n        || node.data.noteId === getHoistedNoteId();\n}\n\nasync function checkNoteAccess(notePath) {\n    // notePath argument can contain only noteId which is not good when hoisted since\n    // then we need to check the whole note path\n    const runNotePath = await treeService.getRunPath(notePath);\n\n    if (!runNotePath) {\n        console.log(\"Cannot activate \" + notePath);\n        return false;\n    }\n\n    const hoistedNoteId = getHoistedNoteId();\n\n    if (hoistedNoteId !== 'root' && !runNotePath.includes(hoistedNoteId)) {\n        const confirmDialog = await import('../dialogs/confirm.js');\n\n        if (!await confirmDialog.confirm(\"Requested note is outside of hoisted note subtree and you must unhoist to access the note. Do you want to proceed with unhoisting?\")) {\n            return false;\n        }\n\n        // unhoist so we can activate the note\n        await unhoist();\n    }\n\n    return true;\n}\n\nexport default {\n    getHoistedNoteId,\n    setHoistedNoteId,\n    unhoist,\n    isTopLevelNode,\n    isRootNode,\n    checkNoteAccess\n}","import server from \"./server.js\";\nimport utils from \"./utils.js\";\nimport appContext from \"./app_context.js\";\n\nconst keyboardActionRepo = {};\n\nconst keyboardActionsLoaded = server.get('keyboard-actions').then(actions => {\n\tactions = actions.filter(a => !!a.actionName); // filter out separators\n\n\tfor (const action of actions) {\n\t\taction.effectiveShortcuts = action.effectiveShortcuts.filter(shortcut => !shortcut.startsWith(\"global:\"));\n\n\t\tkeyboardActionRepo[action.actionName] = action;\n\t}\n\n\treturn actions;\n});\n\nasync function getActionsForScope(scope) {\n\tconst actions = await keyboardActionsLoaded;\n\n\treturn actions.filter(action => action.scope === scope);\n}\n\nasync function setupActionsForElement(scope, $el, component) {\n\tconst actions = await getActionsForScope(scope);\n\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tutils.bindElShortcut($el, shortcut, () => component.triggerCommand(action.actionName));\n\t\t}\n\t}\n}\n\ngetActionsForScope(\"window\").then(actions => {\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tutils.bindGlobalShortcut(shortcut, () => appContext.triggerCommand(action.actionName));\n\t\t}\n\t}\n});\n\nserver.get('keyboard-shortcuts-for-notes').then(shortcutForNotes => {\n\tfor (const shortcut in shortcutForNotes) {\n\t\tutils.bindGlobalShortcut(shortcut, async () => {\n\t\t\tappContext.tabManager.getActiveTabContext().setNote(shortcutForNotes[shortcut]);\n\t\t});\n\t}\n});\n\nfunction setElementActionHandler($el, actionName, handler) {\n\tkeyboardActionsLoaded.then(() => {\n\t\tconst action = keyboardActionRepo[actionName];\n\n\t\tif (!action) {\n\t\t\tthrow new Error(`Cannot find keyboard action '${actionName}'`);\n\t\t}\n\n\t\t// not setting action.handler since this is not global\n\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tif (shortcut) {\n\t\t\t\tutils.bindElShortcut($el, shortcut, handler);\n\t\t\t}\n\t\t}\n\t});\n}\n\nasync function getAction(actionName, silent = false) {\n\tawait keyboardActionsLoaded;\n\n\tconst action = keyboardActionRepo[actionName];\n\n\tif (!action) {\n\t\tif (silent) {\n\t\t\tconsole.log(`Cannot find action ${actionName}`);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`Cannot find action ${actionName}`);\n\t\t}\n\t}\n\n\treturn action;\n}\n\nfunction updateDisplayedShortcuts($container) {\n\t$container.find('kbd[data-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\t$(el).text(action.effectiveShortcuts.join(', '));\n\t\t}\n\t});\n\n\t$container.find('[data-trigger-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-trigger-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\tconst title = $(el).attr('title');\n\t\t\tconst shortcuts = action.effectiveShortcuts.join(', ');\n\t\t\tconst newTitle = !title || !title.trim() ? shortcuts : `${title} (${shortcuts})`;\n\n\t\t\t$(el).attr('title', newTitle);\n\t\t}\n\t});\n}\n\nexport default {\n\tsetElementActionHandler,\n\tupdateDisplayedShortcuts,\n\tsetupActionsForElement,\n\tgetActionsForScope\n};","import keyboardActionService from './keyboard_actions.js';\n\nclass ContextMenu {\n    constructor() {\n        this.$widget = $(\"#context-menu-container\");\n        this.dateContextMenuOpenedMs = 0;\n\n        $(document).on('click', () => this.hide());\n    }\n    \n    async show(options) {\n        this.options = options;\n        \n        this.$widget.empty();\n\n        this.addItems(this.$widget, options.items);\n\n        keyboardActionService.updateDisplayedShortcuts(this.$widget);\n\n        this.positionMenu();\n\n        this.dateContextMenuOpenedMs = Date.now();\n    }\n\n    positionMenu() {\n        // code below tries to detect when dropdown would overflow from page\n        // in such case we'll position it above click coordinates so it will fit into client\n        const clientHeight = document.documentElement.clientHeight;\n        const contextMenuHeight = this.$widget.outerHeight() + 30;\n        let top;\n\n        if (this.options.y + contextMenuHeight > clientHeight) {\n            top = clientHeight - contextMenuHeight - 10;\n        } else {\n            top = this.options.y - 10;\n        }\n\n        this.$widget.css({\n            display: \"block\",\n            top: top,\n            left: this.options.x - 20\n        }).addClass(\"show\");\n    }\n\n    addItems($parent, items) {\n        for (const item of items) {\n            if (item.title === '----') {\n                $parent.append($(\"<div>\").addClass(\"dropdown-divider\"));\n            } else {\n                const $icon = $(\"<span>\");\n\n                if (item.uiIcon) {\n                    $icon.addClass(\"bx bx-\" + item.uiIcon);\n                } else {\n                    $icon.append(\"&nbsp;\");\n                }\n\n                const $link = $(\"<span>\")\n                    .append($icon)\n                    .append(\" &nbsp; \") // some space between icon and text\n                    .append(item.title);\n\n                const $item = $(\"<li>\")\n                    .addClass(\"dropdown-item\")\n                    .append($link)\n                    // important to use mousedown instead of click since the former does not change focus\n                    // (especially important for focused text for spell check)\n                    .on('mousedown', (e) => {\n                        e.stopPropagation();\n\n                        this.hide();\n\n                        if (item.handler) {\n                            item.handler(item, e);\n                        }\n\n                        this.options.selectMenuItemHandler(item, e);\n\n                        // it's important to stop the propagation especially for sub-menus, otherwise the event\n                        // might be handled again by top-level menu\n                        return false;\n                    });\n\n                if (item.enabled !== undefined && !item.enabled) {\n                    $item.addClass(\"disabled\");\n                }\n\n                if (item.items) {\n                    $item.addClass(\"dropdown-submenu\");\n                    $link.addClass(\"dropdown-toggle\");\n\n                    const $subMenu = $(\"<ul>\").addClass(\"dropdown-menu\");\n\n                    this.addItems($subMenu, item.items);\n\n                    $item.append($subMenu);\n                }\n\n                $parent.append($item);\n            }\n        }\n    }\n\n    hide() {\n        // this date checking comes from change in FF66 - https://github.com/zadam/trilium/issues/468\n        // \"contextmenu\" event also triggers \"click\" event which depending on the timing can close just opened context menu\n        // we might filter out right clicks, but then it's better if even right clicks close the context menu\n        if (Date.now() - this.dateContextMenuOpenedMs > 300) {\n            this.$widget.hide();\n        }\n    }\n}\n\nconst contextMenu = new ContextMenu();\n\nexport default contextMenu;","import treeService from './tree.js';\nimport contextMenu from \"./context_menu.js\";\nimport appContext from \"./app_context.js\";\n\nfunction getNotePathFromUrl(url) {\n    const notePathMatch = /#(root[A-Za-z0-9/]*)$/.exec(url);\n\n    return notePathMatch === null ? null : notePathMatch[1];\n}\n\nasync function createNoteLink(notePath, options = {}) {\n    if (!notePath || !notePath.trim()) {\n        console.error(\"Missing note path\");\n\n        return $(\"<span>\").text(\"[missing note]\");\n    }\n\n    let noteTitle = options.title;\n    const showTooltip = options.showTooltip === undefined ? true : options.showTooltip;\n    const showNotePath = options.showNotePath === undefined ? false : options.showNotePath;\n\n    if (!noteTitle) {\n        const {noteId, parentNoteId} = treeService.getNoteIdAndParentIdFromNotePath(notePath);\n\n        noteTitle = await treeService.getNoteTitle(noteId, parentNoteId);\n    }\n\n    const $noteLink = $(\"<a>\", {\n        href: 'javascript:',\n        text: noteTitle\n    }).attr('data-action', 'note')\n        .attr('data-note-path', notePath);\n\n    if (!showTooltip) {\n        $noteLink.addClass(\"no-tooltip-preview\");\n    }\n\n    const $container = $(\"<span>\").append($noteLink);\n\n    if (showNotePath) {\n        notePath = await treeService.resolveNotePath(notePath);\n\n        if (notePath) {\n            const noteIds = notePath.split(\"/\");\n            noteIds.pop(); // remove last element\n\n            const parentNotePath = noteIds.join(\"/\").trim();\n\n            if (parentNotePath) {\n                $container.append($(\"<small>\").text(\" (\" + await treeService.getNotePathTitle(parentNotePath) + \")\"));\n            }\n        }\n    }\n\n    return $container;\n}\n\nfunction getNotePathFromLink($link) {\n    const notePathAttr = $link.attr(\"data-note-path\");\n\n    if (notePathAttr) {\n        return notePathAttr;\n    }\n\n    const url = $link.attr('href');\n\n    return url ? getNotePathFromUrl(url) : null;\n}\n\nfunction goToLink(e) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    const $link = $(e.target).closest(\"a\");\n\n    const notePath = getNotePathFromLink($link);\n\n    if (notePath) {\n        if ((e.which === 1 && e.ctrlKey) || e.which === 2) {\n            appContext.tabManager.openTabWithNote(notePath);\n        }\n        else if (e.which === 1) {\n            const activeTabContext = appContext.tabManager.getActiveTabContext();\n            activeTabContext.setNote(notePath);\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        if (e.which === 1) {\n            const address = $link.attr('href');\n\n            if (address && address.startsWith('http')) {\n                window.open(address, '_blank');\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction linkContextMenu(e) {\n    const $link = $(e.target).closest(\"a\");\n\n    const notePath = getNotePathFromLink($link);\n\n    if (!notePath) {\n        return;\n    }\n\n    e.preventDefault();\n\n    contextMenu.show({\n        x: e.pageX,\n        y: e.pageY,\n        items: [\n            {title: \"Open note in new tab\", command: \"openNoteInNewTab\", uiIcon: \"empty\"},\n            {title: \"Open note in new window\", command: \"openNoteInNewWindow\", uiIcon: \"window-open\"}\n        ],\n        selectMenuItemHandler: ({command}) => {\n            if (command === 'openNoteInNewTab') {\n                appContext.tabManager.openTabWithNote(notePath);\n            }\n            else if (command === 'openNoteInNewWindow') {\n                appContext.openInNewWindow(notePath);\n            }\n        }\n    });\n}\n\n// when click on link popup, in case of internal link, just go the the referenced note instead of default behavior\n// of opening the link in new window/tab\n$(document).on('mousedown', \"a[data-action='note']\", goToLink);\n$(document).on('mousedown', 'div.popover-content a, div.ui-tooltip-content a', goToLink);\n$(document).on('dblclick', '.note-detail-text a', goToLink);\n$(document).on('mousedown', '.note-detail-text a:not(.reference-link)', function (e) {\n    const $link = $(e.target).closest(\"a\");\n    const notePath = getNotePathFromLink($link);\n\n    if ((e.which === 1 && e.ctrlKey) || e.which === 2) {\n        // if it's a ctrl-click, then we open on new tab, otherwise normal flow (CKEditor opens link-editing dialog)\n        e.preventDefault();\n\n        if (notePath) {\n            appContext.tabManager.openTabWithNote(notePath, false);\n        }\n        else {\n            const address = $link.attr('href');\n\n            window.open(address, '_blank');\n        }\n\n        return true;\n    }\n});\n\n$(document).on('mousedown', '.note-detail-book a', goToLink);\n$(document).on('mousedown', '.note-detail-render a', goToLink);\n$(document).on('mousedown', '.note-detail-text a.reference-link', goToLink);\n$(document).on('mousedown', '.note-detail-readonly-text a.reference-link', goToLink);\n$(document).on('mousedown', '.note-detail-readonly-text a', goToLink);\n$(document).on('mousedown', 'a.ck-link-actions__preview', goToLink);\n$(document).on('click', 'section.include-note a', goToLink);\n$(document).on('click', 'a.ck-link-actions__preview', e => {\n    e.preventDefault();\n    e.stopPropagation();\n});\n\n$(document).on('contextmenu', 'a.ck-link-actions__preview', linkContextMenu);\n$(document).on('contextmenu', '.note-detail-text a', linkContextMenu);\n$(document).on('contextmenu', '.note-detail-readonly-text a', linkContextMenu);\n$(document).on('contextmenu', \"a[data-action='note']\", linkContextMenu);\n$(document).on('contextmenu', \".note-detail-render a\", linkContextMenu);\n$(document).on('contextmenu', \".note-paths-widget a\", linkContextMenu);\n$(document).on('contextmenu', \"section.include-note a\", linkContextMenu);\n\nexport default {\n    getNotePathFromUrl,\n    createNoteLink,\n    goToLink\n};\n","/**\n * Purpose of this class is to cache list of attributes for notes.\n *\n * Cache invalidation granularity is global - whenever a write operation is detected to notes, branches or attributes\n * we invalidate the whole cache. That's OK, since the purpose for this is to speed up batch read-only operations, such\n * as loading the tree which uses attributes heavily.\n */\nclass NoteAttributeCache {\n    constructor() {\n        this.attributes = {};\n    }\n\n    invalidate() {\n        this.attributes = {};\n    }\n}\n\nconst noteAttributeCache = new NoteAttributeCache();\n\nexport default noteAttributeCache;","import server from \"./server.js\";\n\nclass Options {\n    constructor() {\n        this.initializedPromise = server.get('options').then(data => this.load(data));\n    }\n\n    load(arr) {\n        this.arr = arr;\n    }\n\n    get(key) {\n        return this.arr[key];\n    }\n\n    getNames() {\n        return Object.keys(this.arr);\n    }\n\n    getJson(key) {\n        try {\n            return JSON.parse(this.arr[key]);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n\n    getInt(key) {\n        return parseInt(this.arr[key]);\n    }\n\n    getFloat(key) {\n        return parseFloat(this.arr[key]);\n    }\n\n    is(key) {\n        return this.arr[key] === 'true';\n    }\n\n    set(key, value) {\n        this.arr[key] = value;\n    }\n\n    async save(key, value) {\n        this.set(key, value);\n\n        const payload = {};\n        payload[key] = value;\n\n        await server.put(`options`, payload);\n    }\n}\n\nconst options = new Options();\n\nexport default options;","import utils from './utils.js';\nimport server from './server.js';\nimport protectedSessionHolder from './protected_session_holder.js';\nimport toastService from \"./toast.js\";\nimport ws from \"./ws.js\";\nimport appContext from \"./app_context.js\";\nimport treeCache from \"./tree_cache.js\";\n\nlet protectedSessionDeferred = null;\n\nasync function leaveProtectedSession() {\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        protectedSessionHolder.resetProtectedSession();\n    }\n}\n\n/** returned promise resolves with true if new protected session was established, false if no action was necessary */\nfunction enterProtectedSession() {\n    const dfd = $.Deferred();\n\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        dfd.resolve(false);\n    }\n    else {\n        // using deferred instead of promise because it allows resolving from outside\n        protectedSessionDeferred = dfd;\n\n        import(\"../dialogs/protected_session.js\").then(dialog => dialog.show());\n    }\n\n    return dfd.promise();\n}\n\nasync function reloadData() {\n    const allNoteIds = Object.keys(treeCache.notes);\n\n    await treeCache.loadInitialTree();\n\n    // make sure that all notes used in the application are loaded, including the ones not shown in the tree\n    await treeCache.reloadNotes(allNoteIds, true);\n}\n\nasync function setupProtectedSession(password) {\n    const response = await enterProtectedSessionOnServer(password);\n\n    if (!response.success) {\n        toastService.showError(\"Wrong password.\", 3000);\n        return;\n    }\n\n    protectedSessionHolder.setProtectedSessionId(response.protectedSessionId);\n    protectedSessionHolder.touchProtectedSession();\n\n    await reloadData();\n\n    await appContext.triggerEvent('treeCacheReloaded');\n\n    appContext.triggerEvent('protectedSessionStarted');\n\n    if (protectedSessionDeferred !== null) {\n        import(\"../dialogs/protected_session.js\").then(dialog => dialog.close());\n\n        protectedSessionDeferred.resolve(true);\n        protectedSessionDeferred = null;\n    }\n\n    toastService.showMessage(\"Protected session has been started.\");\n}\n\nasync function enterProtectedSessionOnServer(password) {\n    return await server.post('login/protected', {\n        password: password\n    });\n}\n\nasync function protectNote(noteId, protect, includingSubtree) {\n    await enterProtectedSession();\n\n    await server.put(`notes/${noteId}/protect/${protect ? 1 : 0}?subtree=${includingSubtree ? 1 : 0}`);\n}\n\nfunction makeToast(message, protectingLabel, text) {\n    return {\n        id: message.taskId,\n        title: protectingLabel + \" status\",\n        message: text,\n        icon: message.data.protect ? \"check-shield\" : \"shield\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'protect-notes') {\n        return;\n    }\n\n    const protectingLabel = message.data.protect ? \"Protecting\" : \"Unprotecting\";\n\n    if (message.type === 'task-error') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'task-progress-count') {\n        toastService.showPersistent(makeToast(message, protectingLabel,protectingLabel + \" in progress: \" + message.progressCount));\n    } else if (message.type === 'task-succeeded') {\n        const toast = makeToast(message, protectingLabel, protectingLabel + \" finished successfully.\");\n        toast.closeAfter = 3000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nexport default {\n    protectNote,\n    enterProtectedSession,\n    leaveProtectedSession,\n    setupProtectedSession\n};\n","import utils from \"./utils.js\";\nimport options from './options.js';\n\nconst PROTECTED_SESSION_ID_KEY = 'protectedSessionId';\n\nlet lastProtectedSessionOperationDate = 0;\n\nsetInterval(() => {\n    const protectedSessionTimeout = options.getInt('protectedSessionTimeout');\n    if (lastProtectedSessionOperationDate\n        && Date.now() - lastProtectedSessionOperationDate > protectedSessionTimeout * 1000) {\n\n        resetProtectedSession();\n    }\n}, 5000);\n\nfunction setProtectedSessionId(id) {\n    // using session cookie so that it disappears after browser/tab is closed\n    utils.setSessionCookie(PROTECTED_SESSION_ID_KEY, id);\n}\n\nfunction resetProtectedSession() {\n    utils.setSessionCookie(PROTECTED_SESSION_ID_KEY, null);\n\n    // most secure solution - guarantees nothing remained in memory\n    // since this expires because user doesn't use the app, it shouldn't be disruptive\n    utils.reloadApp();\n}\n\nfunction isProtectedSessionAvailable() {\n    return !!utils.getCookie(PROTECTED_SESSION_ID_KEY);\n}\n\nfunction touchProtectedSession() {\n    if (isProtectedSessionAvailable()) {\n        lastProtectedSessionOperationDate = Date.now();\n\n        setProtectedSessionId(utils.getCookie(PROTECTED_SESSION_ID_KEY));\n    }\n}\n\nfunction touchProtectedSessionIfNecessary(note) {\n    if (note && note.isProtected && isProtectedSessionAvailable()) {\n        touchProtectedSession();\n    }\n}\n\nexport default {\n    setProtectedSessionId,\n    resetProtectedSession,\n    isProtectedSessionAvailable,\n    touchProtectedSession,\n    touchProtectedSessionIfNecessary\n};","import treeService from \"./tree.js\";\nimport linkService from \"./link.js\";\nimport treeCache from \"./tree_cache.js\";\nimport utils from \"./utils.js\";\n\nfunction setupGlobalTooltip() {\n    $(document).on(\"mouseenter\", \"a\", mouseEnterHandler);\n    $(document).on(\"mouseleave\", \"a\", mouseLeaveHandler);\n\n    // close any note tooltip after click, this fixes the problem that sometimes tooltips remained on the screen\n    $(document).on(\"click\", () => $('.note-tooltip').remove());\n}\n\nfunction setupElementTooltip($el) {\n    $el.on('mouseenter', mouseEnterHandler);\n    $el.on('mouseleave', mouseLeaveHandler);\n}\n\nasync function mouseEnterHandler() {\n    const $link = $(this);\n\n    if ($link.hasClass(\"no-tooltip-preview\")\n        || $link.hasClass(\"disabled\")\n        || $link.attr(\"data-action\") === 'note-revision') {\n        return;\n    }\n\n    // this is to avoid showing tooltip from inside CKEditor link editor dialog\n    if ($link.closest(\".ck-link-actions\").length) {\n        return;\n    }\n\n    let notePath = linkService.getNotePathFromUrl($link.attr(\"href\"));\n\n    if (!notePath) {\n        notePath = $link.attr(\"data-note-path\");\n    }\n\n    if (!notePath) {\n        return;\n    }\n\n    const noteId = treeService.getNoteIdFromNotePath(notePath);\n\n    const note = await treeCache.getNote(noteId);\n    const noteComplement = await treeCache.getNoteComplement(noteId);\n\n    const html = await renderTooltip(note, noteComplement);\n\n    // we need to check if we're still hovering over the element\n    // since the operation to get tooltip content was async, it is possible that\n    // we now create tooltip which won't close because it won't receive mouseleave event\n    if ($(this).is(\":hover\")) {\n        $(this).tooltip({\n            delay: {\"show\": 300, \"hide\": 100},\n            container: 'body',\n            placement: 'auto',\n            trigger: 'manual',\n            boundary: 'window',\n            title: html,\n            html: true,\n            template: '<div class=\"tooltip note-tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n            sanitize: false\n        });\n\n        $(this).tooltip('show');\n    }\n}\n\nfunction mouseLeaveHandler() {\n    $(this).tooltip('dispose');\n}\n\nasync function renderTooltip(note, noteComplement) {\n    if (note.isDeleted) {\n        return '<div>Note has been deleted.</div>';\n    }\n\n    const attributes = note.getAttributes();\n\n    let content = '';\n\n    const promoted = attributes\n        .filter(attr => attr.type === 'label-definition' || attr.type === 'relation-definition')\n        .filter(attr => !attr.name.startsWith(\"child:\"))\n        .filter(attr => {\n            const json = attr.jsonValue;\n\n            return json && json.isPromoted;\n        });\n\n    if (promoted.length > 0) {\n        const $table = $(\"<table>\").addClass(\"promoted-attributes-in-tooltip\");\n\n        for (const definitionAttr of promoted) {\n            const definitionType = definitionAttr.type;\n            const valueType = definitionType.substr(0, definitionType.length - 11);\n\n            let valueAttrs = attributes.filter(el => el.name === definitionAttr.name && el.type === valueType);\n\n            for (const valueAttr of valueAttrs) {\n                if (!valueAttr.value) {\n                    continue;\n                }\n\n                let $value = \"\";\n\n                if (valueType === 'label') {\n                    $value = $(\"<td>\").text(valueAttr.value);\n                }\n                else if (valueType === 'relation' && valueAttr.value) {\n                    $value = $(\"<td>\").append(await linkService.createNoteLink(valueAttr.value));\n                }\n\n                const $row = $(\"<tr>\")\n                    .append($(\"<th>\").text(definitionAttr.name))\n                    .append($value);\n\n                $table.append($row);\n            }\n        }\n\n        content += $table.prop('outerHTML');\n    }\n\n    if (note.type === 'text' && !utils.isHtmlEmpty(noteComplement.content)) {\n        content += '<div class=\"ck-content\">' + noteComplement.content + '</div>';\n    }\n    else if (note.type === 'code' && noteComplement.content && noteComplement.content.trim()) {\n        content += $(\"<pre>\")\n            .text(noteComplement.content)\n            .prop('outerHTML');\n    }\n    else if (note.type === 'image') {\n        content += $(\"<img>\")\n            .prop(\"src\", `api/images/${note.noteId}/${note.title}`)\n            .prop('outerHTML');\n    }\n    // other types of notes don't have tooltip preview\n\n    return content;\n}\n\nexport default {\n    setupGlobalTooltip,\n    setupElementTooltip\n}","import Component from \"./component.js\";\n\nclass BasicWidget extends Component {\n    constructor() {\n        super();\n\n        this.attrs = {\n            style: ''\n        };\n        this.classes = [];\n    }\n\n    id(id) {\n        this.attrs.id = id;\n        return this;\n    }\n\n    class(className) {\n        this.classes.push(className);\n        return this;\n    }\n\n    css(name, value) {\n        this.attrs.style += `${name}: ${value};`;\n        return this;\n    }\n\n    collapsible() {\n        this.css('min-height', '0');\n        return this;\n    }\n\n    filling() {\n        this.css('flex-grow', '1');\n        return this;\n    }\n\n    hideInZenMode() {\n        this.class('hide-in-zen-mode');\n        return this;\n    }\n\n    cssBlock(block) {\n        this.cssEl = block;\n        return this;\n    }\n\n    render() {\n        const $widget = this.doRender();\n\n        $widget.addClass('component')\n            .prop('component', this);\n\n        this.toggleInt(this.isEnabled());\n\n        if (this.cssEl) {\n            const css = this.cssEl.trim().startsWith('<style>') ? this.cssEl : `<style>${this.cssEl}</style>`;\n\n            $widget.append(css);\n        }\n\n        for (const key in this.attrs) {\n            if (key === 'style') {\n                if (this.attrs[key]) {\n                    let style = $widget.attr('style');\n                    style = style ? `${style}; ${this.attrs[key]}` : this.attrs[key];\n\n                    $widget.attr(key, style);\n                }\n            }\n            else {\n                $widget.attr(key, this.attrs[key]);\n            }\n        }\n\n        for (const className of this.classes) {\n            $widget.addClass(className);\n        }\n\n        return $widget;\n    }\n\n    isEnabled() {\n        return true;\n    }\n\n    /**\n     * for overriding\n     */\n    doRender() {}\n\n    toggleInt(show) {\n        this.$widget.toggleClass('hidden-int', !show);\n    }\n\n    toggleExt(show) {\n        this.$widget.toggleClass('hidden-ext', !show);\n    }\n\n    isVisible() {\n        return this.$widget.is(\":visible\");\n    }\n\n    getPosition() {\n        return this.position;\n    }\n\n    remove() {\n        if (this.$widget) {\n            this.$widget.remove();\n        }\n    }\n\n    cleanup() {}\n}\n\nexport default BasicWidget;\n","import BasicWidget from \"./basic_widget.js\";\nimport appContext from \"../services/app_context.js\";\n\nexport default class TabAwareWidget extends BasicWidget {\n    isTab(tabId) {\n        return this.tabContext && this.tabContext.tabId === tabId;\n    }\n\n    isNote(noteId) {\n        return this.noteId === noteId;\n    }\n\n    get note() {\n        return this.tabContext && this.tabContext.note;\n    }\n\n    get noteId() {\n        return this.note && this.note.noteId;\n    }\n\n    get notePath() {\n        return this.tabContext && this.tabContext.notePath;\n    }\n\n    isEnabled() {\n        return !!this.note;\n    }\n\n    async refresh() {\n        if (this.isEnabled()) {\n            const start = Date.now();\n\n            this.toggleInt(true);\n            await this.refreshWithNote(this.note, this.notePath);\n\n            const end = Date.now();\n\n            if (glob.PROFILING_LOG && end - start > 10) {\n                console.log(`Refresh of ${this.componentId} took ${end-start}ms`);\n            }\n        }\n        else {\n            this.toggleInt(false);\n        }\n    }\n\n    async refreshWithNote(note, notePath) {}\n\n    async tabNoteSwitchedEvent({tabContext, notePath}) {\n        // if notePath does not match then the tabContext has been switched to another note in the mean time\n        if (tabContext.notePath === notePath) {\n            await this.noteSwitched();\n        }\n    }\n\n    async noteSwitched() {\n        await this.refresh();\n    }\n\n    async activeTabChangedEvent({tabContext}) {\n        this.tabContext = tabContext;\n\n        await this.activeTabChanged();\n    }\n\n    async activeTabChanged() {\n        await this.refresh();\n    }\n\n    // when note is both switched and activated, this should not produce double refresh\n    async tabNoteSwitchedAndActivatedEvent({tabContext, notePath}) {\n        this.tabContext = tabContext;\n\n        // if notePath does not match then the tabContext has been switched to another note in the mean time\n        if (this.notePath === notePath) {\n            await this.refresh();\n        }\n    }\n\n    setTabContextEvent({tabContext}) {\n        /** @var {TabContext} */\n        this.tabContext = tabContext;\n    }\n\n    async noteTypeMimeChangedEvent({noteId}) {\n        if (this.isNote(noteId)) {\n            await this.refresh();\n        }\n    }\n\n    async treeCacheReloadedEvent() {\n        await this.refresh();\n    }\n\n    async lazyLoadedEvent() {\n        if (!this.tabContext) { // has not been loaded yet\n            this.tabContext = appContext.tabManager.getActiveTabContext();\n        }\n\n        await this.refresh();\n    }\n}","import TabAwareWidget from \"./tab_aware_widget.js\";\nimport options from \"../services/options.js\";\n\nconst WIDGET_TPL = `\n<div class=\"card widget\">\n    <div class=\"card-header\">\n        <div>           \n            <button class=\"btn btn-sm widget-title\" data-toggle=\"collapse\" data-target=\"#[to be set]\">\n                Collapsible Group Item\n            </button>\n            \n            <a class=\"widget-help external no-arrow bx bx-info-circle\"></a>\n        </div>\n        \n        <div class=\"widget-header-actions\"></div>\n    </div>\n\n    <div id=\"[to be set]\" class=\"collapse body-wrapper\" style=\"transition: none; \">\n        <div class=\"card-body\"></div>\n    </div>\n</div>`;\n\nexport default class CollapsibleWidget extends TabAwareWidget {\n    get widgetTitle() { return \"Untitled widget\"; }\n\n    get headerActions() { return []; }\n\n    get help() { return {}; }\n\n    doRender() {\n        this.$widget = $(WIDGET_TPL);\n        this.$widget.find('[data-target]').attr('data-target', \"#\" + this.componentId);\n\n        this.$bodyWrapper = this.$widget.find('.body-wrapper');\n        this.$bodyWrapper.attr('id', this.componentId); // for toggle to work we need id\n\n        // not using constructor name because of webpack mangling class names ...\n        this.widgetName = this.widgetTitle.replace(/[^[a-zA-Z0-9]/g, \"_\");\n\n        if (!options.is(this.widgetName + 'Collapsed')) {\n            this.$bodyWrapper.collapse(\"show\");\n        }\n\n        // using immediate variants of the event so that the previous collapse is not caught\n        this.$bodyWrapper.on('hide.bs.collapse', () => this.saveCollapsed(true));\n        this.$bodyWrapper.on('show.bs.collapse', () => this.saveCollapsed(false));\n\n        this.$body = this.$bodyWrapper.find('.card-body');\n\n        this.$title = this.$widget.find('.widget-title');\n        this.$title.text(this.widgetTitle);\n\n        this.$help = this.$widget.find('.widget-help');\n\n        if (this.help.title) {\n            this.$help.attr(\"title\", this.help.title);\n            this.$help.attr(\"href\", this.help.url || \"javascript:\");\n\n            if (!this.help.url) {\n                this.$help.addClass('no-link');\n            }\n        }\n        else {\n            this.$help.hide();\n        }\n\n        this.$headerActions = this.$widget.find('.widget-header-actions');\n        this.$headerActions.append(...this.headerActions);\n\n        this.initialized = this.doRenderBody();\n\n        this.decorateWidget();\n\n        return this.$widget;\n    }\n\n    saveCollapsed(collapse) {\n        options.save(this.widgetName + 'Collapsed', collapse.toString());\n\n        this.triggerEvent(`widgetCollapsedStateChanged`, {widgetName: this.widgetName, collapse});\n    }\n\n    /**\n     * This event is used to synchronize collapsed state of all the tab-cached widgets since they are all rendered\n     * separately but should behave uniformly for the user.\n     */\n    widgetCollapsedStateChangedEvent({widgetName, collapse}) {\n        if (widgetName === this.widgetName) {\n            this.$bodyWrapper.toggleClass('show', !collapse);\n        }\n    }\n\n    /** for overriding */\n    decorateWidget() {}\n\n    /** for overriding */\n    async doRenderBody() {}\n\n    isExpanded() {\n        return this.$bodyWrapper.hasClass(\"show\");\n    }\n}","import TabAwareWidget from \"./tab_aware_widget.js\";\nimport keyboardActionsService from \"../services/keyboard_actions.js\";\n\nexport default class TabCachingWidget extends TabAwareWidget {\n    constructor(widgetFactory) {\n        super();\n\n        this.widgetFactory = widgetFactory;\n        this.widgets = {};\n    }\n\n    doRender() {\n        return this.$widget = $(`<div class=\"marker\" style=\"display: none;\">`);\n    }\n\n    async newTabOpenedEvent({tabContext}) {\n        const {tabId} = tabContext;\n\n        if (this.widgets[tabId]) {\n            return;\n        }\n\n        this.widgets[tabId] = this.widgetFactory();\n\n        const $renderedWidget = this.widgets[tabId].render();\n        this.widgets[tabId].toggleExt(false); // new tab is always not active, can be activated after creation\n\n        this.$widget.after($renderedWidget);\n\n        keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n        await this.widgets[tabId].handleEvent('setTabContext', {tabContext});\n\n        this.child(this.widgets[tabId]); // add as child only once it is ready (rendered with tabContext)\n    }\n\n    tabRemovedEvent({tabId}) {\n        const widget = this.widgets[tabId];\n\n        if (widget) {\n            widget.remove();\n            delete this.widgets[tabId];\n\n            this.children = this.children.filter(ch => ch !== widget);\n        }\n    }\n\n    async refresh() {\n        this.toggleExt(true);\n    }\n\n    toggleInt(show) {} // not needed\n\n    toggleExt(show) {\n        for (const tabId in this.widgets) {\n            this.widgets[tabId].toggleExt(show && this.isTab(tabId));\n        }\n    }\n\n    /**\n     * widget.hasBeenAlreadyShown is intended for lazy loading of cached tabs - initial note switches of new tabs\n     * are not executed, we're waiting for the first tab activation and then we update the tab. After this initial\n     * activation further note switches are always propagated to the tabs.\n     */\n    handleEventInChildren(name, data) {\n        if (['tabNoteSwitched', 'tabNoteSwitchedAndActivated'].includes(name)) {\n            // this event is propagated only to the widgets of a particular tab\n            const widget = this.widgets[data.tabContext.tabId];\n\n            if (widget && (widget.hasBeenAlreadyShown || name === 'tabNoteSwitchedAndActivated')) {\n                widget.hasBeenAlreadyShown = true;\n\n                return widget.handleEvent('tabNoteSwitched', data);\n            }\n            else {\n                return Promise.resolve();\n            }\n        }\n\n        if (name === 'activeTabChanged') {\n            const widget = this.widgets[data.tabContext.tabId];\n\n            if (widget.hasBeenAlreadyShown) {\n                return Promise.resolve();\n            }\n            else {\n                widget.hasBeenAlreadyShown = true;\n\n                return widget.handleEvent(name, data);\n            }\n        } else {\n            return super.handleEventInChildren(name, data);\n        }\n    }\n}","import treeService from './tree.js';\nimport server from './server.js';\nimport utils from './utils.js';\nimport toastService from './toast.js';\nimport linkService from './link.js';\nimport treeCache from './tree_cache.js';\nimport noteTooltipService from './note_tooltip.js';\nimport protectedSessionService from './protected_session.js';\nimport dateNotesService from './date_notes.js';\nimport CollapsibleWidget from '../widgets/collapsible_widget.js';\nimport ws from \"./ws.js\";\nimport hoistedNoteService from \"./hoisted_note.js\";\nimport appContext from \"./app_context.js\";\nimport TabAwareWidget from \"../widgets/tab_aware_widget.js\";\nimport TabCachingWidget from \"../widgets/tab_caching_widget.js\";\nimport BasicWidget from \"../widgets/basic_widget.js\";\n\n/**\n * This is the main frontend API interface for scripts. It's published in the local \"api\" object.\n *\n * @constructor\n * @hideconstructor\n */\nfunction FrontendScriptApi(startNote, currentNote, originEntity = null, $container = null) {\n    const $pluginButtons = $(\"#plugin-buttons\");\n\n    /** @property {jQuery} container of all the rendered script content */\n    this.$container = $container;\n\n    /** @property {object} note where script started executing */\n    this.startNote = startNote;\n    /** @property {object} note where script is currently executing */\n    this.currentNote = currentNote;\n    /** @property {object|null} entity whose event triggered this execution */\n    this.originEntity = originEntity;\n\n    // to keep consistency with backend API\n    this.dayjs = dayjs;\n\n    /** @property {CollapsibleWidget} */\n    this.CollapsibleWidget = CollapsibleWidget;\n\n    /** @property {TabAwareWidget} */\n    this.TabAwareWidget = TabAwareWidget;\n\n    /** @property {TabCachingWidget} */\n    this.TabCachingWidget = TabCachingWidget;\n\n    /** @property {BasicWidget} */\n    this.BasicWidget = BasicWidget;\n\n    /**\n     * Activates note in the tree and in the note detail.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @returns {Promise<void>}\n     */\n    this.activateNote = async notePath => {\n        await appContext.tabManager.getActiveTabContext().setNote(notePath);\n    };\n\n    /**\n     * Activates newly created note. Compared to this.activateNote() also makes sure that frontend has been fully synced.\n     *\n     * @param {string} notePath (or noteId)\n     * @return {Promise<void>}\n     */\n    this.activateNewNote = async notePath => {\n        await ws.waitForMaxKnownSyncId();\n\n        await appContext.tabManager.getActiveTabContext().setNote(notePath);\n        appContext.triggerEvent('focusAndSelectTitle');\n    };\n\n    /**\n     * @typedef {Object} ToolbarButtonOptions\n     * @property {string} title\n     * @property {string} [icon] - name of the boxicon to be used (e.g. \"time\" for \"bx-time\" icon)\n     * @property {function} action - callback handling the click on the button\n     * @property {string} [shortcut] - keyboard shortcut for the button, e.g. \"alt+t\"\n     */\n\n    /**\n     * Adds new button the the plugin area.\n     *\n     * @param {ToolbarButtonOptions} opts\n     */\n    this.addButtonToToolbar = opts => {\n        const buttonId = \"toolbar-button-\" + opts.title.replace(/[^a-zA-Z0-9]/g, \"-\");\n\n        const button = $('<button>')\n            .addClass(\"btn btn-sm\")\n            .on('click', opts.action);\n\n        if (opts.icon) {\n            button.append($(\"<span>\").addClass(\"bx bx-\" + opts.icon))\n                  .append(\"&nbsp;\");\n        }\n\n        button.append($(\"<span>\").text(opts.title));\n\n        button.attr('id', buttonId);\n\n        if ($(\"#\" + buttonId).replaceWith(button).length === 0) {\n            $pluginButtons.append(button);\n        }\n\n        if (opts.shortcut) {\n            utils.bindGlobalShortcut(opts.shortcut, opts.action);\n\n            button.attr(\"title\", \"Shortcut \" + opts.shortcut);\n        }\n    };\n\n    function prepareParams(params) {\n        if (!params) {\n            return params;\n        }\n\n        return params.map(p => {\n            if (typeof p === \"function\") {\n                return \"!@#Function: \" + p.toString();\n            }\n            else {\n                return p;\n            }\n        });\n    }\n\n    /**\n     * Executes given anonymous function on the backend.\n     * Internally this serializes the anonymous function into string and sends it to backend via AJAX.\n     *\n     * @param {string} script - script to be executed on the backend\n     * @param {Array.<?>} params - list of parameters to the anonymous function to be send to backend\n     * @return {Promise<*>} return value of the executed function on the backend\n     */\n    this.runOnBackend = async (script, params = []) => {\n        if (typeof script === \"function\") {\n            script = script.toString();\n        }\n\n        const ret = await server.post('script/exec', {\n            script: script,\n            params: prepareParams(params),\n            startNoteId: startNote.noteId,\n            currentNoteId: currentNote.noteId,\n            originEntityName: \"notes\", // currently there's no other entity on frontend which can trigger event\n            originEntityId: originEntity ? originEntity.noteId : null\n        }, \"script\");\n\n        if (ret.success) {\n            // wait until all the changes done in the script has been synced to frontend before continuing\n            await ws.waitForSyncId(ret.maxSyncId);\n\n            return ret.executionResult;\n        }\n        else {\n            throw new Error(\"server error: \" + ret.error);\n        }\n    };\n\n    /**\n     * @deprecated new name of this API call is runOnBackend so use that\n     * @method\n     */\n    this.runOnServer = this.runOnBackend;\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"@dateModified =* MONTH AND @log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<NoteShort[]>}\n     */\n    this.searchForNotes = async searchString => {\n        const noteIds = await this.runOnServer(async searchString => {\n            const notes = await api.searchForNotes(searchString);\n\n            return notes.map(note => note.noteId);\n        }, [searchString]);\n\n        return await treeCache.getNotes(noteIds);\n    };\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"@dateModified =* MONTH AND @log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<NoteShort|null>}\n     */\n    this.searchForNote = async searchString => {\n        const notes = await this.searchForNotes(searchString);\n\n        return notes.length > 0 ? notes[0] : null;\n    };\n\n    /**\n     * Returns note by given noteId. If note is missing from cache, it's loaded.\n     **\n     * @param {string} noteId\n     * @return {Promise<NoteShort>}\n     */\n    this.getNote = async noteId => await treeCache.getNote(noteId);\n\n    /**\n     * Returns list of notes. If note is missing from cache, it's loaded.\n     *\n     * This is often used to bulk-fill the cache with notes which would have to be picked one by one\n     * otherwise (by e.g. createNoteLink())\n     *\n     * @param {string[]} noteIds\n     * @param {boolean} [silentNotFoundError] - don't report error if the note is not found\n     * @return {Promise<NoteShort[]>}\n     */\n    this.getNotes = async (noteIds, silentNotFoundError = false) => await treeCache.getNotes(noteIds, silentNotFoundError);\n\n    /**\n     * Update frontend tree (note) cache from the backend.\n     *\n     * @param {string[]} noteIds\n     * @method\n     */\n    this.reloadNotes = async noteIds => await treeCache.reloadNotes(noteIds);\n\n    /**\n     * Instance name identifies particular Trilium instance. It can be useful for scripts\n     * if some action needs to happen on only one specific instance.\n     *\n     * @return {string}\n     */\n    this.getInstanceName = () => window.glob.instanceName;\n\n    /**\n     * @method\n     * @param {Date} date\n     * @returns {string} date in YYYY-MM-DD format\n     */\n    this.formatDateISO = utils.formatDateISO;\n\n    /**\n     * @method\n     * @param {string} str\n     * @returns {Date} parsed object\n     */\n    this.parseDate = utils.parseDate;\n\n    /**\n     * Show info message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showMessage = toastService.showMessage;\n\n    /**\n     * Show error message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showError = toastService.showError;\n\n    /**\n     * @method\n     * @deprecated - this is now no-op since all the changes should be gracefully handled per widget\n     */\n    this.refreshTree = () => {};\n\n    /**\n     * Create note link (jQuery object) for given note.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {string} [noteTitle] - if not present we'll use note title\n     */\n    this.createNoteLink = linkService.createNoteLink;\n\n    /**\n     * Adds given text to the editor cursor\n     *\n     * @param {string} text - this must be clear text, HTML is not supported.\n     * @method\n     */\n    this.addTextToActiveTabEditor = text => appContext.triggerCommand('addTextToActiveEditor', {text});\n\n    /**\n     * @method\n     * @returns {NoteShort} active note (loaded into right pane)\n     */\n    this.getActiveTabNote = () => appContext.tabManager.getActiveTabNote();\n\n    /**\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html for a documentation on the returned instance.\n     *\n     * @method\n     * @param callback - method receiving \"textEditor\" instance\n     */\n    this.getActiveTabTextEditor = callback => appContext.triggerCommand('executeInActiveEditor', {callback});\n\n    /**\n     * @method\n     * @returns {Promise<string|null>} returns note path of active note or null if there isn't active note\n     */\n    this.getActiveTabNotePath = () => appContext.tabManager.getActiveTabNotePath();\n\n    /**\n     * @method\n     * @param {object} $el - jquery object on which to setup the tooltip\n     */\n    this.setupElementTooltip = noteTooltipService.setupElementTooltip;\n\n    /**\n     * @deprecated use protectNote and protectSubtree instead\n     * @method\n     */\n    this.protectActiveNote = async () => {\n        const activeNote = appContext.tabManager.getActiveTabNote();\n\n        await protectedSessionService.protectNote(activeNote.noteId, true, false);\n    };\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect note, false to unprotect\n     */\n    this.protectNote = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, false);\n    };\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect subtree, false to unprotect\n     */\n    this.protectSubTree = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, true);\n    };\n\n    /**\n     * Returns date-note for today. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @return {Promise<NoteShort>}\n     */\n    this.getTodayNote = dateNotesService.getTodayNote;\n\n    /**\n     * Returns date-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} date - e.g. \"2019-04-29\"\n     * @return {Promise<NoteShort>}\n     */\n    this.getDateNote = dateNotesService.getDateNote;\n\n    /**\n     * Returns month-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} month - e.g. \"2019-04\"\n     * @return {Promise<NoteShort>}\n     */\n    this.getMonthNote = dateNotesService.getMonthNote;\n\n    /**\n     * Returns year-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} year - e.g. \"2019\"\n     * @return {Promise<NoteShort>}\n     */\n    this.getYearNote = dateNotesService.getYearNote;\n\n    /**\n     * Hoist note. See https://github.com/zadam/trilium/wiki/Note-hoisting\n     *\n     * @method\n     * @param {string} noteId - set hoisted note. 'root' will effectively unhoist\n     * @return {Promise}\n     */\n    this.setHoistedNoteId = hoistedNoteService.setHoistedNoteId;\n\n    /**\n     * @method\n     * @param {string} keyboardShortcut - e.g. \"ctrl+shift+a\"\n     * @param {function} handler\n     */\n    this.bindGlobalShortcut = utils.bindGlobalShortcut;\n\n    /**\n     * Trilium runs in backend and frontend process, when something is changed on the backend from script,\n     * frontend will get asynchronously synchronized.\n     *\n     * This method returns a promise which resolves once all the backend -> frontend synchronization is finished.\n     * Typical use case is when new note has been created, we should wait until it is synced into frontend and only then activate it.\n     *\n     * @method\n     */\n    this.waitUntilSynced = ws.waitForMaxKnownSyncId;\n\n    /**\n     * This will refresh all currently opened notes which have included note specified in the parameter\n     *\n     * @param includedNoteId - noteId of the included note\n     */\n    this.refreshIncludedNote = includedNoteId => appContext.triggerEvent('refreshIncludedNote', {noteId: includedNoteId});\n}\n\nexport default FrontendScriptApi;\n","import FrontendScriptApi from './frontend_script_api.js';\nimport utils from './utils.js';\nimport treeCache from './tree_cache.js';\n\nasync function ScriptContext(startNoteId, allNoteIds, originEntity = null, $container = null) {\n    const modules = {};\n\n    await treeCache.initializedPromise;\n\n    const startNote = await treeCache.getNote(startNoteId);\n    const allNotes = await treeCache.getNotes(allNoteIds);\n\n    return {\n        modules: modules,\n        notes: utils.toObject(allNotes, note => [note.noteId, note]),\n        apis: utils.toObject(allNotes, note => [note.noteId, new FrontendScriptApi(startNote, note, originEntity, $container)]),\n        require: moduleNoteIds => {\n            return moduleName => {\n                const candidates = allNotes.filter(note => moduleNoteIds.includes(note.noteId));\n                const note = candidates.find(c => c.title === moduleName);\n\n                if (!note) {\n                    throw new Error(\"Could not find module note \" + moduleName);\n                }\n\n                return modules[note.noteId].exports;\n            }\n        }\n    };\n}\n\nexport default ScriptContext;","import utils from './utils.js';\n\nconst REQUEST_LOGGING_ENABLED = false;\n\nfunction getHeaders(headers) {\n    // headers need to be lowercase because node.js automatically converts them to lower case\n    // so hypothetical protectedSessionId becomes protectedsessionid on the backend\n    // also avoiding using underscores instead of dashes since nginx filters them out by default\n    const allHeaders = {\n        'trilium-source-id': glob.sourceId,\n        'trilium-local-now-datetime': utils.localNowDateTime(),\n        'x-csrf-token': glob.csrfToken\n    };\n\n    for (const headerName in headers) {\n        if (headers[headerName]) {\n            allHeaders[headerName] = headers[headerName];\n        }\n    }\n\n    if (utils.isElectron()) {\n        // passing it explicitely here because of the electron HTTP bypass\n        allHeaders.cookie = document.cookie;\n    }\n\n    return allHeaders;\n}\n\nasync function get(url, sourceId) {\n    return await call('GET', url, null, {'trilium-source-id': sourceId});\n}\n\nasync function post(url, data, sourceId) {\n    return await call('POST', url, data, {'trilium-source-id': sourceId});\n}\n\nasync function put(url, data, sourceId) {\n    return await call('PUT', url, data, {'trilium-source-id': sourceId});\n}\n\nasync function remove(url, sourceId) {\n    return await call('DELETE', url, null, {'trilium-source-id': sourceId});\n}\n\nlet i = 1;\nconst reqResolves = {};\n\nlet maxKnownSyncId = 0;\n\nasync function call(method, url, data, headers = {}) {\n    let resp;\n\n    const start = Date.now();\n\n    if (utils.isElectron()) {\n        const ipc = utils.dynamicRequire('electron').ipcRenderer;\n        const requestId = i++;\n\n        resp = await new Promise((resolve, reject) => {\n            reqResolves[requestId] = resolve;\n\n            if (REQUEST_LOGGING_ENABLED) {\n                console.log(utils.now(), \"Request #\" + requestId + \" to \" + method + \" \" + url);\n            }\n\n            ipc.send('server-request', {\n                requestId: requestId,\n                headers: getHeaders(headers),\n                method: method,\n                url: \"/\" + baseApiUrl + url,\n                data: data\n            });\n        });\n    }\n    else {\n        resp = await ajax(url, method, data, headers);\n    }\n\n    const end = Date.now();\n\n    if (glob.PROFILING_LOG) {\n        console.log(`${method} ${url} took ${end - start}ms`);\n    }\n\n    const maxSyncIdStr = resp.headers['trilium-max-sync-id'];\n\n    if (maxSyncIdStr && maxSyncIdStr.trim()) {\n        maxKnownSyncId = Math.max(maxKnownSyncId, parseInt(maxSyncIdStr));\n    }\n\n    return resp.body;\n}\n\nfunction ajax(url, method, data, headers) {\n    return new Promise((res, rej) => {\n        const options = {\n            url: baseApiUrl + url,\n            type: method,\n            headers: getHeaders(headers),\n            timeout: 60000,\n            success: (body, textStatus, jqXhr) => {\n                const respHeaders = {};\n\n                jqXhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(line => {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    respHeaders[header] = parts.join(': ');\n                });\n\n                res({\n                    body,\n                    headers: respHeaders\n                });\n            },\n            error: async (jqXhr, textStatus, error) => {\n                const message = \"Error when calling \" + method + \" \" + url + \": \" + textStatus + \" - \" + error;\n                const toastService = (await import(\"./toast.js\")).default;\n                toastService.showError(message);\n                toastService.throwError(message);\n\n                rej(error);\n            }\n        };\n\n        if (data) {\n            try {\n                options.data = JSON.stringify(data);\n            } catch (e) {\n                console.log(\"Can't stringify data: \", data, \" because of error: \", e)\n            }\n            options.contentType = \"application/json\";\n        }\n\n        $.ajax(options);\n    });\n}\n\nif (utils.isElectron()) {\n    const ipc = utils.dynamicRequire('electron').ipcRenderer;\n\n    ipc.on('server-response', (event, arg) => {\n        if (REQUEST_LOGGING_ENABLED) {\n            console.log(utils.now(), \"Response #\" + arg.requestId + \": \" + arg.statusCode);\n        }\n\n        reqResolves[arg.requestId]({\n            body: arg.body,\n            headers: arg.headers\n        });\n\n        delete reqResolves[arg.requestId];\n    });\n}\n\nexport default {\n    get,\n    post,\n    put,\n    remove,\n    ajax,\n    // don't remove, used from CKEditor image upload!\n    getHeaders,\n    getMaxKnownSyncId: () => maxKnownSyncId\n};","import ws from \"./ws.js\";\nimport utils from \"./utils.js\";\n\nfunction toast(options) {\n    const $toast = $(`<div class=\"toast\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n    <div class=\"toast-header\">\n        <strong class=\"mr-auto\"><span class=\"bx bx-${options.icon}\"></span> ${options.title}</strong>\n        <button type=\"button\" class=\"ml-2 mb-1 close\" data-dismiss=\"toast\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n        </button>\n    </div>\n    <div class=\"toast-body\">\n        ${options.message}\n    </div>\n</div>`);\n\n    if (options.id) {\n        $toast.attr(\"id\", \"toast-\" + options.id);\n    }\n\n    $(\"#toast-container\").append($toast);\n\n    $toast.toast({\n        delay: options.delay || 3000,\n        autohide: !!options.autohide\n    });\n\n    $toast.on('hidden.bs.toast', e => e.target.remove());\n\n    $toast.toast(\"show\");\n\n    return $toast;\n}\n\nfunction showPersistent(options) {\n    let $toast = $(\"#toast-\" + options.id);\n\n    if ($toast.length > 0) {\n        $toast.find('.toast-body').html(options.message);\n    }\n    else {\n        options.autohide = false;\n\n        $toast = toast(options);\n    }\n\n    if (options.closeAfter) {\n        setTimeout(() => $toast.remove(), options.closeAfter);\n    }\n}\n\nfunction closePersistent(id) {\n    $(\"#toast-\" + id).remove();\n}\n\nfunction showMessage(message, delay = 2000) {\n    console.debug(utils.now(), \"message: \", message);\n\n    toast({\n        title: \"Info\",\n        icon: \"check\",\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction showAndLogError(message, delay = 10000) {\n    showError(message, delay);\n\n    ws.logError(message);\n}\n\nfunction showError(message, delay = 10000) {\n    console.log(utils.now(), \"error: \", message);\n\n    toast({\n        title: \"Error\",\n        icon: 'alert',\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction throwError(message) {\n    ws.logError(message);\n\n    throw new Error(message);\n}\n\nexport default {\n    showMessage,\n    showError,\n    showAndLogError,\n    throwError,\n    showPersistent,\n    closePersistent\n}","import ws from './ws.js';\nimport utils from './utils.js';\nimport server from './server.js';\nimport treeCache from './tree_cache.js';\nimport hoistedNoteService from '../services/hoisted_note.js';\nimport appContext from \"./app_context.js\";\n\n/**\n * Accepts notePath which might or might not be valid and returns an existing path as close to the original\n * notePath as possible.\n * @return {string|null}\n */\nasync function resolveNotePath(notePath) {\n    const runPath = await getRunPath(notePath);\n\n    return runPath ? runPath.join(\"/\") : null;\n}\n\n/**\n * Accepts notePath and tries to resolve it. Part of the path might not be valid because of note moving (which causes\n * path change) or other corruption, in that case this will try to get some other valid path to the correct note.\n *\n * @return {string[]}\n */\nasync function getRunPath(notePath, logErrors = true) {\n    utils.assertArguments(notePath);\n\n    notePath = notePath.split(\"-\")[0].trim();\n\n    if (notePath.length === 0) {\n        return;\n    }\n\n    const path = notePath.split(\"/\").reverse();\n\n    if (!path.includes(\"root\")) {\n        path.push('root');\n    }\n\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    const effectivePath = [];\n    let childNoteId = null;\n    let i = 0;\n\n    while (true) {\n        if (i >= path.length) {\n            break;\n        }\n\n        const parentNoteId = path[i++];\n\n        if (childNoteId !== null) {\n            const child = await treeCache.getNote(childNoteId);\n\n            if (!child) {\n                console.log(\"Can't find note \" + childNoteId);\n                return;\n            }\n\n            const parents = child.getParentNotes();\n\n            if (!parents) {\n                ws.logError(\"No parents found for \" + childNoteId);\n                return;\n            }\n\n            if (!parents.some(p => p.noteId === parentNoteId)) {\n                if (logErrors) {\n                    console.log(utils.now(), \"Did not find parent \" + parentNoteId + \" for child \" + childNoteId);\n                }\n\n                if (parents.length > 0) {\n                    if (logErrors) {\n                        console.log(utils.now(), \"Available parents:\", parents);\n                    }\n\n                    const someNotePath = await getSomeNotePath(parents[0]);\n\n                    if (someNotePath) { // in case it's root the path may be empty\n                        const pathToRoot = someNotePath.split(\"/\").reverse();\n\n                        for (const noteId of pathToRoot) {\n                            effectivePath.push(noteId);\n                        }\n\n                        effectivePath.push('root');\n                    }\n\n                    break;\n                }\n                else {\n                    if (logErrors) {\n                        console.log(\"No parents so no run path.\");\n                    }\n\n                    return;\n                }\n            }\n        }\n\n        effectivePath.push(parentNoteId);\n        childNoteId = parentNoteId;\n\n        if (parentNoteId === hoistedNoteId) {\n            break;\n        }\n    }\n\n    return effectivePath.reverse();\n}\n\nasync function getSomeNotePath(note) {\n    utils.assertArguments(note);\n\n    const path = [];\n\n    let cur = note;\n\n    while (cur.noteId !== 'root') {\n        path.push(cur.noteId);\n\n        const parents = cur.getParentNotes();\n\n        if (!parents.length) {\n            console.error(`Can't find parents for note ${cur.noteId}`);\n            return;\n        }\n\n        cur = parents[0];\n    }\n\n    path.push('root');\n\n    return path.reverse().join('/');\n}\n\nasync function sortAlphabetically(noteId) {\n    await server.put('notes/' + noteId + '/sort');\n}\n\nws.subscribeToMessages(message => {\n   if (message.type === 'open-note') {\n       appContext.tabManager.activateOrOpenNote(message.noteId);\n\n       if (utils.isElectron()) {\n           const currentWindow = utils.dynamicRequire(\"electron\").remote.getCurrentWindow();\n\n           currentWindow.show();\n       }\n   }\n});\n\nfunction getParentProtectedStatus(node) {\n    return hoistedNoteService.isRootNode(node) ? 0 : node.getParent().data.isProtected;\n}\n\nfunction getNoteIdFromNotePath(notePath) {\n    if (!notePath) {\n        return null;\n    }\n\n    const path = notePath.split(\"/\");\n\n    const lastSegment = path[path.length - 1];\n\n    // path could have also tabId suffix\n    return lastSegment.split(\"-\")[0];\n}\n\nfunction getNoteIdAndParentIdFromNotePath(notePath) {\n    if (notePath === 'root') {\n        return {\n            noteId: 'root',\n            parentNoteId: 'none'\n        };\n    }\n\n    let parentNoteId = 'root';\n    let noteId = '';\n\n    if (notePath) {\n        const path = notePath.split(\"/\");\n\n        const lastSegment = path[path.length - 1];\n\n        // path could have also tabId suffix\n        noteId = lastSegment.split(\"-\")[0];\n\n        if (path.length > 1) {\n            parentNoteId = path[path.length - 2];\n        }\n    }\n\n    return {\n        parentNoteId,\n        noteId\n    }\n}\n\nfunction getNotePath(node) {\n    if (!node) {\n        console.error(\"Node is null\");\n        return \"\";\n    }\n\n    const path = [];\n\n    while (node && !hoistedNoteService.isRootNode(node)) {\n        if (node.data.noteId) {\n            path.push(node.data.noteId);\n        }\n\n        node = node.getParent();\n    }\n\n    if (node) { // null node can happen directly after unhoisting when tree is still hoisted but option has been changed already\n        path.push(node.data.noteId); // root or hoisted noteId\n    }\n\n    return path.reverse().join(\"/\");\n}\n\nasync function getNoteTitle(noteId, parentNoteId = null) {\n    utils.assertArguments(noteId);\n\n    const note = await treeCache.getNote(noteId);\n    if (!note) {\n        return \"[not found]\";\n    }\n\n    let {title} = note;\n\n    if (parentNoteId !== null) {\n        const branchId = note.parentToBranch[parentNoteId];\n\n        if (branchId) {\n            const branch = treeCache.getBranch(branchId);\n\n            if (branch && branch.prefix) {\n                title = branch.prefix + ' - ' + title;\n            }\n        }\n    }\n\n    return title;\n}\n\nasync function getNotePathTitle(notePath) {\n    utils.assertArguments(notePath);\n\n    const titlePath = [];\n\n    if (notePath.startsWith('root/')) {\n        notePath = notePath.substr(5);\n    }\n\n    // special case when we want just root's title\n    if (notePath === 'root') {\n        return await getNoteTitle(notePath);\n    }\n\n    let parentNoteId = 'root';\n\n    for (const noteId of notePath.split('/')) {\n        titlePath.push(await getNoteTitle(noteId, parentNoteId));\n\n        parentNoteId = noteId;\n    }\n\n    return titlePath.join(' / ');\n}\n\nfunction getHashValueFromAddress() {\n    const str = document.location.hash ? document.location.hash.substr(1) : \"\"; // strip initial #\n\n    return str.split(\"-\");\n}\n\nfunction parseNotePath(notePath) {\n    let noteIds = notePath.split('/');\n\n    if (noteIds[0] !== 'root') {\n        noteIds = ['root'].concat(noteIds);\n    }\n\n    return noteIds;\n}\n\nexport default {\n    sortAlphabetically,\n    resolveNotePath,\n    getSomeNotePath,\n    getRunPath,\n    getParentProtectedStatus,\n    getNotePath,\n    getNoteIdFromNotePath,\n    getNoteIdAndParentIdFromNotePath,\n    getNoteTitle,\n    getNotePathTitle,\n    getHashValueFromAddress,\n    parseNotePath\n};\n","import server from '../services/server.js';\nimport Attribute from './attribute.js';\nimport noteAttributeCache from \"../services/note_attribute_cache.js\";\n\nconst LABEL = 'label';\nconst LABEL_DEFINITION = 'label-definition';\nconst RELATION = 'relation';\nconst RELATION_DEFINITION = 'relation-definition';\n\n/**\n * FIXME: since there's no \"full note\" anymore we can rename this to Note\n *\n * This note's representation is used in note tree and is kept in TreeCache.\n */\nclass NoteShort {\n    /**\n     * @param {TreeCache} treeCache\n     * @param {Object.<string, Object>} row\n     */\n    constructor(treeCache, row) {\n        this.treeCache = treeCache;\n\n        /** @type {string[]} */\n        this.attributes = [];\n\n        /** @type {string[]} */\n        this.targetRelations = [];\n\n        /** @type {string[]} */\n        this.parents = [];\n        /** @type {string[]} */\n        this.children = [];\n\n        /** @type {Object.<string, string>} */\n        this.parentToBranch = {};\n\n        /** @type {Object.<string, string>} */\n        this.childToBranch = {};\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @param {string} */\n        this.noteId = row.noteId;\n        /** @param {string} */\n        this.title = row.title;\n        /** @param {int} */\n        this.contentLength = row.contentLength;\n        /** @param {boolean} */\n        this.isProtected = !!row.isProtected;\n        /** @param {string} one of 'text', 'code', 'file' or 'render' */\n        this.type = row.type;\n        /** @param {string} content-type, e.g. \"application/json\" */\n        this.mime = row.mime;\n        /** @param {boolean} */\n        this.isDeleted = row.isDeleted;\n    }\n\n    addParent(parentNoteId, branchId) {\n        if (!this.parents.includes(parentNoteId)) {\n            this.parents.push(parentNoteId);\n        }\n\n        this.parentToBranch[parentNoteId] = branchId;\n    }\n\n    addChild(childNoteId, branchId) {\n        if (!this.children.includes(childNoteId)) {\n            this.children.push(childNoteId);\n        }\n\n        this.childToBranch[childNoteId] = branchId;\n\n        const branchIdPos = {};\n\n        for (const branchId of Object.values(this.childToBranch)) {\n            branchIdPos[branchId] = this.treeCache.getBranch(branchId).notePosition;\n        }\n\n        this.children.sort((a, b) => branchIdPos[this.childToBranch[a]] < branchIdPos[this.childToBranch[b]] ? -1 : 1);\n    }\n\n    /** @returns {boolean} */\n    isJson() {\n        return this.mime === \"application/json\";\n    }\n\n    async getContent() {\n        // we're not caching content since these objects are in treeCache and as such pretty long lived\n        const note = await server.get(\"notes/\" + this.noteId);\n\n        return note.content;\n    }\n\n    async getJsonContent() {\n        const content = await this.getContent();\n\n        try {\n            return JSON.parse(content);\n        }\n        catch (e) {\n            console.log(`Cannot parse content of note ${this.noteId}: `, e.message);\n\n            return null;\n        }\n    }\n\n    /** @returns {string[]} */\n    getBranchIds() {\n        return Object.values(this.parentToBranch);\n    }\n\n    /** @returns {Branch[]} */\n    getBranches() {\n        const branchIds = Object.values(this.parentToBranch);\n\n        return this.treeCache.getBranches(branchIds);\n    }\n\n    /** @returns {boolean} */\n    hasChildren() {\n        return this.children.length > 0;\n    }\n\n    /** @returns {Branch[]} */\n    getChildBranches() {\n        // don't use Object.values() to guarantee order\n        const branchIds = this.children.map(childNoteId => this.childToBranch[childNoteId]);\n\n        return this.treeCache.getBranches(branchIds);\n    }\n\n    /** @returns {string[]} */\n    getParentNoteIds() {\n        return this.parents;\n    }\n\n    /** @returns {NoteShort[]} */\n    getParentNotes() {\n        return this.treeCache.getNotesFromCache(this.parents);\n    }\n\n    /** @returns {string[]} */\n    getChildNoteIds() {\n        return this.children;\n    }\n\n    /** @returns {Promise<NoteShort[]>} */\n    async getChildNotes() {\n        return await this.treeCache.getNotes(this.children);\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {Attribute[]} all note's attributes, including inherited ones\n     */\n    getOwnedAttributes(type, name) {\n        const attrs = this.attributes\n            .map(attributeId => this.treeCache.attributes[attributeId])\n            .filter(Boolean); // filter out nulls;\n\n        return this.__filterAttrs(attrs, type, name);\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {Attribute[]} all note's attributes, including inherited ones\n     */\n    getAttributes(type, name) {\n        return this.__filterAttrs(this.__getCachedAttributes([]), type, name);\n    }\n\n    __getCachedAttributes(path) {\n        // notes/clones cannot form tree cycles, it is possible to create attribute inheritance cycle via templates\n        // when template instance is a parent of template itself\n        if (path.includes(this.noteId)) {\n            return [];\n        }\n\n        if (!(this.noteId in noteAttributeCache)) {\n            const ownedAttributes = this.getOwnedAttributes();\n\n            const attrArrs = [\n                ownedAttributes\n            ];\n\n            const newPath = [...path, this.noteId];\n\n            for (const templateAttr of ownedAttributes.filter(oa => oa.type === 'relation' && oa.name === 'template')) {\n                const templateNote = this.treeCache.notes[templateAttr.value];\n\n                if (templateNote && templateNote.noteId !== this.noteId) {\n                    attrArrs.push(templateNote.__getCachedAttributes(newPath));\n                }\n            }\n\n            if (this.noteId !== 'root') {\n                for (const parentNote of this.getParentNotes()) {\n                    // these virtual parent-child relationships are also loaded into frontend tree cache\n                    if (parentNote.type !== 'search') {\n                        attrArrs.push(parentNote.__getInheritableAttributes(newPath));\n                    }\n                }\n            }\n\n            noteAttributeCache.attributes[this.noteId] = attrArrs.flat();\n        }\n\n        return noteAttributeCache.attributes[this.noteId];\n    }\n\n    __filterAttrs(attributes, type, name) {\n        if (!type && !name) {\n            return attributes;\n        } else if (type && name) {\n            return attributes.filter(attr => attr.type === type && attr.name === name);\n        } else if (type) {\n            return attributes.filter(attr => attr.type === type);\n        } else if (name) {\n            return attributes.filter(attr => attr.name === name);\n        }\n    }\n\n    __getInheritableAttributes(path) {\n        const attrs = this.__getCachedAttributes(path);\n\n        return attrs.filter(attr => attr.isInheritable);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {Attribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getOwnedLabels(name) {\n        return this.getOwnedAttributes(LABEL, name);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {Attribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getLabels(name) {\n        return this.getAttributes(LABEL, name);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {Attribute[]} all note's label definitions, including inherited ones\n     */\n    getLabelDefinitions(name) {\n        return this.getAttributes(LABEL_DEFINITION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Attribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getOwnedRelations(name) {\n        return this.getOwnedAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Attribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getRelations(name) {\n        return this.getAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Attribute[]} all note's relation definitions including inherited ones\n     */\n    getRelationDefinitions(name) {\n        return this.getAttributes(RELATION_DEFINITION, name);\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasAttribute(type, name) {\n        return !!this.getAttribute(type, name);\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasOwnedAttribute(type, name) {\n        return !!this.getOwnedAttribute(type, name);\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {Attribute} attribute of given type and name. If there's more such attributes, first is  returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getOwnedAttribute(type, name) {\n        const attributes = this.getOwnedAttributes(type, name);\n\n        return attributes.length > 0 ? attributes[0] : 0;\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {Attribute} attribute of given type and name. If there's more such attributes, first is  returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getAttribute(type, name) {\n        const attributes = this.getAttributes(type, name);\n\n        return attributes.length > 0 ? attributes[0] : 0;\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of given type and name or null if no such attribute exists.\n     */\n    getOwnedAttributeValue(type, name) {\n        const attr = this.getOwnedAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {string} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of given type and name or null if no such attribute exists.\n     */\n    getAttributeValue(type, name) {\n        const attr = this.getAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (excluding inherited)\n     */\n    hasOwnedLabel(name) { return this.hasOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (including inherited)\n     */\n    hasLabel(name) { return this.hasAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (excluding inherited)\n     */\n    hasOwnedRelation(name) { return this.hasOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (including inherited)\n     */\n    hasRelation(name) { return this.hasAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {Attribute} label if it exists, null otherwise\n     */\n    getOwnedLabel(name) { return this.getOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {Attribute} label if it exists, null otherwise\n     */\n    getLabel(name) { return this.getAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {Attribute} relation if it exists, null otherwise\n     */\n    getOwnedRelation(name) { return this.getOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {Attribute} relation if it exists, null otherwise\n     */\n    getRelation(name) { return this.getAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getOwnedLabelValue(name) { return this.getOwnedAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getLabelValue(name) { return this.getAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getOwnedRelationValue(name) { return this.getOwnedAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getRelationValue(name) { return this.getAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name\n     * @returns {Promise<NoteShort>|null} target note of the relation or null (if target is empty or note was not found)\n     */\n    async getRelationTarget(name) {\n        const targets = await this.getRelationTargets(name);\n\n        return targets.length > 0 ? targets[0] : null;\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Promise<NoteShort[]>}\n     */\n    async getRelationTargets(name) {\n        const relations = this.getRelations(name);\n        const targets = [];\n\n        for (const relation of relations) {\n            targets.push(await this.treeCache.getNote(relation.value));\n        }\n\n        return targets;\n    }\n\n    /**\n     * @returns {NoteShort[]}\n     */\n    getTemplateNotes() {\n        const relations = this.getRelations('template');\n\n        return relations.map(rel => this.treeCache.notes[rel.value]);\n    }\n\n    hasAncestor(ancestorNote) {\n        if (this.noteId === ancestorNote.noteId) {\n            return true;\n        }\n\n        for (const templateNote of this.getTemplateNotes()) {\n            if (templateNote.hasAncestor(ancestorNote)) {\n                return true;\n            }\n        }\n\n        for (const parentNote of this.getParentNotes()) {\n            if (parentNote.hasAncestor(ancestorNote)) {console.log(parentNote);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Clear note's attributes cache to force fresh reload for next attribute request.\n     * Cache is note instance scoped.\n     */\n    invalidateAttributeCache() {\n        this.__attributeCache = null;\n    }\n\n    /**\n     * Get relations which target this note\n     *\n     * @returns {Attribute[]}\n     */\n    getTargetRelations() {\n        return this.targetRelations\n            .map(attributeId => this.treeCache.attributes[attributeId]);\n    }\n\n    /**\n     * Return note complement which is most importantly note's content\n     *\n     * @return {Promise<NoteComplement>}\n     */\n    async getNoteComplement() {\n        return await this.treeCache.getNoteComplement(this.noteId);\n    }\n\n    get toString() {\n        return `Note(noteId=${this.noteId}, title=${this.title})`;\n    }\n\n    get dto() {\n        const dto = Object.assign({}, this);\n        delete dto.treeCache;\n\n        return dto;\n    }\n\n    getCssClass() {\n        const labels = this.getLabels('cssClass');\n        return labels.map(l => l.value).join(' ');\n    }\n}\n\nexport default NoteShort;\n","/**\n * Complements the NoteShort with the main note content and other extra attributes\n */\nclass NoteComplement {\n    constructor(row) {\n        /** @param {string} */\n        this.noteId = row.noteId;\n\n        /** @param {string} */\n        this.content = row.content;\n\n        /** @param {string} */\n        this.dateCreated = row.dateCreated;\n\n        /** @param {string} */\n        this.dateModified = row.dateModified;\n\n        /** @param {string} */\n        this.utcDateCreated = row.utcDateCreated;\n\n        /** @param {string} */\n        this.utcDateModified = row.utcDateModified;\n    }\n}\n\nexport default NoteComplement;","import Branch from \"../entities/branch.js\";\nimport NoteShort from \"../entities/note_short.js\";\nimport Attribute from \"../entities/attribute.js\";\nimport server from \"./server.js\";\nimport NoteComplement from \"../entities/note_complement.js\";\n\n/**\n * TreeCache keeps a read only cache of note tree structure in frontend's memory.\n * - notes are loaded lazily when unknown noteId is requested\n * - when note is loaded, all its parent and child branches are loaded as well. For a branch to be used, it's not must be loaded before\n * - deleted notes are present in the cache as well, but they don't have any branches. As a result check for deleted branch is done by presence check - if the branch is not there even though the corresponding note has been loaded, we can infer it is deleted.\n *\n * Note and branch deletions are corner cases and usually not needed.\n */\nclass TreeCache {\n    constructor() {\n        this.initializedPromise = this.loadInitialTree();\n    }\n\n    async loadInitialTree() {\n        const resp = await server.get('tree');\n\n        await this.loadParents(resp, false);\n\n        // clear the cache only directly before adding new content which is important for e.g. switching to protected session\n\n        /** @type {Object.<string, NoteShort>} */\n        this.notes = {};\n\n        /** @type {Object.<string, Branch>} */\n        this.branches = {};\n\n        /** @type {Object.<string, Attribute>} */\n        this.attributes = {};\n\n        /** @type {Object.<string, Promise<NoteComplement>>} */\n        this.noteComplementPromises = {};\n\n        this.addResp(resp);\n    }\n\n    async loadParents(resp, additiveLoad) {\n        const noteIds = new Set(resp.notes.map(note => note.noteId));\n        const missingNoteIds = [];\n        const existingNotes = additiveLoad ? this.notes : {};\n\n        for (const branch of resp.branches) {\n            if (!(branch.parentNoteId in existingNotes) && !noteIds.has(branch.parentNoteId) && branch.parentNoteId !== 'none') {\n                missingNoteIds.push(branch.parentNoteId);\n            }\n        }\n\n        for (const attr of resp.attributes) {\n            if (attr.type === 'relation' && attr.name === 'template' && !(attr.value in existingNotes) && !noteIds.has(attr.value)) {\n                missingNoteIds.push(attr.value);\n            }\n\n            if (!(attr.noteId in existingNotes) && !noteIds.has(attr.noteId)) {\n                missingNoteIds.push(attr.noteId);\n            }\n        }\n\n        if (missingNoteIds.length > 0) {\n            const newResp = await server.post('tree/load', { noteIds: missingNoteIds });\n\n            resp.notes = resp.notes.concat(newResp.notes);\n            resp.branches = resp.branches.concat(newResp.branches);\n            resp.attributes = resp.attributes.concat(newResp.attributes);\n\n            await this.loadParents(resp, additiveLoad);\n        }\n    }\n\n    addResp(resp) {\n        const noteRows = resp.notes;\n        const branchRows = resp.branches;\n        const attributeRows = resp.attributes;\n\n        for (const noteRow of noteRows) {\n            const {noteId} = noteRow;\n\n            const oldNote = this.notes[noteId];\n\n            if (oldNote) {\n                for (const childNoteId of oldNote.children) {\n                    const childNote = this.notes[childNoteId];\n\n                    if (childNote) {\n                        childNote.parents = childNote.parents.filter(p => p !== noteId);\n\n                        delete this.branches[childNote.parentToBranch[noteId]];\n                        delete childNote.parentToBranch[noteId];\n                    }\n                }\n\n                for (const parentNoteId of oldNote.parents) {\n                    const parentNote = this.notes[parentNoteId];\n\n                    if (parentNote) {\n                        parentNote.children = parentNote.children.filter(p => p !== noteId);\n\n                        delete this.branches[parentNote.childToBranch[noteId]];\n                        delete parentNote.childToBranch[noteId];\n                    }\n                }\n            }\n\n            const note = new NoteShort(this, noteRow);\n\n            this.notes[note.noteId] = note;\n        }\n\n        for (const branchRow of branchRows) {\n            const branch = new Branch(this, branchRow);\n\n            this.branches[branch.branchId] = branch;\n\n            const childNote = this.notes[branch.noteId];\n\n            if (childNote) {\n                childNote.addParent(branch.parentNoteId, branch.branchId);\n            }\n\n            const parentNote = this.notes[branch.parentNoteId];\n\n            if (parentNote) {\n                parentNote.addChild(branch.noteId, branch.branchId);\n            }\n        }\n\n        for (const attributeRow of attributeRows) {\n            const {attributeId} = attributeRow;\n\n            this.attributes[attributeId] = new Attribute(this, attributeRow);\n\n            const note = this.notes[attributeRow.noteId];\n\n            if (!note.attributes.includes(attributeId)) {\n                note.attributes.push(attributeId);\n            }\n\n            if (attributeRow.type === 'relation') {\n                const targetNote = this.notes[attributeRow.value];\n\n                if (targetNote) {\n                    if (!targetNote.targetRelations.includes(attributeId)) {\n                        targetNote.targetRelations.push(attributeId);\n                    }\n                }\n            }\n        }\n    }\n\n    async reloadNotes(noteIds) {\n        if (noteIds.length === 0) {\n            return;\n        }\n\n        noteIds = Array.from(new Set(noteIds)); // make noteIds unique\n\n        const resp = await server.post('tree/load', { noteIds });\n\n        await this.loadParents(resp, true);\n        this.addResp(resp);\n\n        for (const note of resp.notes) {\n            if (note.type === 'search') {\n                const searchResults = await server.get('search-note/' + note.noteId);\n\n                if (!searchResults) {\n                    throw new Error(`Search note ${note.noteId} failed.`);\n                }\n\n                // force to load all the notes at once instead of one by one\n                await this.getNotes(searchResults.map(res => res.noteId));\n\n                const branches = resp.branches.filter(b => b.noteId === note.noteId || b.parentNoteId === note.noteId);\n\n                searchResults.forEach((result, index) => branches.push({\n                    // branchId should be repeatable since sometimes we reload some notes without rerendering the tree\n                    branchId: \"virt\" + result.noteId + '-' + note.noteId,\n                    noteId: result.noteId,\n                    parentNoteId: note.noteId,\n                    prefix: this.getBranch(result.branchId).prefix,\n                    notePosition: (index + 1) * 10\n                }));\n\n                // update this note with standard (parent) branches + virtual (children) branches\n                this.addResp({\n                    notes: [note],\n                    branches,\n                    attributes: []\n                });\n            }\n        }\n    }\n\n    /** @return {NoteShort[]} */\n    getNotesFromCache(noteIds, silentNotFoundError = false) {\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.log(`Can't find note \"${noteId}\"`);\n\n                return null;\n            }\n            else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @return {Promise<NoteShort[]>} */\n    async getNotes(noteIds, silentNotFoundError = false) {\n        const missingNoteIds = noteIds.filter(noteId => !this.notes[noteId]);\n\n        await this.reloadNotes(missingNoteIds);\n\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.log(`Can't find note \"${noteId}\"`);\n\n                return null;\n            }\n            else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @return {Promise<boolean>} */\n    async noteExists(noteId) {\n        const notes = await this.getNotes([noteId], true);\n\n        return notes.length === 1;\n    }\n\n    /** @return {Promise<NoteShort>} */\n    async getNote(noteId, silentNotFoundError = false) {\n        if (noteId === 'none') {\n            console.trace(`No 'none' note.`);\n            return null;\n        }\n        else if (!noteId) {\n            console.log(`Falsy noteId ${noteId}, returning null.`);\n            return null;\n        }\n\n        return (await this.getNotes([noteId], silentNotFoundError))[0];\n    }\n\n    getNoteFromCache(noteId) {\n        return this.notes[noteId];\n    }\n\n    getBranches(branchIds, silentNotFoundError = false) {\n        return branchIds\n            .map(branchId => this.getBranch(branchId, silentNotFoundError))\n            .filter(b => !!b);\n    }\n\n    /** @return {Branch} */\n    getBranch(branchId, silentNotFoundError = false) {\n        if (!(branchId in this.branches)) {\n            if (!silentNotFoundError) {\n                console.error(`Not existing branch ${branchId}`);\n            }\n        }\n        else {\n            return this.branches[branchId];\n        }\n    }\n\n    async getBranchId(parentNoteId, childNoteId) {\n        const child = await this.getNote(childNoteId);\n\n        if (!child) {\n            console.error(`Could not find branchId for parent=${parentNoteId}, child=${childNoteId} since child does not exist`);\n\n            return null;\n        }\n\n        return child.parentToBranch[parentNoteId];\n    }\n\n    /**\n     * @return {Promise<NoteComplement>}\n     */\n    async getNoteComplement(noteId) {\n        if (!this.noteComplementPromises[noteId]) {\n            this.noteComplementPromises[noteId] = server.get('notes/' + noteId).then(row => new NoteComplement(row));\n        }\n\n        return await this.noteComplementPromises[noteId];\n    }\n}\n\nconst treeCache = new TreeCache();\n\nexport default treeCache;\n","export default class LoadResults {\n    constructor(treeCache) {\n        this.treeCache = treeCache;\n\n        this.noteIdToSourceId = {};\n        this.sourceIdToNoteIds = {};\n\n        this.branches = [];\n\n        this.attributes = [];\n\n        this.noteReorderings = [];\n\n        this.noteRevisions = [];\n\n        this.contentNoteIdToSourceId = [];\n\n        this.options = [];\n    }\n\n    addNote(noteId, sourceId) {\n        this.noteIdToSourceId[noteId] = this.noteIdToSourceId[noteId] || [];\n\n        if (!this.noteIdToSourceId[noteId].includes(sourceId)) {\n            this.noteIdToSourceId[noteId].push(sourceId);\n        }\n\n        this.sourceIdToNoteIds[sourceId] = this.sourceIdToNoteIds[sourceId] || [];\n\n        if (!this.sourceIdToNoteIds[sourceId]) {\n            this.sourceIdToNoteIds[sourceId].push(noteId);\n        }\n    }\n\n    addBranch(branchId, sourceId) {\n        this.branches.push({branchId, sourceId});\n    }\n\n    getBranches() {\n        return this.branches\n            .map(row => this.treeCache.branches[row.branchId])\n            .filter(branch => !!branch);\n    }\n\n    addNoteReordering(parentNoteId, sourceId) {\n        this.noteReorderings.push(parentNoteId);\n    }\n\n    getNoteReorderings() {\n        return this.noteReorderings;\n    }\n\n    addAttribute(attributeId, sourceId) {\n        this.attributes.push({attributeId, sourceId});\n    }\n\n    getAttributes(sourceId = 'none') {\n        return this.attributes\n            .filter(row => row.sourceId !== sourceId)\n            .map(row => this.treeCache.attributes[row.attributeId])\n            .filter(attr => !!attr);\n    }\n\n    addNoteRevision(noteRevisionId, noteId, sourceId) {\n        this.noteRevisions.push({noteRevisionId, noteId, sourceId});\n    }\n\n    hasNoteRevisionForNote(noteId) {\n        return !!this.noteRevisions.find(nr => nr.noteId === noteId);\n    }\n\n    getNoteIds() {\n        return Object.keys(this.noteIdToSourceId);\n    }\n\n    isNoteReloaded(noteId, sourceId = null) {\n        if (!noteId) {\n            return false;\n        }\n\n        const sourceIds = this.noteIdToSourceId[noteId];\n        return sourceIds && !!sourceIds.find(sId => sId !== sourceId);\n    }\n\n    addNoteContent(noteId, sourceId) {\n        this.contentNoteIdToSourceId.push({noteId, sourceId});\n    }\n\n    isNoteContentReloaded(noteId, sourceId) {\n        if (!noteId) {\n            return false;\n        }\n\n        return this.contentNoteIdToSourceId.find(l => l.noteId === noteId && l.sourceId !== sourceId);\n    }\n\n    addOption(name) {\n        this.options.push(name);\n    }\n\n    isOptionReloaded(name) {\n        this.options.includes(name);\n    }\n\n    /**\n     * @return {boolean} true if there are changes which could affect the attributes (including inherited ones)\n     *          notably changes in note itself should not have any effect on attributes\n     */\n    hasAttributeRelatedChanges() {\n        return this.branches.length === 0\n            && this.attributes.length === 0;\n    }\n\n    isEmpty() {\n        return Object.keys(this.noteIdToSourceId).length === 0\n            && this.branches.length === 0\n            && this.attributes.length === 0\n            && this.noteReorderings.length === 0\n            && this.noteRevisions.length === 0\n            && this.contentNoteIdToSourceId.length === 0\n            && this.options.length === 0;\n    }\n}\n","import utils from './utils.js';\nimport toastService from \"./toast.js\";\nimport server from \"./server.js\";\nimport LoadResults from \"./load_results.js\";\nimport Branch from \"../entities/branch.js\";\nimport Attribute from \"../entities/attribute.js\";\nimport options from \"./options.js\";\nimport treeCache from \"./tree_cache.js\";\nimport noteAttributeCache from \"./note_attribute_cache.js\";\n\nconst $outstandingSyncsCount = $(\"#outstanding-syncs-count\");\n\nconst messageHandlers = [];\n\nlet ws;\nlet lastAcceptedSyncId = window.glob.maxSyncIdAtLoad;\nlet lastProcessedSyncId = window.glob.maxSyncIdAtLoad;\nlet lastPingTs;\nlet syncDataQueue = [];\n\nfunction logError(message) {\n    console.log(utils.now(), message); // needs to be separate from .trace()\n    console.trace();\n\n    if (ws && ws.readyState === 1) {\n        ws.send(JSON.stringify({\n            type: 'log-error',\n            error: message,\n            stack: new Error().stack\n        }));\n    }\n}\n\nfunction subscribeToMessages(messageHandler) {\n    messageHandlers.push(messageHandler);\n}\n\n// used to serialize sync operations\nlet consumeQueuePromise = null;\n\n// most sync events are sent twice - once immediatelly after finishing the transaction and once during the scheduled ping\n// but we want to process only once\nconst processedSyncIds = new Set();\n\nfunction logRows(syncRows) {\n    const filteredRows = syncRows.filter(row =>\n        !processedSyncIds.has(row.id)\n        && row.entityName !== 'recent_notes'\n        && (row.entityName !== 'options' || row.entityId !== 'openTabs'));\n\n    if (filteredRows.length > 0) {\n        console.debug(utils.now(), \"Sync data: \", filteredRows);\n    }\n}\n\nasync function handleMessage(event) {\n    const message = JSON.parse(event.data);\n\n    for (const messageHandler of messageHandlers) {\n        messageHandler(message);\n    }\n\n    if (message.type === 'sync') {\n        let syncRows = message.data;\n        lastPingTs = Date.now();\n\n        $outstandingSyncsCount.html(message.outstandingSyncs);\n\n        if (syncRows.length > 0) {\n            logRows(syncRows);\n\n            syncDataQueue.push(...syncRows);\n\n            // we set lastAcceptedSyncId even before sync processing and send ping so that backend can start sending more updates\n            lastAcceptedSyncId = Math.max(lastAcceptedSyncId, syncRows[syncRows.length - 1].id);\n            sendPing();\n\n            // first wait for all the preceding consumers to finish\n            while (consumeQueuePromise) {\n                await consumeQueuePromise;\n            }\n\n            try {\n                // it's my turn so start it up\n                consumeQueuePromise = consumeSyncData();\n\n                await consumeQueuePromise;\n            }\n            finally {\n                // finish and set to null to signal somebody else can pick it up\n                consumeQueuePromise = null;\n            }\n        }\n    }\n    else if (message.type === 'sync-hash-check-failed') {\n        toastService.showError(\"Sync check failed!\", 60000);\n    }\n    else if (message.type === 'consistency-checks-failed') {\n        toastService.showError(\"Consistency checks failed! See logs for details.\", 50 * 60000);\n    }\n}\n\nlet syncIdReachedListeners = [];\n\nfunction waitForSyncId(desiredSyncId) {\n    if (desiredSyncId <= lastProcessedSyncId) {\n        return Promise.resolve();\n    }\n\n    console.debug(\"Waiting for\", desiredSyncId, 'current is', lastProcessedSyncId);\n\n    return new Promise((res, rej) => {\n        syncIdReachedListeners.push({\n            desiredSyncId,\n            resolvePromise: res,\n            start: Date.now()\n        })\n    });\n}\n\nfunction waitForMaxKnownSyncId() {\n    return waitForSyncId(server.getMaxKnownSyncId());\n}\n\nfunction checkSyncIdListeners() {\n    syncIdReachedListeners\n        .filter(l => l.desiredSyncId <= lastProcessedSyncId)\n        .forEach(l => l.resolvePromise());\n\n    syncIdReachedListeners = syncIdReachedListeners\n        .filter(l => l.desiredSyncId > lastProcessedSyncId);\n\n    syncIdReachedListeners.filter(l => Date.now() > l.start - 60000)\n        .forEach(l => console.log(`Waiting for syncId ${l.desiredSyncId} while current is ${lastProcessedSyncId} for ${Math.floor((Date.now() - l.start) / 1000)}s`));\n}\n\nasync function runSafely(syncHandler, syncData) {\n    try {\n        return await syncHandler(syncData);\n    }\n    catch (e) {\n        console.log(`Sync handler failed with ${e.message}: ${e.stack}`);\n    }\n}\n\n/**\n * TODO: we should rethink the fact that each sync row is sent twice (once at the end of transaction, once periodically)\n *       and we keep both lastProcessedSyncId and processedSyncIds\n *       it even seems incorrect that when transaction sync rows are received, we incorrectly increase lastProcessedSyncId\n *       and then some syncs might lost (or are *all* sync rows sent from transactions?)\n */\nasync function consumeSyncData() {\n    if (syncDataQueue.length > 0) {\n        const allSyncRows = syncDataQueue;\n        syncDataQueue = [];\n\n        const nonProcessedSyncRows = allSyncRows.filter(sync => !processedSyncIds.has(sync.id));\n\n        try {\n            await utils.timeLimit(processSyncRows(nonProcessedSyncRows), 5000);\n        }\n        catch (e) {\n            logError(`Encountered error ${e.message}: ${e.stack}, reloading frontend.`);\n\n            // if there's an error in updating the frontend then the easy option to recover is to reload the frontend completely\n            utils.reloadApp();\n        }\n\n        for (const syncRow of nonProcessedSyncRows) {\n            processedSyncIds.add(syncRow.id);\n        }\n\n        lastProcessedSyncId = Math.max(lastProcessedSyncId, allSyncRows[allSyncRows.length - 1].id);\n    }\n\n    checkSyncIdListeners();\n}\n\nfunction connectWebSocket() {\n    const loc = window.location;\n    const webSocketUri = (loc.protocol === \"https:\" ? \"wss:\" : \"ws:\")\n                       + \"//\" + loc.host + loc.pathname;\n\n    // use wss for secure messaging\n    const ws = new WebSocket(webSocketUri);\n    ws.onopen = () => console.debug(utils.now(), `Connected to server ${webSocketUri} with WebSocket`);\n    ws.onmessage = handleMessage;\n    // we're not handling ws.onclose here because reconnection is done in sendPing()\n\n    return ws;\n}\n\nasync function sendPing() {\n    if (Date.now() - lastPingTs > 30000) {\n        console.log(utils.now(), \"Lost websocket connection to the backend. If you keep having this issue repeatedly, you might want to check your reverse proxy (nginx, apache) configuration and allow/unblock WebSocket.\");\n    }\n\n    if (ws.readyState === ws.OPEN) {\n        ws.send(JSON.stringify({\n            type: 'ping',\n            lastSyncId: lastAcceptedSyncId\n        }));\n    }\n    else if (ws.readyState === ws.CLOSED || ws.readyState === ws.CLOSING) {\n        console.log(utils.now(), \"WS closed or closing, trying to reconnect\");\n\n        ws = connectWebSocket();\n    }\n}\n\nsetTimeout(() => {\n    ws = connectWebSocket();\n\n    lastPingTs = Date.now();\n\n    setInterval(sendPing, 1000);\n}, 0);\n\nsubscribeToMessages(message => {\n    if (message.type === 'sync-pull-in-progress') {\n        toastService.showPersistent({\n            id: 'sync',\n            title: \"Sync status\",\n            message: \"Sync update in progress\",\n            icon: \"refresh\"\n        });\n    }\n    else if (message.type === 'sync-pull-finished') {\n        // this gives user a chance to see the toast in case of fast sync finish\n        setTimeout(() => toastService.closePersistent('sync'), 1000);\n    }\n});\n\nasync function processSyncRows(syncRows) {\n    const missingNoteIds = [];\n\n    for (const {entityName, entity} of syncRows) {\n        if (entityName === 'branches' && !(entity.parentNoteId in treeCache.notes)) {\n            missingNoteIds.push(entity.parentNoteId);\n        }\n        else if (entityName === 'attributes'\n              && entity.type === 'relation'\n              && entity.name === 'template'\n              && !(entity.noteId in treeCache.notes)) {\n\n            missingNoteIds.push(entity.value);\n        }\n    }\n\n    if (missingNoteIds.length > 0) {\n        await treeCache.reloadNotes(missingNoteIds);\n    }\n\n    const loadResults = new LoadResults(treeCache);\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'notes')) {\n        const note = treeCache.notes[sync.entityId];\n\n        if (note) {\n            note.update(sync.entity);\n            loadResults.addNote(sync.entityId, sync.sourceId);\n        }\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'branches')) {\n        let branch = treeCache.branches[sync.entityId];\n        const childNote = treeCache.notes[sync.entity.noteId];\n        const parentNote = treeCache.notes[sync.entity.parentNoteId];\n\n        if (branch) {\n            branch.update(sync.entity);\n            loadResults.addBranch(sync.entityId, sync.sourceId);\n\n            if (sync.entity.isDeleted) {\n                if (childNote) {\n                    childNote.parents = childNote.parents.filter(parentNoteId => parentNoteId !== sync.entity.parentNoteId);\n                    delete childNote.parentToBranch[sync.entity.parentNoteId];\n                }\n\n                if (parentNote) {\n                    parentNote.children = parentNote.children.filter(childNoteId => childNoteId !== sync.entity.noteId);\n                    delete parentNote.childToBranch[sync.entity.noteId];\n                }\n            }\n            else {\n                if (childNote) {\n                    childNote.addParent(branch.parentNoteId, branch.branchId);\n                }\n\n                if (parentNote) {\n                    parentNote.addChild(branch.noteId, branch.branchId);\n                }\n            }\n        }\n        else if (!sync.entity.isDeleted) {\n            if (childNote || parentNote) {\n                branch = new Branch(treeCache, sync.entity);\n                treeCache.branches[branch.branchId] = branch;\n\n                loadResults.addBranch(sync.entityId, sync.sourceId);\n\n                if (childNote) {\n                    childNote.addParent(branch.parentNoteId, branch.branchId);\n                }\n\n                if (parentNote) {\n                    parentNote.addChild(branch.noteId, branch.branchId);\n                }\n            }\n        }\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'note_reordering')) {\n        for (const branchId in sync.positions) {\n            const branch = treeCache.branches[branchId];\n\n            if (branch) {\n                branch.notePosition = sync.positions[branchId];\n            }\n        }\n\n        loadResults.addNoteReordering(sync.entityId, sync.sourceId);\n    }\n\n    // missing reloading the relation target note\n    for (const sync of syncRows.filter(sync => sync.entityName === 'attributes')) {\n        let attribute = treeCache.attributes[sync.entityId];\n        const sourceNote = treeCache.notes[sync.entity.noteId];\n        const targetNote = sync.entity.type === 'relation' && treeCache.notes[sync.entity.value];\n\n        if (attribute) {\n            attribute.update(sync.entity);\n            loadResults.addAttribute(sync.entityId, sync.sourceId);\n\n            if (sync.entity.isDeleted) {\n                if (sourceNote) {\n                    sourceNote.attributes = sourceNote.attributes.filter(attributeId => attributeId !== attribute.attributeId);\n                }\n\n                if (targetNote) {\n                    targetNote.targetRelations = targetNote.targetRelations.filter(attributeId => attributeId !== attribute.attributeId);\n                }\n            }\n        }\n        else if (!sync.entity.isDeleted) {\n            if (sourceNote || targetNote) {\n                attribute = new Attribute(treeCache, sync.entity);\n\n                treeCache.attributes[attribute.attributeId] = attribute;\n\n                loadResults.addAttribute(sync.entityId, sync.sourceId);\n\n                if (sourceNote && !sourceNote.attributes.includes(attribute.attributeId)) {\n                    sourceNote.attributes.push(attribute.attributeId);\n                }\n\n                if (targetNote && !targetNote.targetRelations.includes(attribute.attributeId)) {\n                    targetNote.targetRelations.push(attribute.attributeId);\n                }\n            }\n        }\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'note_contents')) {\n        delete treeCache.noteComplementPromises[sync.entityId];\n\n        loadResults.addNoteContent(sync.entityId, sync.sourceId);\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'note_revisions')) {\n        loadResults.addNoteRevision(sync.entityId, sync.noteId, sync.sourceId);\n    }\n\n    for (const sync of syncRows.filter(sync => sync.entityName === 'options')) {\n        if (sync.entity.name === 'openTabs') {\n            continue; // only noise\n        }\n\n        options.set(sync.entity.name, sync.entity.value);\n\n        loadResults.addOption(sync.entity.name);\n    }\n\n    if (!loadResults.isEmpty()) {\n        if (loadResults.hasAttributeRelatedChanges()) {\n            noteAttributeCache.invalidate();\n        }\n\n        const appContext = (await import(\"./app_context.js\")).default;\n        await appContext.triggerEvent('entitiesReloaded', {loadResults});\n    }\n}\n\nexport default {\n    logError,\n    subscribeToMessages,\n    waitForSyncId,\n    waitForMaxKnownSyncId\n};\n","import utils from '../services/utils.js';\n\n/**\n * Abstract class for all components in the Trilium's frontend.\n *\n * Contains also event implementation with following properties:\n * - event / command distribution is synchronous which among others mean that events are well ordered - event\n *   which was sent out first will also be processed first by the component\n * - execution of the event / command is asynchronous - each component executes the event on its own without regard for\n *   other components.\n * - although the execution is async, we are collecting all the promises and therefore it is possible to wait until the\n *   event / command is executed in all components - by simply awaiting the `triggerEvent()`.\n */\nexport default class Component {\n    constructor() {\n        this.componentId = `comp-` + utils.randomString(8);\n        /** @type Component[] */\n        this.children = [];\n        this.initialized = Promise.resolve();\n    }\n\n    setParent(parent) {\n        /** @type Component */\n        this.parent = parent;\n        return this;\n    }\n\n    child(...components) {\n        for (const component of components) {\n            component.setParent(this);\n\n            this.children.push(component);\n        }\n\n        return this;\n    }\n\n    /** @return {Promise} */\n    handleEvent(name, data) {\n        return Promise.all([\n            this.initialized.then(() => this.callMethod(this[name + 'Event'], data)),\n            this.handleEventInChildren(name, data)\n        ]);\n    }\n\n    /** @return {Promise} */\n    triggerEvent(name, data) {\n        return this.parent.triggerEvent(name, data);\n    }\n\n    /** @return {Promise} */\n    handleEventInChildren(name, data) {\n        const promises = [];\n\n        for (const child of this.children) {\n            promises.push(child.handleEvent(name, data));\n        }\n\n        return Promise.all(promises);\n    }\n\n    /** @return {Promise} */\n    triggerCommand(name, data = {}) {\n        const fun = this[name + 'Command'];\n\n        if (fun) {\n            return this.callMethod(fun, data);\n        }\n        else {\n            return this.parent.triggerCommand(name, data);\n        }\n    }\n\n    async callMethod(fun, data) {\n        if (typeof fun !== 'function') {\n            return false;\n        }\n\n        await fun.call(this, data);\n\n        return true;\n    }\n}\n"],"sourceRoot":""}